<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  
  <!-- Relative Navigation -->
  
  <link rel="up" href="drm_47.html" />
  <link rel="prev" href="drm_48.html" />
  <link rel="next" href="drm_50.html" />
  
  <!-- Absolute Navigation -->
  
  <link rel="top" href="drm_1.html" />
  <link rel="start first" href="index.html" />
  <link rel="copyright" href="drm_2.html" />
  <link rel="contents" href="drm_3.html" />
  <link rel="glossary" href="drm_126.html" />
  <link rel="index" href="drm_127.html" />
  <link rel="last author" href="drm_128.html" />
  
  <!-- Chapters -->
  
  <link rel="chapter" title="About This Book" href="drm_4.html" />
  <link rel="chapter" title="1 Introduction" href="drm_5.html" />
  <link rel="chapter" title="2 Syntax" href="drm_9.html" />
  <link rel="chapter" title="3 Program Structure" href="drm_25.html" />
  <link rel="chapter" title="4 Program Control" href="drm_28.html" />
  <link rel="chapter" title="5 Types and Classes" href="drm_38.html" />
  <link rel="chapter" title="6 Functions" href="drm_47.html" />
  <link rel="chapter" title="7 Conditions" href="drm_52.html" />
  <link rel="chapter" title="8 Collections" href="drm_59.html" />
  <link rel="chapter" title="9 Sealing" href="drm_70.html" />
  <link rel="chapter" title="10 Macros" href="drm_76.html" />
  <link rel="chapter" title="11 The Built-In Classes" href="drm_87.html" />
  <link rel="chapter" title="12 The Built-In Functions" href="drm_96.html" />
  <link rel="chapter" title="13 Other Built-In Objects" href="drm_108.html" />
  <link rel="chapter" title="14 The Built-In Macros and Special Definitions" href="drm_110.html" />
  
  <!-- Appendices -->
  
  <link rel="appendix" title="A BNF" href="drm_116.html" />
  <link rel="appendix" title="B Exported Names" href="drm_119.html" />
  
  <!-- Stylesheet -->
  
  <link title="main style sheet" rel="stylesheet" href="drm.css" type="text/css" />

  <title>The Dylan Reference Manual: Parameter Lists</title>
</head>
<body>

<div class="wm-div-body">
<a name="HEADING49"></a>

<div class="wm-div-headers">
<div id="navigation-header">
    <p id="book-title">The Dylan Reference Manual</p>
    <p id="basic-navigation"><a class="previous" title="Go to previous page" href="drm_48.html"><img alt="Previous" src="prev.gif" /></a> <a class="next" title="Go to next page" href="drm_50.html"><img alt="Next" src="next.gif" /></a> <a class="up" title="Go to start of chapter" href="drm_47.html"><img alt="Up" src="up.gif" /></a> <a class="start" title="Go to start of book" href="drm_1.html"><img alt="Top" src="top.gif" /></a> <a class="contents" title="Go to table of contents" href="drm_3.html"><img alt="Contents" src="content.gif" /></a> <a class="index" title="Go to index" href="drm_127.html"><img alt="index" src="index.gif" /></a></p>
  </div>

<div id="section-header">
  <p id="section-prefix">Chapter 6</p>
  <p id="section-name">Functions</p>
</div>

<div id="navigation-TOC">
  <ul class="front-matter">
    <li><a href="drm_1.html">Start</a></li>
    <li><a href="drm_3.html">Contents</a></li>
    <li><a href="drm_4.html">About This Book</a></li>
  </ul>
  <ol class="chapters">
    <li><a href="drm_5.html">Introduction</a></li>
    <li><a href="drm_9.html">Syntax</a></li>
    <li><a href="drm_25.html">Program Structure</a></li>
    <li><a href="drm_28.html">Program Control</a></li>
    <li><a href="drm_38.html">Types and Classes</a></li>
    <li><a href="drm_47.html">Functions</a>
      <ul>
	<li><a href="drm_48.html">Overview</a></li>
	<li id="current">Parameter Lists
	  <ul>
	    <li><a href="#HEADING49-4">Kinds of Parameters</a></li>
	    <li><a href="#HEADING49-14">Kinds of Parameter Lists</a></li>
	    <li><a href="#HEADING49-32">Specializing Required Parameters</a></li>
	    <li><a href="#HEADING49-44">Keyword Parameters</a></li>
	    <li><a href="#HEADING49-68">Return Value Declarations</a></li>
	    <li><a href="#HEADING49-84">Parameter List Congruency</a></li>
	    <li><a href="#HEADING49-102">Parameter Lists of Implicitly Defined Generic Functions</a></li>
	  </ul>
	</li>
	<li><a href="drm_50.html">Method Dispatch</a></li>
	<li><a href="drm_51.html">Operations on Functions</a></li>
      </ul>
    </li>
    <li><a href="drm_52.html">Conditions</a></li>
    <li><a href="drm_59.html">Collections</a></li>
    <li><a href="drm_70.html">Sealing</a></li>
    <li><a href="drm_76.html">Macros</a></li>
    <li><a href="drm_87.html">The Built-In Classes</a></li>
    <li><a href="drm_96.html">The Built-In Functions</a></li>
    <li><a href="drm_108.html">Other Built-In Objects</a></li>
    <li><a href="drm_110.html">The Built-In Macros and Special Definitions</a></li>
  </ol>
  <ol class="appendices">
    <li><a href="drm_116.html">BNF</a></li>
    <li><a href="drm_119.html">Exported Names</a></li>
  </ol>
  <ul class="back-matter">
    <li><a href="drm_126.html">Glossary</a></li>
    <li><a href="drm_127.html">Index</a></li>
    <li><a href="drm_128.html">Colophon</a></li>
  </ul>
  <ul class="errata">
    <li><a href="drm_errata.html">Errata</a></li>
  </ul>
</div>

<hr />

</div>

<a name="HEADING49-0"></a>
<a name="UID-Functions-2254"></a>
<h1 class="H1.Heading1"><a name="MARKER-9-782"></a>Parameter Lists</h1>
<p class="T1.Text1"><a name="MARKER-2-783"></a>The parameter list of a function describes the number and types of the arguments that the function accepts, and the number and types of the values it returns.</p>
<p class="T1.Text1"><a name="MARKER-2-784"></a>The parameter list of a generic function is used to define the overall protocol of the generic function. It constrains the methods that may be added to the generic function, through the parameter list congruency rules described on <a href="#MARKER-9-837" class="T1.Text1">page 93</a>. It may also specify that calls to the generic function may contain any keyword arguments.</p>
<p class="T1.Text1"><a name="MARKER-2-785"></a>The parameter list of a method specifies the types of arguments to which the method is applicable, and declares local bindings to which those arguments will be bound during the execution of the body of the method. It may also declare the return value types of the method.</p>
<a name="HEADING49-4"></a>
<a name="UID-Functions-4841"></a>
<h2 class="H2.Heading2">Kinds of Parameters</h2>
<p class="T1.Text1"><a name="MARKER-2-786"></a>Dylan parameter lists support <strong class="T1.Text1"><a name="MARKER-2-787"></a>required parameters</strong>, <strong class="T1.Text1"><a name="MARKER-2-788"></a>rest parameters</strong>, <strong class="T1.Text1"><a name="MARKER-2-789"></a>keyword parameters</strong>, and sometimes a <strong class="T1.Text1"><a name="MARKER-2-790"></a>next-method parameter</strong>. They also may include <strong class="T1.Text1"><a name="MARKER-2-791"></a>return value declarations</strong>.</p>
<p class="T1.Text1">The complete syntax of parameter lists is given in <a href="drm_118.html#MARKER-9-2115" class="T1.Text1">"Methods" on page 426</a>.</p>
<p class="T1.Text1">Required parameters correspond to arguments that must be supplied when a function is called. The arguments are supplied in a fixed order and must appear before any other arguments.</p>
<p class="T1.Text1">Each required parameter may be a name or a name <strong class="T1.Text1"><a name="MARKER-2-792"></a>specialized</strong> by a type. Specifying a type declares that supplied argument must be a general instance of that type.</p>
<p class="T1.Text1">A rest parameter allows a function to accept an unlimited number of arguments.<a rel="FOOTNOTE" href="#FOOTNOTE-3" class="T1.Text1"><sup>[3]</sup></a>  After the required arguments of a function have been supplied, any additional arguments are collected in a sequence, which is passed as the value of the rest parameter. <a name="MARKER-2-793"></a>This sequence may be immutable, and it may or may not be freshly allocated. The types of rest parameters cannot be declared.</p>
<p class="T1.Text1"><a name="MARKER-2-794"></a><a name="MARKER-2-795"></a>Keyword parameters correspond to arguments that are optional and may be given in any order. Symbols are used among the arguments to guide matching of arguments to parameters. These symbols are usually written in keyword syntax and so they are known as keywords. Keyword arguments can only be supplied after all required arguments are supplied. Keyword parameters may be specialized, restricting which values may be supplied for them. Keyword parameters may also be given default values to be used when the caller does not supply a value.</p>
<p class="T1.Text1"><a name="MARKER-2-796"></a><a name="MARKER-2-797"></a>Required parameters come first in the parameter list, followed by the rest parameter, if any, and then the keyword parameters, if any. A rest parameter is indicated by the token <code>#rest</code> followed by the name of the parameter. Keyword parameters are indicated by the token <code>#key</code> followed by the keyword parameter specifiers, optionally followed by the token <code>#all-keys</code>.</p>
<p class="T1.Text1">If <code>#rest</code> and <code>#key</code> are used in the same parameter list, <code>#rest</code> must come first. The rest parameter will be bound to a sequence containing all the keyword arguments and their corresponding values.</p>
<p class="T1.Text1"><a name="MARKER-2-798"></a>A next-method parameter is indicated by the token <code>#next</code>, followed by the name of the parameter. It is not normally necessary to specify a next-method parameter explicitly. If a next-method parameter is not specified by the programmer, <code>define method</code> inserts one with the name <code>next-method</code>. If an explicit next-method parameter is given, it must come after the required parameters and before the rest and keyword parameters. Details of using next-method are given in <a href="drm_50.html#MARKER-9-858" class="T1.Text1">"Calling Less Specific Methods" on page 98</a>.<a name="MARKER-2-799"></a></p>
<a name="HEADING49-14"></a>
<a name="UID-Functions-2273"></a>
<h2 class="H2.Heading2"><a name="MARKER-9-800"></a>Kinds of Parameter Lists</h2>
<p class="T1.Text1"><a name="MARKER-2-801"></a>Each function (generic function or method) has an argument passing protocol specified by its parameter list. The argument passing protocol for a method must be compatible with the argument passing protocol of any generic function to which it is added, as described in <a href="#MARKER-9-837" class="T1.Text1">"Parameter List Congruency" on page 93</a>.</p>
<p class="T1.Text1">The argument passing protocol of a function can be described in one of the following ways:</p>
<ul class="B1.Bullet1">
<li class="B1.Bullet1">A function is said to <strong class="B1.Bullet1"><a name="MARKER-2-802"></a>require a fixed number of arguments</strong> if its parameter list does not specify either <code><a name="MARKER-2-803"></a>#rest</code> or <code><a name="MARKER-2-804"></a>#key</code>.</li>
<li class="B1.Bullet1">A function is said to <strong class="B1.Bullet1"><a name="MARKER-2-805"></a>accept keyword arguments</strong> if its parameter list specifies <code>#key</code>. The parameter list could also specify <code>#rest</code> if it is a method, but not if it is a generic function.</li>
<li class="B1.Bullet1">A function is said to <strong class="B1.Bullet1"><a name="MARKER-2-806"></a>accept all keyword arguments</strong> if its parameter list specifies <code>#all-keys</code> in addition to <code>#key</code>.</li>
<li class="B1.Bullet1">A function is said to <strong class="B1.Bullet1"><a name="MARKER-2-807"></a>accept a variable number of arguments</strong> if its parameter list specifies <code>#rest</code> but does not specify <code>#key</code>. (Note: If the parameter list specifies <code>#key</code> in addition to <code>#rest</code> it is not said to accept a variable number of arguments.)</li>
</ul>
<p class="T1.Text1">A method that accepts keyword arguments is said to <strong class="T1.Text1"><a name="MARKER-2-808"></a>recognize</strong> the keywords mentioned in its parameter list. (A method may, of course, mention them in the parameter list and then ignore their values. It is still said to recognize them.)  It is possible for a method to accept keyword arguments in general but not recognize any particular keywords; it does this by specifying <code>#key</code> without any subsequent keyword parameters.</p>
<p class="T1.Text1">If a generic function that accepts keyword arguments mentions any specific keyword arguments in its parameter list, these are the <strong class="T1.Text1"><a name="MARKER-2-809"></a>mandatory keywords</strong> of the generic function. Every method added to the generic function must recognize these keywords.</p>
<p class="T1.Text1">A function may accept all keyword arguments by specifying <code>#all-keys</code> in its parameter list.<a name="MARKER-2-810"></a><a name="MARKER-2-811"></a><a name="MARKER-2-812"></a></p>
<p class="T1.Text1">When a function that accepts keyword arguments is called, it is said to <strong class="T1.Text1"><a name="MARKER-2-813"></a>permit</strong> a keyword argument in the call if one of the following is true:</p>
<ul>
<li class="B1.Bullet1">The function is a method that recognizes the keyword.</li>
<li class="B1.Bullet1">The function is a generic function and the keyword is recognized by any of the applicable methods of the call.</li>
<li class="B1.Bullet1">The function accepts all keyword arguments.</li>
<li class="B1.Bullet1">The function is a generic function and any of the applicable methods of the call accepts all keyword arguments.</li>
</ul>
<p class="T1.Text1"><a name="MARKER-2-814"></a>If a function that accepts keyword arguments is called, it will signal an error if called with a keyword argument that it does not permit, or if the arguments following the required arguments are not keyword/value pairs. This is true even if the function specifies <code>#rest</code>.</p>
<p class="T1.Text1">If a method is called via a generic function or via next-method (rather than directly), the method itself does not check whether it received any keyword arguments it does not permit, nor does it check that the arguments following the required arguments are keyword/value pairs. This check is performed by the generic function or next-method, and is made relative to the call as a whole, not relative to an individual method or the methods remaining to be called.</p>
<p class="T1.Text1"><a name="MARKER-2-815"></a>A call to a function may supply the same keyword argument more than once. When this is done, the leftmost keyword/value pair is used.<a name="MARKER-2-816"></a></p>
<a name="HEADING49-32"></a>
<a name="UID-Functions-2288"></a>
<h2 class="H2.Heading2">Specializing Required Parameters</h2>
<p class="T1.Text1"><a name="MARKER-2-817"></a>When you define a generic function or method, you may specify the types of the arguments appropriate for the generic function or method. This is called <strong class="T1.Text1"><a name="MARKER-2-818"></a>specializing</strong> the generic function or method, or specializing the parameters of the generic function or method.</p>
<p class="T1.Text1">The following example defines a method specialized on <code>&lt;number&gt;</code>. The method will be applicable when <code>double</code> is called on a general instance of <code>&lt;number&gt;</code>.</p>
<pre class="Cv.Code">
define method double (thing :: &lt;number&gt;)
  thing + thing;
end method;
</pre>
<p class="T1.Text1">Specialization constrains the values that may be passed as the value of a parameter. The function can be called only with arguments that are instances of the specializers of the corresponding parameters.</p>
<p class="T1.Text1">Specialization is useful in three way:</p>
<ul class="B1.Bullet1">
<li class="B1.Bullet1">It makes the intent of the program clear. It indicates to the compiler and to anyone reading the code that an error is signaled if an argument is not of the specializer type.</li>
<li class="B1.Bullet1">It allows the compiler to perform additional optimizations.</li>
<li class="B1.Bullet1"><a name="MARKER-2-819"></a>It is used to control method dispatch. By defining methods on the same generic function with different specializers, you can define behavior applicable to different sets of types. A generic function chooses among its methods on the basis of the methods' specializers. The generic function chooses the method whose specializers most closely match the types of the arguments.</li>
</ul>
<p class="T1.Text1">Syntactically, specializers are operands. These operands are executed once when the function is created. They are not re-executed each time the function is called. The value of the operand must be a type.</p>
<p class="T1.Text1">It is most common for specializers to be constant module bindings or calls to a built-in type constructor such as <code>singleton</code>, <code>limited</code>, or <code>type-union</code>.</p>
<p class="T1.Text1">There is a convenient syntax for singleton specializers, which is equivalent to explicitly calling <code>singleton</code> in the current lexical scope.<a name="MARKER-2-820"></a></p>
<a name="HEADING49-44"></a>
<a name="UID-Functions-2308"></a>
<h2 class="H2.Heading2">Keyword Parameters</h2>
<p class="T1.Text1"><a name="MARKER-2-821"></a>The syntax of a keyword parameter is:</p>
<p><strong style="font-size: larger">[</strong> <var>keyword</var> <strong style="font-size: larger">]</strong> <var>name</var> <strong style="font-size: larger">[</strong> <code>::</code> <var>operand</var> <strong style="font-size: larger">]</strong> <strong style="font-size: larger">[</strong> <code>=</code> <var>expression</var> <strong style="font-size: larger">]</strong></p>
<p class="T1.Text1">If <var>keyword</var> is not supplied, then <var>name</var> is used to indicate both the keyword and the name of the parameter. If the <var>keyword</var> and <var>name</var> are given independently, the <var>keyword</var> is used when calling the method, and the <var>name</var> is used as the name of the parameter inside the body of the method.</p>
<p class="T1.Text1"><a name="MARKER-2-822"></a>The <var>expression</var> supplies a default value for the parameter. It is used when the method is called and the keyword is not supplied. It is executed each time the method is called and the corresponding keyword argument is not supplied. If no <var>expression</var> is specified, the parameter corresponding to an unsupplied keyword argument is initialized to <a name="MARKER-2-823"></a><code>#f</code>. The <var>expression</var> is executed in a scope that includes all the preceding parameters, including required parameters, the rest parameter (if any), the preceding keyword parameters, and the next-method parameter (if any).</p>
<p class="T1.Text1">In the following example, all three keyword parameters have default values, and all three use the same name for the keyword and the parameter.</p>
<pre class="Cv.Code">
define method percolate (#key brand = #&quot;maxwell-house&quot;,
                              cups = 4,
                              strength = #&quot;strong&quot;)
  make-coffee (brand, cups, strength);
end method;
</pre>
<p class="T1.Text1">The caller can choose which keyword arguments to supply and what order to supply them in:</p>
<p class="T1.Text1"><code>percolate (brand: #&quot;ja<a name="MARKER-2-824"></a>va&quot;, cups: 10);<br />percolate (strength: #&quot;strong&quot;,<br />           brand: #&quot;st<a name="MARKER-2-825"></a>arbucks&quot;,<br />            cups: 1);</code></p>
<p class="T1.Text1">The following method has two keyword parameters. In each, the name of the keyword and the name of the parameter is specified separately. The first keyword parameter has a default value, the second does not.</p>
<pre class="Cv.Code">
define method layout (widget, #key position: the-pos = 0,
                                   size: the-size)
  let the-sibling = sibling (widget);
  unless (the-pos = position (the-sibling))
    align-objects (widget, the-sibling, the-pos, the-size);
end method;
layout(my-widget, position: 100, size: 500);
layout(my-widget, size: query-user-for-size() );
</pre>
<p class="T1.Text1"><a name="MARKER-2-826"></a>The keyword parameter syntax in which the keyword name and parameter name are given separately is needed to allow keyword names such as <code>position:</code> without forcing the method to use <code>position</code> as a local binding. If a method uses <code>position</code> as a local binding, it cannot access the module binding <code>position</code> (which contains a function). The local binding would shadow the module binding.</p>
<p class="T1.Text1">All required arguments must be supplied before any keyword arguments can be supplied. The following call to <code>layout</code> will signal an error:</p>
<p class="T1.Text1"><code>layout(position: 100, size: 500);</code></p>
<a name="HEADING49-59"></a>
<h3 class="H3.Heading3">Types for Keyword Parameters</h3>
<p class="T1.Text1"><a name="MARKER-2-827"></a>When a type is indicated for a keyword parameter in a method, it is the same as establishing a type for a local binding. Specifically, the types of any keyword parameters are not used for method dispatch. Keyword parameter types are not allowed in generic function definitions, and do not figure into parameter list congruency.</p>
<p class="T1.Text1">The following two method definitions are equivalent:</p>
<pre class="Cv.Code">
method (#key X :: &lt;integer&gt;)
  ... X ...
end method;

method (#key X)
  let X :: &lt;integer&gt; = X;
  ... X ...
end method;
</pre>
<p class="T1.Text1">If a keyword parameter is given a type, if <code>#f</code> is not an instance of that type, and if the keyword parameter is not given a default value, then the keyword parameter is essentially required. An error of type <code>&lt;type-error&gt;</code> will be signaled if a call to the method does not include the keyword.</p>
<p class="T1.Text1">The following examples include keyword parameters that include both a type and a default value.</p>
<pre class="Cv.Code">
define method find-happiness (#key hint :: &lt;symbol&gt; =  #&quot;here&quot;)
  ...
end method find-happiness;

define method find-food (#key hint :: &lt;restaurant&gt;
                              =  lookup-default-restaurant())
  ...
end method find-food;<a name="MARKER-2-828"></a><a name="MARKER-2-829"></a></pre>
<a name="HEADING49-68"></a>
<a name="UID-Functions-2324"></a>
<h2 class="H2.Heading2"><a name="MARKER-2-830"></a>Return Value Declarations<a name="MARKER-2-831"></a></h2>
<p class="T1.Text1">Parameter lists may include value declarations. Value declarations come at the end of the parameter list and are separated from the parameters by <code>=&gt;</code>. For each return value, a value declaration can specify a name and an operand or just a name if the type is <code>&lt;object&gt;</code>. The complete syntax of value declarations is given in <a href="drm_118.html#MARKER-9-2115" class="T1.Text1">"Methods" on page 426</a>.</p>
<p class="T1.Text1">The result of executing the operand at the time the function is defined is a type, called a <strong class="Bold T1.Text1"><a name="MARKER-2-832"></a><dfn>value type</dfn></strong>. The name never comes into scope. It is included for documentation and for syntactic consistency with parameters. It is valid for the same name to be used in both one parameter and one value declaration in the same parameter list; this is useful as documentation that a function returns one of its arguments.</p>
<p class="T1.Text1">The last value declaration can be preceded by <code>#rest</code> to indicate a variable number of return values. A value declaration preceded by <code>#rest</code> is called a <strong class="Bold T1.Text1"><a name="MARKER-2-833"></a><dfn>rest value declaration</dfn></strong>. A value declaration not preceded by <code>#rest</code> is called a <strong class="Bold T1.Text1"><a name="MARKER-2-834"></a><dfn>required value declaration</dfn></strong>. The value type in a rest value declaration is the type of each one of the remaining individual values, not the type of a conceptual sequence of multiple values.</p>
<p class="T1.Text1">If a parameter-list does not contain a value declaration, it defaults to <code>=&gt; #rest x :: &lt;object&gt;</code>. That is, the function can return any number of values of any type.</p>
<p class="T1.Text1">A function will always return the number and types of values declared in its parameter-list. More precisely:</p>
<ul class="B1.Bullet1">
<li class="B1.Bullet1">Each value returned by a function must be an instance of the corresponding value type, or else an error of type <code>&lt;type-error&gt;</code> will be signaled.</li>
<li class="B1.Bullet1"><a name="MARKER-2-835"></a>If fewer values are returned by the function's body (or by the applicable method if the function is a generic function) than the number of required value declarations in the function's parameter-list, the missing values are defaulted to <code>#f</code> and returned. If <code>#f</code> is not an instance of the corresponding value type, an error of type <code>&lt;type-error&gt;</code> is signaled.</li>
<li class="B1.Bullet1">If a function does not have a rest value declaration, and more values are returned by the function's body (or by the applicable method if the function is a generic function) than the number of required value declarations in the function's parameter-list, the extra values are discarded and not returned.</li>
</ul>
<p class="T1.Text1"><a name="MARKER-2-836"></a>Because of the parameter list congruency rules for value declarations (see <a href="#MARKER-9-837" class="T1.Text1">"Parameter List Congruency" on page 93</a>) the values returned by a generic function do not have to be checked by the generic function. The check inside a method will always be enough to verify that the return values are valid for the generic function.</p>
<pre class="Cv.Code">
define method average (x :: &lt;number&gt;, y :: &lt;number&gt;)
 =&gt; mean :: &lt;number&gt;;
 (x + y) / 2
end method;

// Returning multiple values
define method limits (center :: &lt;number&gt;, radius :: &lt;number&gt;)
 =&gt; (min :: &lt;number&gt;, max :: &lt;number&gt;);
 values(center - radius, center + radius);
end method;

// The same name used both as a parameter and as a value type
define method rotate (image :: &lt;picture&gt;, rotation-angle :: &lt;number&gt;)

 =&gt; (image :: &lt;picture&gt;);
 &hellip;
end method;

// This method can return one, two, or three values
define method family (kid :: &lt;person&gt;)
  =&gt; (kid :: &lt;person&gt;, #rest parents);
  let mom = kid.mother;
  let dad = kid.father;
  case
    mom &amp; dad =&gt; values(kid, mom, dad);
    mom =&gt; values(kid, mom);
    dad =&gt; values(kid, dad);
    otherwise =&gt; kid;
  end case
end method family;
</pre>
<p class="T1.Text1">Note that the following example does not declare a return value of type <code>&lt;number&gt;</code>. It declares a return value of type <code>&lt;object&gt;</code>. To specify a type, both the name and the type must be specified. If only one is given, it is taken as the name.</p>
<p class="errata left"><em>Errata:</em> The return value declaration should be:<br />
<code>=&gt; &lt;number&gt;;</code></p>
<pre class="Cv.Code">
define method average (x :: &lt;number&gt;, y :: &lt;number&gt;)
 =&gt; avg :: &lt;number&gt;;
 truncate/((x + y), 2);
end method;
</pre>
<a name="HEADING49-84"></a>
<a name="UID-Functions-2334"></a>
<h2 class="H2.Heading2"><a name="MARKER-9-837"></a>Parameter List Congruency</h2>
<p class="T1.Text1"><a name="MARKER-2-838"></a>For any given generic function, the generic function and all methods for that function must have <strong class="T1.Text1">congruent parameter lists</strong>. Two parameter lists are congruent if they satisfy the following conditions:</p>
<ul class="B1.Bullet1">
  <li class="B1.Bullet1">They have the same number of required arguments.</li>
  <li class="B1.Bullet1">Each of the method's parameter specializers is a subtype of the corresponding parameter specializer of the generic function.</li>
  <li class="B1.Bullet1">One of the following is true:
    <ul class="B2.Bullet2">
      <li class="B2.Bullet2">both accept keyword arguments</li>
      <li class="B2.Bullet2">both accept a variable number of arguments</li>
      <li class="B2.Bullet2">both require a fixed number of arguments</li>
    </ul>
  </li>
  <li class="B1.Bullet1">If the generic function accepts keyword arguments, each method must recognize the mandatory keywords of the generic function.</li>
</ul>
<p class="T1.Text1">In addition, the value declarations must be congruent, defined as follows:</p>
<ul>
  <li class="B1.Bullet1">If the generic function's parameter list does not contain a rest value declaration, then
    <ul class="B2.Bullet2">
      <li class="B2.Bullet2">The method's parameter list must not contain a rest value declaration.</li>
      <li class="B2.Bullet2">The two parameter lists must contain the same number of required value declarations.</li>
      <li class="B2.Bullet2">Each value type in the method's parameter list must be a subtype of the corresponding value type in the generic function's parameter list.</li>
    </ul>
  </li>
  <li class="B1.Bullet1"><a name="MARKER-2-839"></a>If the generic function's parameter list contains a rest value declaration, then:
    <ul class="B2.Bullet2">
      <li class="B2.Bullet2">The method's parameter list is permitted, but not required, to contain a rest value declaration.</li>
      <li class="B2.Bullet2">The method's parameter list must contain at least as many required value declarations as the generic function's parameter list.</li>
      <li class="B2.Bullet2">Each value type in the method's parameter list must be a subtype of the corresponding value type in the generic function's parameter list. If the method has a rest value type, it corresponds to the generic function's rest value type. If the method has more required value types than the generic function, the extra ones must be subtypes of the generic function's rest value type.<a name="MARKER-2-840"></a></li>
    </ul>
  </li>
</ul>
<a name="HEADING49-102"></a>
<a name="UID-Functions-3556"></a>
<h2 class="H2.Heading2">Parameter Lists of Implicitly Defined Generic Functions</h2>
<p class="T1.Text1"><a name="MARKER-2-841"></a>As a general principle, the parameter list of an implicitly defined generic function will impose as few constraints as possible on the methods that may be added. If a more constrained generic function definition is desired, an explicit definition should be used.</p>
<p class="T1.Text1">The parameter list of an implicitly defined generic function is determined by its method definitions. These method definitions include both methods defined using <code>define method</code> and slot getter and setter methods defined using <code>define class</code>.</p>
<ul class="B1.Bullet1">
<li class="B1.Bullet1">The implicitly defined generic function has the same basic argument pattern as the methods. Either they must all require a fixed number of arguments, they must all accept a variable number of arguments, or they must all accept keyword arguments. A set of methods that includes members with more than one of these patterns violates the parameter list congruency requirement, and is an error.</li>
<li class="B1.Bullet1">The implicitly defined generic function has the same number of required arguments as the methods. A set of methods that includes members with different numbers of required arguments violates the parameter list congruency requirement, and is an error.</li>
<li class="B1.Bullet1">Each required argument of the implicitly defined generic function is specialized on <code>&lt;object&gt;</code>.</li>
<li class="B1.Bullet1">If the implicitly defined generic function accepts keyword arguments, it does not have any mandatory keywords, nor does it accept all keyword arguments.</li>
<li class="B1.Bullet1">The implicitly defined generic function has a rest value declaration of <code>&lt;object&gt;</code>.<a name="MARKER-2-842"></a><a name="MARKER-2-843"></a></li>
</ul>

</div>

<div class="wm-div-footnotes">

<div class="wm-div-footnotes">
<hr />

<a name="FOOTNOTE-3"><sup>[3]</sup> </a>
 In practice, an implementation may place a reasonable limit on the number of arguments that may be passed to any function.

</div>

</div>

<div class="wm-div-footers">

<hr class="footer" />
<address class="footer">The Dylan Reference Manual - 7 Apr 1998</address>
<p class="footer"><a class="previous" title="Go to previous page" href="drm_48.html"><img alt="Previous" src="prev.gif" /></a> <a class="next" title="Go to next page" href="drm_50.html"><img alt="Next" src="next.gif" /></a> <a class="up" title="Go to start of chapter" href="drm_47.html"><img alt="Up" src="up.gif" /></a> <a class="start" title="Go to start of book" href="drm_1.html"><img alt="Top" src="top.gif" /></a> <a class="contents" title="Go to table of contents" href="drm_3.html"><img alt="Contents" src="content.gif" /></a> <a class="index" title="Go to index" href="drm_127.html"><img alt="index" src="index.gif" /></a></p>
<p class="footer">Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</p>
<p class="footer">Originally generated with <a href="http://www.harlequin.com/webmaker" class="footer">Harlequin WebMaker&#174;</a>, subsequently revised.</p>

</div>
</body>
</html>
