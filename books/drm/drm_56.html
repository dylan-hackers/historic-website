<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  
  <!-- Relative Navigation -->
  
  <link rel="up" href="drm_52.html" />
  <link rel="prev" href="drm_55.html" />
  <link rel="next" href="drm_57.html" />
  
  <!-- Absolute Navigation -->
  
  <link rel="top" href="drm_1.html" />
  <link rel="start first" href="index.html" />
  <link rel="copyright" href="drm_2.html" />
  <link rel="contents" href="drm_3.html" />
  <link rel="glossary" href="drm_126.html" />
  <link rel="index" href="drm_127.html" />
  <link rel="last author" href="drm_128.html" />
  
  <!-- Chapters -->
  
  <link rel="chapter" title="About This Book" href="drm_4.html" />
  <link rel="chapter" title="1 Introduction" href="drm_5.html" />
  <link rel="chapter" title="2 Syntax" href="drm_9.html" />
  <link rel="chapter" title="3 Program Structure" href="drm_25.html" />
  <link rel="chapter" title="4 Program Control" href="drm_28.html" />
  <link rel="chapter" title="5 Types and Classes" href="drm_38.html" />
  <link rel="chapter" title="6 Functions" href="drm_47.html" />
  <link rel="chapter" title="7 Conditions" href="drm_52.html" />
  <link rel="chapter" title="8 Collections" href="drm_59.html" />
  <link rel="chapter" title="9 Sealing" href="drm_70.html" />
  <link rel="chapter" title="10 Macros" href="drm_76.html" />
  <link rel="chapter" title="11 The Built-In Classes" href="drm_87.html" />
  <link rel="chapter" title="12 The Built-In Functions" href="drm_96.html" />
  <link rel="chapter" title="13 Other Built-In Objects" href="drm_108.html" />
  <link rel="chapter" title="14 The Built-In Macros and Special Definitions" href="drm_110.html" />
  
  <!-- Appendices -->
  
  <link rel="appendix" title="A BNF" href="drm_116.html" />
  <link rel="appendix" title="B Exported Names" href="drm_119.html" />
  
  <!-- Stylesheet -->
  
  <link title="Normal" rel="stylesheet" href="drm.css" type="text/css" />

  <title>The Dylan Reference Manual: Exception Handling</title>
</head>
<body>

<div class="wm-div-body">
<a name="HEADING56"></a>

<div class="wm-div-headers">
<div id="navigation-header">
    <p id="book-title">The Dylan Reference Manual</p>
    <p id="basic-navigation"><a class="previous" title="Go to previous page" href="drm_55.html"><img alt="Previous" src="prev.gif" /></a> <a class="next" title="Go to next page" href="drm_57.html"><img alt="Next" src="next.gif" /></a> <a class="up" title="Go to start of chapter" href="drm_52.html"><img alt="Up" src="up.gif" /></a> <a class="start" title="Go to start of book" href="drm_1.html"><img alt="Top" src="top.gif" /></a> <a class="contents" title="Go to table of contents" href="drm_3.html"><img alt="Contents" src="content.gif" /></a> <a class="index" title="Go to index" href="drm_127.html"><img alt="index" src="index.gif" /></a></p>
  </div>

<div id="section-header">
  <p id="section-prefix">Chapter 7</p>
  <p id="section-name">Conditions</p>
</div>

<div id="navigation-TOC">
  <ul class="front-matter">
    <li><a href="drm_1.html">Start</a></li>
    <li><a href="drm_3.html">Contents</a></li>
    <li><a href="drm_4.html">About This Book</a></li>
  </ul>
  <ol class="chapters">
    <li><a href="drm_5.html">Introduction</a></li>
    <li><a href="drm_9.html">Syntax</a></li>
    <li><a href="drm_25.html">Program Structure</a></li>
    <li><a href="drm_28.html">Program Control</a></li>
    <li><a href="drm_38.html">Types and Classes</a></li>
    <li><a href="drm_47.html">Functions</a></li>
    <li><a href="drm_52.html">Conditions</a>
      <ul>
	<li><a href="drm_53.html">Background</a></li>
	<li><a href="drm_54.html">Overview</a></li>
	<li><a href="drm_55.html">Signalers, Conditions, and Handlers</a></li>
	<li id="current">Exception Handling
	  <ul>
	    <li><a href="#HEADING56-3">Stack Model</a></li>
	    <li><a href="#HEADING56-11">Recovery and Exits</a></li>
	    <li><a href="#HEADING56-22">Restarts</a></li>
	    <li><a href="#HEADING56-25">Recovery Protocols</a></li>
	  </ul>
	</li>
	<li><a href="drm_57.html">Condition Messages</a></li>
	<li><a href="drm_58.html">Introspective Operations</a></li>
      </ul>
    </li>
    <li><a href="drm_59.html">Collections</a></li>
    <li><a href="drm_70.html">Sealing</a></li>
    <li><a href="drm_76.html">Macros</a></li>
    <li><a href="drm_87.html">The Built-In Classes</a></li>
    <li><a href="drm_96.html">The Built-In Functions</a></li>
    <li><a href="drm_108.html">Other Built-In Objects</a></li>
    <li><a href="drm_110.html">The Built-In Macros and Special Definitions</a></li>
  </ol>
  <ol class="appendices">
    <li><a href="drm_116.html">BNF</a></li>
    <li><a href="drm_119.html">Exported Names</a></li>
  </ol>
  <ul class="back-matter">
    <li><a href="drm_126.html">Glossary</a></li>
    <li><a href="drm_127.html">Index</a></li>
    <li><a href="drm_128.html">Colophon</a></li>
  </ul>
  <ul class="errata">
    <li><a href="drm_errata.html">Errata</a></li>
  </ul>
</div>

<hr />

</div>

<a name="HEADING56-0"></a>
<a name="UID-Conditions-1884"></a>
<h1 class="section-title">Exception Handling</h1>
<p class="T0.Text0">A set of classes, functions, and associated conventions extend the underlying condition handling capabilities to provide a complete exception handling facility.</p>
<p class="T1.Text1">The classes are described in <a href="drm_95.html#MARKER-9-1472" class="T1.Text1">"Conditions" on page 244</a>, and the functions are described in <a href="drm_107.html#MARKER-9-1917" class="T1.Text1">"Signaling Conditions" on page 357</a>.</p>
<a name="HEADING56-3"></a>
<a name="UID-Conditions-2155"></a>
<h2 class="subsection-title">Stack Model</h2>
<p class="T1.Text1"><a name="MARKER-2-925"></a>Condition handlers are installed dynamically, with more recent handlers shadowing previously installed handlers. In addition, exception handling often involves the use of <a name="MARKER-2-926"></a>nonlocal exits. For these reasons it is useful to describe the behavior of the exception system using the following terms from the stack model of function calling.</p>
<ul>
  <li><strong><a name="MARKER-2-927"></a>outside stack<br /></strong>The state existing just before the handler was established.</li>
  <li><strong><a name="MARKER-2-928"></a>signaling unit <br /></strong>The conceptual program component that includes the expression that signaled the condition and does not include the expression that established the handler. This informal concept provides a notion of where the interface boundary between the signaler and the handler lies.</li>
  <li><strong><a name="MARKER-2-929"></a>middle stack<br /></strong>The state existing just before the signaling unit was called, minus the outside stack. In other words, the state between the handler and the signaling unit.</li>
  <li><strong><a name="MARKER-2-930"></a>inside stack<br /></strong>The state existing just before signaling occurred, minus the middle stack and outside stack. In other words, the portion of the signaling unit prior to the call to <code>signal</code>.</li>
</ul>
<p class="figure"><strong>Figure</strong> <strong>7-1</strong>  <a name="MARKER-9-931"></a><!-- img alt="dr56ima1" src="dr56ima1.gif" -->The Stack Model</p>

<div class="figure" style="min-width: 399px">
  <img alt="Stack Model Diagram" src="drm_Figure_7-1_Stack_Model.png" width="399" height="337" />
</div>

<p class="T1.Text1">The handler in <a href="#MARKER-9-931" class="T1.Text1">Figure 7-1</a> may either return normally, in which case execution resumes as the call to <code>signal</code> returns normally, or the handler may make a nonlocal exit, such as calling the exit function from a dynamically active <code>block</code> statement.<a name="MARKER-2-932"></a></p>
<a name="HEADING56-11"></a>
<a name="UID-Conditions-2820"></a>
<h2 class="subsection-title">Recovery and Exits</h2>
<p class="T1.Text1"><a name="MARKER-2-933"></a>There are two ways to handle an exception: by recovery or by exit. Recovery involves making some repair to the program state and leaving control in the signaling unit. Exit involves <a name="MARKER-2-934"></a>transferring control outside of the signaling unit through the use of a <a name="MARKER-2-935"></a>nonlocal exit.</p>
<p class="T1.Text1">The simplest way to handle an exception is to exit the signaling unit by taking a nonlocal exit to a target established in the outside stack. The <code>exception</code> clause of the <code><a name="MARKER-2-936"></a>block</code> statement provides a convenient mechanism for accomplishing this.</p>
<p class="T1.Text1">A less common handling style is to exit the signaling unit by taking a nonlocal exit to a target established in the middle stack, thus leaving the handler in force.</p>
<p class="T1.Text1">Instead of exiting, a handler can recover by returning control to the signaling unit. This can be done either by returning values that the signaling unit will understand or by taking a nonlocal exit to a target established in the inside stack.</p>
<p class="T1.Text1">The following examples show three ways of handling a copy-protection violation while copying a series of files. Note that the signaling code does not need to know how the condition will be handled. The only changes are in the code that handles the condition.</p>
<pre class="code">
// Assume there is a class for file-system errors.
// We are interested in a special kind of file-system error
// that occurs when attempting to copy a copy-protected file,
// so we define a new class to indicate such errors.
define class &lt;copy-protection-violation&gt; (&lt;file-system-error&gt;)
  slot file, init-keyword: file:;    // Store the file name
end class;
// Define a function to copy a single file. This
// function signals a &lt;copy-protection-violation&gt; if
// the file is copy-protected.
define method copy-file (source, destination)
  if ( copy-protected?(source) )
    signal(make(&lt;copy-protection-violation&gt;, file: source));
  else
    // copy normally
    notify-user(&quot;Copying %s to %s.&quot;, source, destination);
  end if;
end method;
// The following function copies a sequence of files.
// If one of the files is copy-protected, the user is
// notified, and the remaining files are copied.
define method backup-all-possible (volume, archive)
  let handler &lt;copy-protection-violation&gt;
       = method (condition, next)
           // The handler just notifies the user and continues
           notify-user(&quot;The file %s could not be copied.&quot;,
                       condition.file);
         end method;
  // start copying files, with the handler in effect
  for (each-file in volume)
    copy-file(each-file, archive)
  end for;
end method;
// The following function stops copying as soon as it
// hits a copy-protected file
define method backup-exit (volume, archive)
  // set up a block so we can do a nonlocal exit
  block (exit)
   let handler &lt;copy-protection-violation&gt;
       = method (condition, next)
           // Notify the user and abort the backup
           notify-user(
    &quot;Backup interrupted: the file %s could not be copied.&quot;,
                       condition.file);
           exit(#f);
         end method;
  // start copying files, with the handler in effect
    for (each-file in volume)
      copy-file(each-file, archive)
    end for;
  end block;
end method;
// The following function uses the convenient exception clause of
// the block statement to achieve essentially the same effect as
// as backup-exit.
define method backup-block (volume, archive)
  // get ready to do backups   
  block ()
    // start copying files   
    for (each-file in volume)
      copy-file(each-file, archive)
    end for;
  exception (condition :: &lt;copy-protection-violation&gt;)
    notify-user(
   &quot;Backup interrupted: the file %s could not be copied.&quot;,
                condition.file);
  end block;
end method;<a name="MARKER-2-937"></a>
</pre>
<a name="HEADING56-22"></a>
<a name="UID-Conditions-2199"></a>
<h2 class="subsection-title">Restarts</h2>
<p class="T1.Text1"><a name="MARKER-2-938"></a><a name="MARKER-2-939"></a>Recovering or exiting can be accomplished directly, or a more formal mechanism called <strong class="Bold"><dfn>restarting</dfn></strong> can be used. Using restarts provides more assurance that the handler and the signaling unit agree on the meaning of what they are doing and provides some isolation of the handler from names and data representations internal to the signaling unit.</p>
<p class="T1.Text1">A handler restarts by signaling a restart. All restarts are instances of <code><a name="MARKER-2-940"></a>&lt;restart&gt;</code>. Any values needed for recovery are passed in the restart (that is, in initialization arguments that the restart remembers, typically in slots). The restart is handled by a <a name="MARKER-2-941"></a>restart handler that either <a name="MARKER-2-942"></a>returns or takes a <a name="MARKER-2-943"></a>nonlocal exit. If the restart handler returns some values, <code>signal</code> returns those values and the handler that called <code>signal</code> also returns them. The call to <code>signal</code> from the signaling unit that signaled the original condition returns the same values, and the signaling unit recovers as directed by those values.<a name="MARKER-2-944"></a></p>
<a name="HEADING56-25"></a>
<a name="UID-Conditions-1894"></a>
<h2 class="subsection-title">Recovery Protocols</h2>
<p class="T1.Text1"><a name="MARKER-2-945"></a>For every condition class there should be a <strong class="Bold"><dfn>recovery protocol</dfn></strong> that defines the meaning of <a name="MARKER-2-946"></a>handling by returning, the meaning of the <a name="MARKER-2-947"></a>values returned, and which <a name="MARKER-2-948"></a>restart handlers are supposed to be established by the signaling unit. The recovery protocol tells the handler what to expect from the signaler. For many condition classes, this is the empty protocol: handling by returning isn't allowed, and no particular restart handlers are provided. In this case only handling by exiting is possible. (Exiting might be accomplished by signaling a restart whose handler was established in the outside or middle stack and does a nonlocal exit back to where it was established, or by an ordinary nonlocal exit.)  The recovery protocol for a subclass should be compatible with the recovery protocol of a superclass. That is, a handler that applies a class's recovery protocol should operate correctly when the condition is an instance of some subclass of that class.</p>
<p class="T1.Text1">An example recovery protocol for a hypothetical <code>&lt;unbound-slot&gt;</code> condition could include the following:</p>
<ul>
  <li>Returning is allowed. Returning a value uses that value as if it had been the contents of the slot.</li>
  <li>A restart handler for <code>&lt;new-value&gt;</code> is available. <code>&lt;new-value&gt;</code> has initialization arguments <code>value:</code>, the value to use, and <code>permanent:</code>, which indicates whether to store the value into the slot or leave the slot unbound.</li>
</ul>
<p class="T1.Text1">No formal mechanism is provided for describing recovery protocols; they are left to the documentation of a condition class. Introspective functions are provided for discovering which recovery facilities are actually available, but this is different from (and sometimes is a superset of) the recovery facilities guaranteed by a recovery protocol always to be available.</p>
<p class="T1.Text1">The <a name="MARKER-2-949"></a>debugger is the condition handler of last resort. It receives control if no program-provided handler handles a serious condition. (This is true even if the debugger provided cannot analyze or intervene in the execution of programs but can only abort or restart them. The debugger might be merely a "core dumper," a "bomb box," or something similar.)  An interactive debugger ought to offer the user the ability to signal any restart for which a restart handler is applicable and to return if the condition's recovery protocol allows it. This could, for example, be done with a menu titled "Recovery."<a name="MARKER-2-950"></a></p>

</div>

<div class="wm-div-footers">

<hr class="footer" />
<address class="footer">The Dylan Reference Manual - 7 Apr 1998</address>
<p class="footer"><a class="previous" title="Go to previous page" href="drm_55.html"><img alt="Previous" src="prev.gif" /></a> <a class="next" title="Go to next page" href="drm_57.html"><img alt="Next" src="next.gif" /></a> <a class="up" title="Go to start of chapter" href="drm_52.html"><img alt="Up" src="up.gif" /></a> <a class="start" title="Go to start of book" href="drm_1.html"><img alt="Top" src="top.gif" /></a> <a class="contents" title="Go to table of contents" href="drm_3.html"><img alt="Contents" src="content.gif" /></a> <a class="index" title="Go to index" href="drm_127.html"><img alt="index" src="index.gif" /></a></p>
<p class="footer">Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</p>
<p class="footer">Originally generated with <a href="http://www.harlequin.com/webmaker" class="footer">Harlequin WebMaker&#174;</a>, subsequently revised.</p>

</div>
</body>
</html>
