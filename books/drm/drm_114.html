<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  
  <!-- Relative Navigation -->
  
  <link rel="up" href="drm_110.html" />
  <link rel="prev" href="drm_113.html" />
  <link rel="next" href="drm_115.html" />
  
  <!-- Absolute Navigation -->
  
  <link rel="top" href="drm_1.html" />
  <link rel="start first" href="index.html" />
  <link rel="contents" href="drm_2.html" />
  <link rel="copyright" href="drm_3.html" />
  <link rel="glossary" href="drm_126.html" />
  <link rel="index" href="drm_127.html" />
  <link rel="last author" href="drm_128.html" />
  
  <!-- Chapters -->
  
  <link rel="chapter" title="About This Book" href="drm_4.html" />
  <link rel="chapter" title="1 Introduction" href="drm_5.html" />
  <link rel="chapter" title="2 Syntax" href="drm_9.html" />
  <link rel="chapter" title="3 Program Structure" href="drm_25.html" />
  <link rel="chapter" title="4 Program Control" href="drm_28.html" />
  <link rel="chapter" title="5 Types and Classes" href="drm_38.html" />
  <link rel="chapter" title="6 Functions" href="drm_47.html" />
  <link rel="chapter" title="7 Conditions" href="drm_52.html" />
  <link rel="chapter" title="8 Collections" href="drm_59.html" />
  <link rel="chapter" title="9 Sealing" href="drm_70.html" />
  <link rel="chapter" title="10 Macros" href="drm_76.html" />
  <link rel="chapter" title="11 The Built-In Classes" href="drm_87.html" />
  <link rel="chapter" title="12 The Built-In Functions" href="drm_96.html" />
  <link rel="chapter" title="13 Other Built-In Objects" href="drm_108.html" />
  <link rel="chapter" title="14 The Built-In Macros and Special Definitions" href="drm_110.html" />
  
  <!-- Appendices -->
  
  <link rel="appendix" title="A BNF" href="drm_116.html" />
  <link rel="appendix" title="B Exported Names" href="drm_119.html" />
  
  <!-- Stylesheet -->
  
  <link title="main style sheet" rel="stylesheet" href="drm.css" type="text/css" />

  <title>The Dylan Reference Manual: Statements</title>
</head>
<body>

<div class="wm-div-body">
<a name="HEADING114"></a>

<div class="wm-div-headers">
<p id="navigation"><a href="drm_113.html"><img alt="prev" src="prev.gif" title="Go to previous page" /></a> <a href="drm_115.html"><img alt="next" src="next.gif" title="Go to next page" /></a> <a href="drm_110.html"><img alt="up" src="up.gif" /></a> <a href="drm_1.html"><img alt="top" src="top.gif" /></a> <a href="drm_2.html"><img alt="Contents" src="content.gif" /></a> <a href="drm_127.html"><img alt="index" src="index.gif" /></a></p>

<div id="section-header">
  <p id="section-prefix">Chapter 14</p>
  <p id="section-name">The Built-In Macros and Special Definitions</p>
</div>

<div class="wm-div-toc">
  <ul class="page-toc">
    <li><a href="drm_114.html#HEADING114-162">Conditionals</a>
      <ul>
	<li><a href="drm_114.html#HEADING114-164"><code>if</code> <span class="attributes-summary">[Statement]</span></a></li>
	<li><a href="drm_114.html#HEADING114-181"><code>unless</code> <span class="attributes-summary">[Statement]</span></a></li>
	<li><a href="drm_114.html#HEADING114-190"><code>case</code> <span class="attributes-summary">[Statement]</span></a></li>
	<li><a href="drm_114.html#HEADING114-201"><code>select</code> <span class="attributes-summary">[Statement]</span></a></li>
      </ul>
    </li>
    <li><a href="drm_114.html#HEADING114-220">Iteration Constructs</a>
      <ul>
	<li><a href="drm_114.html#HEADING114-221"><code>while</code> <span class="attributes-summary">[Statement]</span></a></li>
	<li><a href="drm_114.html#HEADING114-229"><code>until</code> <span class="attributes-summary">[Statement]</span></a></li>
	<li><a href="drm_114.html#HEADING114-237"><code>for</code> <span class="attributes-summary">[Statement]</span></a></li>
      </ul>
    </li>
    <li><a href="drm_114.html#HEADING114-280">Other Statement Macros</a>
      <ul>
	<li><a href="drm_114.html#HEADING114-281"><code>begin</code> <span class="attributes-summary">[Statement]</span></a></li>
	<li><a href="drm_114.html#HEADING114-287"><code>block</code> <span class="attributes-summary">[Statement]</span></a></li>
	<li><a href="drm_114.html#HEADING114-310">Dynamic Extent of Block Features</a></li>
	<li><a href="drm_114.html#HEADING114-315">Intervening Cleanup Clauses</a></li>
	<li><a href="drm_114.html#HEADING114-320">Restrictions on the use of exit procedures</a></li>
	<li><a href="drm_114.html#HEADING114-324"><code>method</code> <span class="attributes-summary">[Statement]</span></a></li>
      </ul>
    </li>
  </ul>
</div>

<hr />

</div>

<a name="HEADING114-0"></a>
<a name="UID-Built-In_Macros-2670"></a>
<h1 class="H1.Heading1">Statements</h1>
<p class="T1.Text1"><a name="MARKER-2-2041"></a>Statements are used to implement a variety of program constructs.</p>
<p class="T1.Text1">Many statements include an optional implicit body, which may contain one or more constituents separated by semicolons. When an implicit body is executed, the expressions in the implicit body are executed in order (left to right). The values of the implicit body are the values of the last expression. If the optional implicit body is not present or contains no expressions, the return value is <code>#f</code>.</p>
<table class="numbered"><caption><strong>Table 14-3</strong> Statements</caption>
<tr><th class="primary"><p class="TbH.TblHd"> Macro</p>
</th><th><p class="TbH.TblHd"> Description</p>
</th><th><p class="TbH.TblHd"> Page</p>
</th></tr><tr><td><p class="TbT.TblText"> <code>if</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2044" class="TbT.TblText">Executes an implicit body if the value of a test is true or an alternate if the test is false.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2044" class="TbT.TblText">395</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>unless</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2046" class="TbT.TblText">Executes an implicit body unless the value of a test is true.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2046" class="TbT.TblText">396</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>case</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2048" class="TbT.TblText">Executes a number of tests until one is true, and then executes an implicit body associated with the true test.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2048" class="TbT.TblText">397</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>select</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2050" class="TbT.TblText">Compares a target object to a series of potential matches, and executes an implicit body associated with the first match found.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2050" class="TbT.TblText">398</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>while</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2054" class="TbT.TblText">Repeatedly executes a body until a test expression is false.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2054" class="TbT.TblText">399</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>until</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2056" class="TbT.TblText">Repeatedly executes a body until a test expression is true.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2056" class="TbT.TblText">400</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>for</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2058" class="TbT.TblText">Performs general iteration over a body, updating bindings and performing end tests on each iteration.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2058" class="TbT.TblText">400</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>begin</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2061" class="TbT.TblText">Executes expressions in a body, in order.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2061" class="TbT.TblText">404</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>block</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2063" class="TbT.TblText">Executes a body with several options for nonstandard flow of control.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2063" class="TbT.TblText">404</a></p>
</td></tr><tr><td><p class="TbT.TblText"> <code>method</code></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2066" class="TbT.TblText">Creates and returns a method.</a></p>
</td><td><p class="TbT.TblText"> <a href="#MARKER-9-2066" class="TbT.TblText">408</a></p>
</td></tr></table><a name="HEADING114-162"></a>
<a name="UID-Built-In_Macros-10641"></a>
<h2 class="H2.Heading2">Conditionals</h2>
<p class="T1.Text1"><a name="MARKER-2-2042"></a>The following statements are used to perform conditional execution.</p>
<a name="HEADING114-164"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2043"></a>if</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><code><a name="MARKER-9-2044"></a></code>Executes an implicit body if the value of a test is true or an alternate if the test is false.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche">
    <p class="Cliche">
      <code>if (</code> <var>test</var> <code>)</code> <strong class="re">[</strong> <var>consequent</var> <strong class="re">]</strong><br />
      <strong class="re">{</strong> <code>elseif</code> <code>(</code> <var>elseif-test</var> <code>)</code> <strong class="re">[</strong> <var>elseif-consequent</var> <strong class="re">] }*</strong><br />
      <strong class="re">[</strong> <code>else</code> <strong class="re">[</strong> <var>alternate</var> <strong class="re">] ]</strong><br />
      <code>end</code> <strong class="re">[</strong> <code>if</code> <strong class="re">]</strong>
    </p>
  </dd>
  <dt class="Cliche">Arguments:</dt>
  <dd class="Cliche">
    <dl>
      <dt><var>test</var></dt>
      <dd><p class="Cliche"><span class="BNF">expression<em class="BNF"><sub>bnf</sub></em></span></p></dd>
      <dt class="RP.RoutineParam"><var>consequent</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <span class="BNF">body<em class="BNF"><sub>bnf</sub></em></span></p></dd>
      <dt class="RP.RoutineParam"><var>elseif-test</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <span class="BFN">expression<em class="BNF"><sub>bnf</sub></em></span></p></dd>
      <dt class="RP.RoutineParam"><var>elseif-consequent</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <span class="BNF">body<em class="BNF"><sub>bnf</sub></em></span></p></dd>
      <dt class="RP.RoutineParam"><var>alternate</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <span class="BNF">body<em class="BNF"><sub>bnf</sub></em></span></p></dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> Zero or more instances of <code>&lt;object&gt;</code>.</p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>if</code> executes one or more expressions, executing and returning the values of a body following the first test that returns true.</p>
    <p class="T1.Text1"><var>test</var> is the first expression to be executed. If its value is true, <code>if</code> executes and returns the values of the <var>consequent</var>. If the value of <var>test</var> is false, <code>if</code> proceeds with the optional elseif-tests and alternate.</p>
    <p class="T1.Text1">First the elseif clauses are tried in order. The first <var>elseif-test</var> is executed. If its value is true, the corresponding <var>elseif-consequent</var> is executed and its values are returned as the value of the <code>if</code> statement. If its value is false, the next <var>elseif-test</var> is tried. This continues until a true <var>elseif-test</var> is found, or until there are no more elseif clauses.</p>
    <p class="T1.Text1">If the <var>test</var> and all the <var>elseif-tests</var> are false, the <var>alternate</var> is executed and its values are returned as the value of the <code>if</code> statement. If there is no alternate, the <code>if</code> statement returns <code>#f</code>.</p>
    <pre class="Cv.Code">
if ( x &lt; 0 )
  - x;
end if;

if ( heads?(flip(coin)) )
  start(black);
else
  start(white);
end if

if (player1.money &lt;= 0)
  end-game(player1)
elseif (player2.money &lt;= 0)
  end-game(player2)
else
  move(player1);
  move(player2);
end if

if ( camel.humps = 1 )
  &quot;dromedary&quot;
elseif ( camel.humps = 2 )
  &quot;bactrian&quot;
else
  &quot;not a camel&quot;
end if; </pre>
  </dd>
</dl>
<a name="HEADING114-181"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2045"></a>unless</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2046"></a>Executes an implicit body unless the value of a test is true.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>unless (</code> <var>test</var> <code>)</code><br />
      <strong class="re">[</strong> <var>body</var> <strong class="re">]</strong><br />
      <code>end</code> <strong class="re">[</strong> <code>unless</code> <strong class="re">]</strong></p></dd>
  <dt class="Cliche2">Arguments:</dt>
  <dd class="Cliche2">
    <dl>
      <dt><var>test</var></dt>
      <dd><p class="Cliche2"><span class="BNF">expression<em class="BNF"><sub>bnf</sub></em></span></p> </dd>
      <dt class="RP.RoutineParam"><var>body</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <span class="BNF">body<em class="BNF"><sub>bnf</sub></em></span></p></dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> Zero or more instances of <code>&lt;object&gt;</code>.</p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>unless</code> executes <var>test</var>. If the value of <var>test</var> is false, then the <var>body</var> is executed and its values are returned by <code>unless</code>. If the value of <var>test</var> is true, the <var>body</var> is not executed and <code>unless</code> returns <code>#f</code>.</p>
    <p class="T1.Text1">If there are no expressions in the <var>body</var>, then <code>#f</code> is returned.</p>
    <pre class="Cv.Code">
unless(detect-gas? (nose))
    light(match)
end unless </pre>
  </dd>
</dl>
<a name="HEADING114-190"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2047"></a>case              </code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2048"></a>Executes a number of tests until one is true, and then executes an implicit body associated with the true test.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche">
    <p class="Cliche">
      <code>case</code><br />
      <strong class="re">{</strong> <var>test</var> <code>=&gt;</code> <var>consequent</var> <strong class="re">}*</strong><br />
      <strong class="re">[</strong> <code>otherwise</code> <strong class="re">[</strong> <code>=&gt;</code> <strong class="re">]</strong> <var>alternate</var> <strong class="re">]</strong><br />
      <code>end</code> <strong class="re">[</strong> <code>case</code> <strong class="re">]</strong>
    </p>
  </dd>
  <dt class="Cliche2">Arguments:</dt>
  <dd class="Cliche2">
    <dl>
      <dt><var>test</var></dt>
      <dd><p class="Cliche2"><span class="BNF">expression<em class="BNF"><sub>bnf</sub></em></span></p></dd>
      <dt class="RP.RoutineParam"><var>consequent</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"><strong class="re">[</strong> constituents<em class="BNF"><sub>bnf</sub></em> <strong class="re">]</strong> <code>;</code>
	</p>
      </dd>
      <dt class="RP.RoutineParam"><var>alternate</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"><strong class="re">[</strong> constituents<em class="BNF"><sub>bnf</sub></em> <strong class="re">]</strong> <code>;</code>
	</p>
      </dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> Zero or more instances of <code>&lt;object&gt;</code>.</p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>case</code> executes the <var>test</var> in order, until it reaches a test that returns true. When it reaches a test that returns true, it executes the corresponding <var>consequent</var> and returns its values. Subsequent tests are not executed. If the corresponding <var>consequent</var> is empty, the first value of the successful test is returned.</p>
    <p class="T1.Text1">As a special case, the name <code>otherwise</code> may appear as a <var>test</var>. This <var>test</var> always succeeds if there is no preceding successful <var>test</var>.</p>
    <p class="T1.Text1">If no <var>test</var> is true, then <code>case</code> returns <code>#f</code>.</p>
    <pre class="Cv.Code">
case
   player1.money &lt;= 0
     =&gt; end-game(player1);
   player2.money &lt;= 0
     =&gt; end-game(player2);
   otherwise
     =&gt; move(player1);
        move(player2);
end case; </pre>
  </dd>
</dl>
<a name="HEADING114-201"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2049"></a>select</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2050"></a>Compares a target object to a series of potential matches, and executes an implicit body associated with the first match found.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche">
    <p class="Cliche">
      <code>
	select ( <var>target</var> [ by <var>test</var>  ] )<br />
	{ <var>matches</var>  =&gt; <var>consequent</var> }*<br />
	[ otherwise [ =&gt; ] <var>alternate</var> ]<br />
	end [ select ]
      </code>
    </p>
  </dd>
  <dt class="Cliche2">Arguments:</dt>
  <dd class="Cliche2">
    <dl>
      <dt><var>target</var></dt>
      <dd><p class="Cliche2"><code>expression<em class="BNF Parameter Cliche2"><sub>bnf</sub></em></code></p></dd>
      <dt class="RP.RoutineParam"><var>test</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <code>expression<em class="BNF"><sub>bnf</sub></em></code></p></dd>
      <dt class="RP.RoutineParam"><var>matches</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <code>{ expression<em class="BNF"><sub>bnf</sub></em> } ,<strong class="re">+ |</strong> ( { expression<sub>bnf</sub> } ,+ )</code></p></dd>
      <dt class="RP.RoutineParam"><var>consequent</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <code>[ constituents<em class="MetaSyntax"><sub>bnf</sub></em> ] ;</code></p></dd>
      <dt class="RP.RoutineParam"><var>alternate</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> <code>[ constituents<em class="MetaSyntax"><sub>bnf</sub></em> ] ;</code></p></dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> Zero or more instances of <code>&lt;object&gt;</code>.</p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>select</code> generates a target object and then compares it to a series of potential matches, in order. If it finds a match, it executes the corresponding <var>consequent</var> and returns the values of the <var>consequent</var>. If no match is found, an error is signaled.</p>
    <p class="T1.Text1">The <var>target</var> is executed to produce the match object.</p>
    <p class="T1.Text1">The <var>test</var>, if supplied, is a function used to compare the target object to the potential matches. The default <var>test</var> is <code>==</code>.</p>
    <p class="T1.Text1">One at a time, each <var>match</var> is executed and its value compared to <var>target</var>, in order. If a match is found, the corresponding <var>consequent</var> is executed and its values are returned. If the corresponding <var>consequent</var> is empty, <code>#f</code> is returned.</p>
    <p class="T1.Text1">Once a match is found, subsequent <var>matches</var>  and the corresponding bodies are not executed.</p>
    <p class="T1.Text1">As a special case, the name <code>otherwise</code> may appear instead of a <var>matches</var>. This will be considered a match if no other match is found.</p>
    <p class="T1.Text1">If there is no matching clause, an error is signaled. Because an <code>otherwise</code> clause matches when no other clause matches, a <code>select</code> form that includes an <code>otherwise</code> clause will never signal an error for failure to match.</p>
    <p class="T1.Text1">Since testing stops when the first match is found, it is irrelevant whether the test function would also have returned true if called on later matches of the same clause or on matches of later clauses.</p>
    <pre class="Cv.Code">
select ( career-choice(student) )
   art:, music:, drama:
     =&gt; &quot;Don't quit your day job&quot;;
   literature:, history:, linguistics:
     =&gt; &quot;That really is fascinating&quot;;
   science:, math:, engineering:
     =&gt; &quot;Say, can you fix my VCR?&quot;;
   otherwise =&gt; &quot;I wish you luck&quot;;
end select;

select ( my-object by instance? )
  &lt;window&gt;, &lt;view&gt;, &lt;rectangle&gt; =&gt; &quot;a graphical object&quot;;
  &lt;number&gt;, &lt;string&gt;, &lt;list&gt; =&gt; &quot;a computational object&quot;;
  otherwise =&gt; &quot;I don't know&quot;;
end select<a name="MARKER-2-2051"></a> </pre>
  </dd>
</dl>
<a name="HEADING114-220"></a>
<a name="UID-Built-In_Macros-1898"></a>
<h2 class="H2.Heading2"><a name="MARKER-2-2052"></a>Iteration Constructs</h2>
<a name="HEADING114-221"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2053"></a>while</code>  <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2054"></a>Repeatedly executes a body until a test expression is false.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>while ( <i class="parameter Code Cliche">test  )<br /></i></code>    <code>[ <var>body</var></code>  <code>]<br />end</code> <code>[ while ]<br />&rArr; <strong class="MetaSyntax Cliche"> #f</strong></code></p></dd>
  <dt class="Cliche2">Arguments:</dt>
  <dd class="Cliche2">
    <dl>
      <dt><var>test</var></dt>
      <dd><p class="Cliche2">expression<em class="BNF Cliche2"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>body</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>#f</code></p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>while</code> loops over <var>body</var> until <var>test</var> returns false.</p>
    <p class="T1.Text1">Each pass through the loop begins by executing <var>test</var>. If <var>test</var> returns a true value, the expressions in the <var>body</var> are executed and the looping continues. If <var>test</var> returns false, the loop terminates and <code>while</code> returns <code>#f</code>.</p></dd>
</dl>
<a name="HEADING114-229"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2055"></a>until ( <var>test</var> )</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2056"></a>Repeatedly executes a body until a test expression is true.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche">
    <p class="Cliche">
      <code>until ( <var>test</var> )</code><br />
      [ <var>body</var> ]<br />
      <code>end</code> [ <code>until</code> ]<br />
      &rArr; <code>#f</code>
    </p>
  </dd>
  <dt class="Cliche">Arguments:</dt>
  <dd class="Cliche">
    <dl>
      <dt><var>test</var></dt>
      <dd><p class="Cliche">expression<em class="BNF Cliche"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>body</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>#f</code></p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>until</code> loops over <var>body</var> until <var>test</var> returns true.</p>
    <p class="T1.Text1">Each pass through the loop begins by executing <var>test</var>. If <var>test</var> returns false, the expressions in the <var>body</var> are executed and the looping continues. If <var>test</var> returns true, the loop terminates and <code>until</code> returns <code>#f</code>.</p></dd>
</dl>
<a name="HEADING114-237"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2057"></a>for</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2058"></a>Performs general iteration over a body, updating bindings and performing end tests on each iteration.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche">
    <p class="Cliche">
      <code>for (</code> { <var>for-clause</var> } <code>,</code>* |<br />
      { { <var>for-clause</var> <code>,</code>}* <var>end-clause</var> }<code>)</code><br />
      [ <var>loop-body</var> ]<br />
      [ <code>finally</code> [ <var>result-body</var> ] ]<br />
      <code>end</code> [ <code>for</code> ]
    </p>
  </dd>
  <dt class="Cliche2">Arguments:</dt>
  <dd class="Cliche2">
    <dl>
      <dt><var>for-clause</var></dt>
      <dd><p class="Cliche2">explicit-step-clause <strong class="re">|</strong></p></dd>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">collection-clause <strong class="re">|</strong></p></dd>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam"> numeric-clause </p></dd>
      <dt class="RP.RoutineParam"><var>end-test</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>loop-body</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>result-body</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP3.RoutineParam"><var>explicit-step-clause</var></dt>
      <dd class="RP3.RoutineParam"><p class="RP3.RoutineParam">variable<em class="BNF"><sub>bnf</sub></em><code> = <var>init-value</var>  then <var>next-value</var></code></p></dd>
      <dt class="RP3.RoutineParam"><var>collection-clause</var></dt>
      <dd class="RP3.RoutineParam"><p class="RP3.RoutineParam">variable<em class="BNF"><sub>bnf</sub> in <var>collection</var></em></p></dd>
      <dt class="RP.RoutineParam"><i class="parameter RP.RoutineParam">numeric-clause<code></code></i></dt>
      <dd class="RP.RoutineParam">
	<p class="RP.RoutineParam">
	  variable<em class="BNF"><sub>bnf</sub></em> <code>from</code> <var>start</var><br />
          [ { <code>to</code> | <code>above</code> | <code>below</code> } <var>bound</var> ]<br />
          [ <code>by</code> <var>increment</var> ]
	</p>
      </dd>
      <dt class="RP.RoutineParam"><var>end-clause</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">{ <code>until:</code> | <code>while:</code> } <var>end-test</var></p></dd>
      <dt class="RP.RoutineParam"><var>init-value</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>next-value</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>collection</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>start</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>bound</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>increment</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> Zero or more instances of <code>&lt;object&gt;</code>.</p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <code>for</code> iterates over <var>loop-body</var>, creating and updating iteration bindings on each iteration according to the <var>for-clauses</var>. Iteration ends when one of the <var>for-clauses</var> is exhausted, or when the optional <var>end-test</var> is satisfied.</p>
    <p class="T1.Text1">Each <var>for-clause</var> controls one iteration binding. The optional <var>end-test</var> does not control any iteration bindings.</p>
    <p class="T1.Text1">There are three kinds of for-clauses: <var>explicit-step-clauses</var>, <var>collection-clauses</var>, and <var>numeric-clauses</var>:  An <var>explicit-step-clause</var> creates bindings for the results of executing an expression. A <var>collection-clause</var> creates bindings for successive elements of a collection. A <var>numeric-clause</var> creates bindings for a series of numbers.</p>
    <p class="T1.Text1">Execution of a <code>for</code> statement proceeds through the following steps:</p>
    <ol>
      <li>Execute the expressions that are executed just once, in left to right order as they appear in the <code>for</code> statement. These expressions include the types of all the bindings, and the expressions <var>init-value</var>, <var>collection</var>, <var>start</var>, <var>bound</var>, and <var>increment</var>. If the value of <var>collection</var> is not a collection, an error is signaled. The default value for <var>increment</var> is <code>1</code>.</li>
      <li>Create the iteration bindings of explicit step and numeric clauses.
	<ul class="B2.Bullet2">
	  <li class="B2.Bullet2"> For each explicit step clause, create the binding for the value of <var>init-value</var>. If the binding is typed and the value is not of the specified type, signal an error.</li>
	  <li class="B2.Bullet2">For each numeric clause, create the binding for the value of <var>start</var>. If the binding is typed and the value is not of the specified type, signal an error.</li>
	</ul>
      </li>
      <li>Check numeric and collection clauses for exhaustion. If a clause is exhausted, go to step 9.
	<ul>
	  <li class="B2.Bullet2">A collection clause is exhausted if its collection has no next element.</li>
	  <li class="B2.Bullet2">A numeric clause is exhausted if a <var>bound </var>is supplied and the value of the clause is no longer in bounds. If <code>above</code> is specified, the clause will be in bounds as long as the value is greater than the <var>bounds</var>. If <code>below</code> is specified, the clause will be in bounds as long as the value is less than the <var>bounds</var>. If <code>to</code> is specified with a positive or zero <var>increment</var>, the clause will be in bounds as long as it is less than or equal to the  <var>bounds</var>. If <code>to</code> is specified with a negative <var>increment</var>, the clause will be in bounds as long as it is greater than or equal to the <var>bounds</var>.</li>
	</ul>
      </li>
      <li>For each collection clause create the iteration binding for the next element of the collection for that clause. Fresh bindings are created each time through the loop (i.e., the binding is not assigned the new value). If the binding is typed and the value is not of the specified type, signal an error. </li>
      <li>If <var>end-test</var> is supplied, execute it.  If the value of <var>end-test </var>is false and the symbol is <code>while:</code>, go to step 9. If the value of <var>end-test </var>is true and the symbol is <code>until:</code>, go to step 9.</li>
      <li>Execute the expressions in the <var>body</var> in order. The expressions in the <var>body</var> are used to produce side-effects.</li>
      <li>Obtain the next values for explicit step and numeric clauses. Values are obtained in left to right order, in the environment produced by step 6.
	<ul>
	  <li class="B2.Bullet2">For each explicit step clause, execute <var>next-value</var>.</li>
	  <li class="B2.Bullet2"> For each numeric clause, add the <var>increment</var> to the current value of the binding, using <code>+</code>.</li>
	</ul>
      </li>
      <li>Create the iteration bindings of explicit step and numeric clauses for the values obtained in step 7. For each clause, if a binding type is supplied and the next value for that clause is not of the specified type, signal an error. Fresh bindings are created each time through the loop (i.e., the binding is not assigned the new value). After the bindings have been created, go to step 3.</li>
      <li>Execute the expressions in the <var>result-body</var>  in order. Bindings created in step 2 and 8  are visible during the execution of <var>result-body</var>, but bindings created in step 4 ( the iteration bindings of collection clauses) are not visible during the execution of <var>result-body</var>. The values of the last expression in the <var>result-body</var>  are returned as the values of the <code>for</code> statement. If there are no expressions in the <var>result-body</var>, <code>for</code> returns <code>#f</code>.</li>
    </ol>
    <pre class="Cv.Code">
for ( thing = first-thing then next(thing),
      until: done?(thing) )
  do-some(thing)
end;

for (j :: &lt;integer&gt; from 0 to height)
  for (i :: &lt;integer&gt; from 0 to width)
   erase(i,j);
   plot (i,j);
  end for;
end for;

for (city in olympic-cities,
     year from start-year by 4)
  schedule-olympic-game(city, year)
  finally notify(press);
           sell(tickets);
end;

for (i from 0 below 100,
     zombies from 0 below 100,
     normals from 100 above 0 by -1)
   population[i] := zombies + normals
end;<a name="MARKER-2-2059"></a> </pre>
  </dd>
</dl>
<a name="HEADING114-280"></a>
<a name="UID-Built-In_Macros-13876"></a>
<h2 class="H2.Heading2">Other Statement Macros</h2>
<a name="HEADING114-281"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2060"></a>begin</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2061"></a>Executes expressions in a body, in order.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche">
    <p class="Cliche">
      <code>begin</code> <strong class="re">[</strong> <var>body</var> <strong class="re">]</strong> <code>end</code>
    </p>
  </dd>
  <dt class="Cliche">Arguments:</dt>
  <dd class="Cliche">
    <dl>
      <dt><var>body</var></dt>
      <dd><p class="Cliche">body<em class="BNF Cliche"><sub>bnf</sub></em></p></dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> Zero or more instances of <code>&lt;object&gt;</code>.</p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> Begin executes the expressions in a body, in order. The values of the last expression are returned. If there are no expressions in the body, <code>#f</code> is returned.</p></dd>
</dl>
<a name="HEADING114-287"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2062"></a>block</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2063"></a>Executes a body with several options for nonstandard flow of control.</p>
<dl class="Cliche">
  <dt class="Cliche">Macro Call:</dt>
  <dd class="Cliche">
    <p class="Cliche">
      <code>block (</code> <strong class="re">[</strong> <var>exit-variable</var> <strong class="re">]</strong> <code>)</code><br />
      <strong class="re">[</strong> <var>block-body</var> <strong class="re">]</strong><br />
      <strong class="re">[</strong> <code>afterwards</code> <strong class="re">[</strong> <var>afterwards-clause</var> <strong class="re">]</strong> <strong class="re">]</strong><br />
      <strong class="re">[</strong> <code>cleanup</code> <strong class="re">[</strong> <var>cleanup-clause</var> <strong class="re">]</strong> <strong class="re">]</strong><br />
      <strong class="re">{</strong> <code>exception</code> <var>exception-clause</var> <strong class="re">}*</strong><br />
      <code>end</code> <strong class="re">[</strong> <code>block</code> <strong class="re">]</strong>
    </p>
  </dd>
  <dt class="Cliche2">Arguments:</dt>
  <dd class="Cliche2">
    <dl>
      <dt><var>exit-variable</var></dt>
      <dd><p class="Cliche2">variable-name<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>block-body</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP3.RoutineParam"><var>afterwards-clause</var></dt>
      <dd class="RP3.RoutineParam"><p class="RP3.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>cleanup-clause</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>exception-clause</var></dt>
      <dd class="RP.RoutineParam">
	<p class="RP.RoutineParam">
	  <code>(</code> <strong class="re">[</strong> <var>name</var> <code>::</code> <strong class="re">]</strong> <var>type</var> <strong class="re">{</strong> <code>,</code> <var>exception-options</var> <strong class="re">}*</strong> <code>)</code><br />
	  <strong class="re">[</strong> body<em class="BNF"><sub>bnf</sub></em> <strong class="re">]</strong>
	</p>
      </dd>
      <dt class="RP.RoutineParam"><var>name</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">variable-name<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>type</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">expression<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>exception-options</var></dt>
      <dd class="RP.RoutineParam">
	<p class="RP.RoutineParam">
	  <strong class="re">{</strong> <code>test:</code> expression<em class="BNF"><sub>bnf</sub></em> <strong class="re">} | {</strong> <code>init-arguments:</code> expression<em class="BNF"><sub>bnf</sub></em> <strong class="re">}</strong>
	</p>
      </dd>
    </dl>
  </dd>
  <dt class="Cliche">Values:</dt>
  <dd class="Cliche"><p class="Cliche"> Zero or more instances of <code>&lt;object&gt;</code>.</p></dd>
  <dt class="Cliche">Description:</dt>
  <dd class="Cliche"><p class="Cliche"> <a name="MARKER-2-2064"></a><code>block</code> executes the expressions in the <var>block-body</var> in order, and then executes the optional <var>afterwards-clause</var> and <var>cleanup-clause</var>. Unless there is a nonlocal exit, block returns the values of the <var>block-body</var>, or <code>#f</code> if there is no <var>block-body</var>.</p>
    <p class="T1.Text1">If <var>exit-variable</var> is provided, it is bound to an exit procedure (an object of type <code>&lt;function&gt;</code>) that is valid during the execution of the block body and the clauses. At any point in time before the last clause returns, the exit procedure can be called. Calling the exit procedure has the effect of immediately terminating the execution of the block, and returning as values the arguments to the exit procedure.</p>
    <p class="T1.Text1">The body of the <var>afterwards-clause</var>, if provided, is executed after the <var>block-body</var>. The values produced by the <var>afterwards-clause</var> are ignored. This is useful when you want to execute an expression for side-effect after the <var>block-body</var> has executed, but still want to return the values of the last expression in the <var>block-body</var>.</p>
    <p class="T1.Text1">The body of the <var>cleanup-clause</var>, if provided, is executed after the <var>block-body</var> and <var>afterwards-clause</var>. Its values are also ignored. The cleanup clause differs from the afterwards clause in that its body is guaranteed to be executed, even if the execution of the block is interrupted by a nonlocal exit. There is no such guarantee for the <var>afterwards-clause</var>.</p>
    <p class="T1.Text1">For example, the following code fragment ensures that files are closed even in the case of an error causing a nonlocal exit from the block body:</p>
    <pre class="Cv.Code">
block (return)
  open-files();
  if (something-wrong)
    return(&quot;didn't work&quot;);
  end if;
  compute-with-files()
cleanup
  close-files();
end block </pre>
    <p class="T1.Text1">The <var>exception-clauses</var>, if supplied, install exception handlers during the execution of the <var>block-body</var>, <var>afterwards-clause</var>, and <var>cleanup-clause</var>. If one of these handlers is invoked, it never declines but immediately takes a nonlocal exit to the beginning of the block, executes the expressions in its body and returns the values of the last expression or <code>#f</code> if the body is empty. Note that when the expressions in an exception body are executed, all handlers established by the <code>block</code> are no longer active. Note also that the cleanup clause of the block will be executed before the expressions of the handler body are executed.</p>
    <p class="T1.Text1">The <var>type</var> and <var>exception-options</var> are as for <code>let handler</code>. If present, <var>name</var> is bound to the condition during the execution of the handler's body.</p>
    <p class="T1.Text1">The exception clauses are checked in the order in which they appear. That is, the first handler will take precedence over the second, the second over the third, etc.</p>
    <p class="T1.Text1">The following is a trivial use of an exception clause.</p>
    <pre class="Cv.Code">
block ()
  open-files();
  compute-with-files()
exception (&lt;error&gt;) 
  &quot;didn't work&quot;;
cleanup
  close-files();
end block </pre>
    <a name="HEADING114-310"></a>
    <h4 class="H5.Heading5">Dynamic Extent of Block Features</h4>
    <p class="T1.Text1">A block installs features that are active for different portions of the execution of the block.</p>
    <ul class="B1.Bullet1">
      <li class="B1.Bullet1">During the execution of the block body and the afterwards clause the exit procedure, exception clauses, and cleanup clauses are active.</li>
      <li class="B1.Bullet1">During the execution of the cleanup clause, the exit procedure and exception clauses are active.</li>
      <li class="B1.Bullet1">During the execution of a handler installed by an exception clause, the exit procedure is active.</li>
    </ul>
    <a name="HEADING114-315"></a>
    <h4 class="H5.Heading5">Intervening Cleanup Clauses</h4>
    <p class="T1.Text1">When an exit procedure is called, it initiates a nonlocal exit out of its establishing block. Before the nonlocal exit can complete, however, the cleanup clauses of intervening blocks (blocks that have been entered, but not exited, since the establishing block was entered) must be executed, beginning with the most recently entered intervening block. Once the cleanup clauses of an intervening block have been executed, it is an error to invoke the exit procedure established by that block. The cleanup clauses of the establishing block are executed last. At that point, further invocation of the exit procedure becomes invalid, and the establishing block returns with the values that were passed to the exit procedure.</p>
    <p class="T1.Text1">Note that a block statement may also be exited due to the execution of a handler clause. Before the exception clause is executed, intervening cleanup clauses are executed as described above (including any clause for the establishing block.)  The exit procedure may be invoked during execution of exception clauses, in which case the argument values are immediately returned from the block (the cleanup clause already having been executed).</p>
    <p class="T1.Text1">During the process of executing the cleanup clauses of the intervening blocks, any valid exit procedure may be invoked and may interrupt the current nonlocal exit.</p>
    <p class="T1.Text1">All exception clauses are executed in the same dynamic environment. None of the handlers established in the block are visible during the execution of one of the handlers. This can be thought of as parallel installation of the handlers.</p>
    <a name="HEADING114-320"></a>
    <h4 class="H5.Heading5">Restrictions on the use of exit procedures</h4>
    <p class="T1.Text1">The exit procedure is a first-class object. Specifically, it can be passed as an argument to functions, stored in data structures, and so on. Its use is not restricted to the lexical body of the block in which it was established. However, invocation of the exit procedure is valid only during the execution of the establishing block. It is an error to invoke an exit procedure after its establishing block has returned, or after execution of the establishing block has been terminated by a nonlocal exit.</p>
    <p class="T1.Text1">In the following example, the <code>block</code> establishes an exit procedure in the binding <code>bar</code>. The <code>block</code> returns a method containing a call to <code>bar</code>, and the  method is stored in the binding <code>foo</code>. Calling <code>foo</code> is an error because it is no longer valid to invoke <code>bar</code> after its establishing <code>block</code> has returned.</p>
    <pre class="Cv.Code">
define constant foo =
  block (bar)
     method (n) bar(n) end;
  end block;
foo(5)
  {error or other undefined consequences} </pre>
  </dd>
</dl>
<a name="HEADING114-324"></a>
<h3 class="H4.Heading4"><code><a name="MARKER-2-2065"></a>method</code> <span class="attributes-summary">[Statement]</span></h3>
<hr class="H4.Heading4" />
<p class="SD.ShortDescription"><a name="MARKER-9-2066"></a>Creates and returns a method.</p>
<dl class="Cliche">
<dt class="Cliche">Macro Call:</dt>
<dd class="Cliche"><p class="Cliche"> <code>method <var>parameter-list</var> [ <var>body</var> ] <code>end</code> [ <code>method</code> ]</code></p></dd>
<dt class="Cliche2">Arguments:</dt>
<dd class="Cliche2">
    <dl>
      <dt><var>parameter-list</var></dt>
      <dd><p class="Cliche2">parameter-list<em class="BNF"><sub>bnf</sub></em></p></dd>
      <dt class="RP.RoutineParam"><var>body</var></dt>
      <dd class="RP.RoutineParam"><p class="RP.RoutineParam">body<em class="BNF"><sub>bnf</sub></em></p></dd>
    </dl>
</dd>
<dt class="Cliche">Values:</dt>
<dd class="Cliche"><p class="Cliche"> An instance of <code>&lt;method&gt;</code>.</p></dd>
<dt class="Cliche">Description:</dt>
<dd class="Cliche"><p class="Cliche"> <code>method</code> creates and returns a method specified by the <var>parameter-list</var> and <var>body</var>. For a complete description of methods, see <a href="drm_48.html#MARKER-9-762" class="Cliche">"Methods" on page 80</a>.<a name="MARKER-2-2067"></a></p></dd>
</dl>

</div>

<div class="wm-div-footers">

<hr class="footer" />
<address class="footer">The Dylan Reference Manual - 7 Apr 1998</address>
<p class="footer"><a href="drm_113.html"><img alt="prev" src="prev.gif" title="Go to previous page" /></a> <a href="drm_115.html"><img alt="next" src="next.gif" title="Go to next page" /></a> <a href="drm_110.html"><img alt="up" src="up.gif" /></a> <a href="drm_1.html"><img alt="top" src="top.gif" /></a> <a href="drm_2.html"><img alt="Contents" src="content.gif" /></a> <a href="drm_127.html"><img alt="index" src="index.gif" /></a></p>
<p class="footer">Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</p>
<p class="footer">Generated with <a href="http://www.harlequin.com/webmaker" class="footer">Harlequin WebMaker&#174;</a></p>

</div>
</body>
</html>
