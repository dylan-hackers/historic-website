<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="top" href="drm_1.html" />
<link rel="up" href="drm_76.html" />
<link rel="prev" href="drm_80.html" />
<link rel="next" href="drm_82.html" />
<link title="main style sheet" rel="stylesheet" href="drm.css" type="text/css" />
<title>Patterns</title>
</head>
<body>

<div class="wm-div-body">
<a name="HEADING81"></a>

<div class="wm-div-headers">
<p class="header"><a href="drm_82.html" class="header"><img alt="next" src="next.gif" class="header" /></a> <a href="drm_80.html" class="header"><img alt="prev" src="prev.gif" class="header" /></a> <a href="drm_76.html" class="header"><img alt="up" src="up.gif" class="header" /></a> <a href="drm_1.html" class="header"><img alt="top" src="top.gif" class="header" /></a> <a href="drm_2.html" class="header"><img alt="content" src="content.gif" class="header" /></a> <a href="drm_127.html" class="header"><img alt="index" src="index.gif" class="header" /></a></p>
<p class="header">10 Macros</p>

</div>
<a name="HEADING81-0"></a>
<a name="UID-Macros-1648"></a>
<h1 class="H1.Heading1"> Patterns</h1>
<p class="T1.Text1"><a name="MARKER-2-1237"></a>Approximately speaking, a pattern looks like the construct that it matches, but contains pattern variables that bind to portions of the construct. Hence, a left-hand side in the <i class="Parameter T1.Text1">main-rule-set</i> looks like a macro call. However, the grammar of patterns is not the same as the grammar of programs, but contains just what is required to match the portions of the Dylan grammar that are extensible by macros. Patterns have a simple nested grammar, with semicolons, commas, and brackets used to indicate levels of nesting. See the definition of <i class="Parameter T1.Text1">pattern</i> in <a href="drm_116.html#MARKER-9-2090" class="T1.Text1">Appendix A, "BNF."</a></p>
<p class="T1.Text1">A pattern matches a fragment (a sequence of elementary fragments) by executing the following algorithm from left to right. It is easy to create patterns that are ambiguous when considered as grammars. This ambiguity is resolved by the left to right processing order and the specified try-shortest-first order for matching wildcards. Pattern matching succeeds only if all sub-patterns match. If pattern matching fails, the current rule fails and control passes to the next rule in the current rule set. If all patterns in a rule set fail to match, the macro call is invalid.</p>
<p class="T1.Text1">Multiple occurrences of the same pattern variable name in a single rule's left-hand side are not valid.</p>
<p class="T1.Text1">A <i class="Parameter T1.Text1">pattern</i>  matches a fragment as follows:</p>
<ul class="B1.Bullet1">
<li class="B1.Bullet1">If the pattern consists of just one pattern-list, go to the next step. Otherwise, divide the pattern into subpatterns and the fragment into subfragments at semicolons, and match subpatterns to subfragments individually in order. The subpatterns and subfragments do not include the semicolons that separate them. Suppose the pattern consists of N + 1 pattern-lists separated by N semicolons. Locate the first N semicolons in the fragment (without looking inside of elementary fragments) and divide up the fragment into subfragments accordingly. The match fails if the fragment contains fewer than N - 1 semicolons. As a special case, if the fragment contains N - 1 semicolons, the match still succeeds and the last subfragment is empty. If the fragment contains more than N semicolons, the extra semicolons will be in the last subfragment.
<p class="T1.Text1">A <a name="MARKER-2-1238"></a><i class="T1.Text1">pattern-list</i>  matches a fragment as follows:</p>
</li>
<li class="B1.Bullet1">If the pattern-list consists of just a pattern-sequence, go to the next step. If the pattern-list consists of just a property-list-pattern, go to that step. Otherwise divide the pattern-list into subpatterns and the fragment into subfragments at commas, and match subpatterns to subfragments individually in order. The subpatterns and subfragments do not include the commas that separate them. Suppose the pattern consists of N + 1 subpatterns separated by N commas. Locate the first N commas in the fragment (without looking inside of elementary fragments) and divide up the fragment into subfragments accordingly. The match fails if the fragment contains fewer than N - 1 commas. As a special case, if the fragment contains N - 1 commas, the match still succeeds and the last subfragment is empty. If the fragment contains more than N commas, the extra commas will be in the last subfragment. Note that the subdivision algorithms for commas and semicolons are identical.
<p class="T1.Text1">A <a name="MARKER-2-1239"></a><i class="Parameter T1.Text1">pattern-sequence</i>  matches a fragment as follows:</p>
</li>
<li class="B1.Bullet1">Consider each simple-pattern in the pattern-sequence in turn from left to right. Each simple-pattern matches an initial subsequence of the fragment and consumes that subsequence, or fails. The entire pattern match fails if any simple-pattern fails, if the fragment is empty and the simple-pattern requires one or more elementary fragments, or if the fragment is not entirely consumed after all simple-patterns have been matched. There is a special backup and retry rule for wildcards, described below.
<p class="T1.Text1">A <i class="T1.Text1"><a name="MARKER-2-1240"></a>simple-pattern  </i>matches a fragment as follows:</p>
</li>
<li class="B1.Bullet1">A <em class="B1.Bullet1">name</em> or <code class="cv B1.Bullet1">=&gt;</code> consumes one elementary fragment, which must be identical to the <i class="Parameter B1.Bullet1">simple-pattern</i>. A <em class="B1.Bullet1">name</em> matches a name that is spelled the same, independent of modules, lexical scoping issues, alphabetic case, and backslash quoting. As a special case, after the word <code class="cv B1.Bullet1">otherwise</code>, an <code class="cv B1.Bullet1">=&gt;</code> is optional in both the pattern and the fragment. Presence or absence of the arrow in either place makes no difference to matching. 
</li>
<li class="B1.Bullet1">A <a name="MARKER-2-1241"></a><i class="Parameter B1.Bullet1">bracketed-pattern<code class="Parameter B1.Bullet1"> </code></i>matches and consumes a <i class="Parameter B1.Bullet1">bracketed-fragment</i>. If the enclosed <i class="Parameter B1.Bullet1">pattern</i> is omitted, the enclosed <i class="Parameter B1.Bullet1">body-fragment</i> must be empty, otherwise the enclosed <i class="Parameter B1.Bullet1">pattern</i> must match the enclosed <i class="Parameter B1.Bullet1">body-fragment</i>  (which can be empty). The type of brackets ( <code class="cv B1.Bullet1">()</code>, <code class="cv B1.Bullet1">[]</code>, or <code class="cv B1.Bullet1">{}</code> ) in the <i class="Parameter B1.Bullet1">bracketed-fragment  </i>must be the same as the type of brackets in the <i class="Parameter B1.Bullet1">bracketed-pattern</i>.
<p class="T1.Text1">A <a name="MARKER-2-1242"></a><i class="Parameter T1.Text1">binding-pattern</i>  matches a fragment as follows:</p>
</li>
<li class="B1.Bullet1"><i class="Parameter B1.Bullet1">pattern-variable <code class="Parameter B1.Bullet1"> :: pattern-variable  </code></i>consumes as much of the fragment as can be parsed by the grammar for <i class="Parameter B1.Bullet1">variable. </i>It matches the first pattern-variable to the <i class="Parameter B1.Bullet1">variable-name</i> and the second to the <i class="Parameter B1.Bullet1">type</i>, a parsed expression fragment. If no specializer is present, it matches the second pattern-variable to a parsed expression fragment that is a named value reference to <code class="cv B1.Bullet1">&lt;object&gt;</code> in the Dylan module. This matching checks the constraints on the pattern variable, fails if the constraint is not satisfied, and binds the pattern variable to the fragment.
</li>
<li class="B1.Bullet1"><i class="Parameter B1.Bullet1">pattern-variable<code class="Parameter B1.Bullet1"> = pattern-variable  </code></i>consumes as much of the fragment as can be parsed by the grammar for <i class="Parameter B1.Bullet1">variable</i> <code class="cv B1.Bullet1">=</code> <i class="Parameter B1.Bullet1">expression. </i>It matches the first pattern-variable to the <i class="Parameter B1.Bullet1">variable,</i> a fragment, and the second to the <i class="Parameter B1.Bullet1">expression</i>, a parsed expression fragment.
</li>
<li class="B1.Bullet1"><i class="Parameter B1.Bullet1">pattern-variable<code class="Parameter B1.Bullet1"> :: pattern-variable = pattern-variable  </code></i>consumes as much of the fragment as can be parsed by the grammar for <i class="Parameter B1.Bullet1">variable</i> <code class="cv B1.Bullet1">=</code> <i class="Parameter B1.Bullet1">expression. </i>It matches the first two pattern-variables the same as the first kind of <i class="Parameter B1.Bullet1">binding-pattern</i> and it matches the third pattern-variable the same as the second kind of <i class="Parameter B1.Bullet1">binding-pattern.</i>
<p class="T1.Text1">A <i class="Parameter T1.Text1"><a name="MARKER-2-1243"></a>pattern-variable  </i>matches a fragment as follows:</p>
</li>
<li class="B1.Bullet1">When the constraint is a wildcard constraint (see <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints" on page 157</a>), the pattern variable<i class="B1.Bullet1"> </i>consumes some initial subsequence of the fragment, using a backup and retry algorithm. First, the wildcard consumes no elementary fragments, and matching continues with the next <i class="Parameter B1.Bullet1">simple-pattern</i> in the <i class="Parameter B1.Bullet1">pattern-sequence</i>. If any <i class="Parameter B1.Bullet1">simple-pattern</i> in the current <i class="Parameter B1.Bullet1">pattern-sequence</i> fails to match, back up to the wildcard, consume one more elementary fragment than before, and retry matching the rest of the <i class="Parameter B1.Bullet1">pattern-sequence</i>, starting one elementary fragment to the right of the previous start point. Once the entire <i class="Parameter B1.Bullet1">pattern-sequence</i> has successfully matched, the pattern variable binds to a fragment consisting of the sequence of elementary fragments that it consumed.
</li>
<li class="B1.Bullet1">It is an error for more than one of the <i class="Parameter B1.Bullet1">simple-patterns</i> directly contained in a <i class="Parameter B1.Bullet1">pattern-sequence</i> to be a wildcard.
</li>
<li class="B1.Bullet1">When the constraint is other than a wildcard constraint, the pattern variable consumes as much of the fragment as can be parsed by the grammar specified for the constraint in <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints" on page 157</a>. If the parsing fails, the pattern match fails. The pattern variable binds to the fragment specified in <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints."</a>  This can be a parsed fragment rather than the original sequence of elementary fragments.
</li>
<li class="B1.Bullet1">The ellipsis <i class="Parameter B1.Bullet1">pattern-variable</i>, <code class="cv B1.Bullet1">...</code>, can only be used in an auxiliary rule set. It represents a pattern variable with the same name as the current rule set and a wildcard constraint.
<p class="T1.Text1">A <a name="MARKER-2-1244"></a><i class="Parameter T1.Text1">property-list-pattern</i>  matches a fragment as follows:</p>
</li>
<li class="B1.Bullet1">Parse the fragment using the grammar for <i class="Parameter B1.Bullet1">property-list<em class="Subscript Parameter B1.Bullet1">opt</em></i> . If the parsing fails or does not consume the entire fragment, the pattern match fails.
</li>
<li class="B1.Bullet1">If the <i class="Parameter B1.Bullet1">property-list-pattern</i> contains <code class="cv B1.Bullet1"><a name="MARKER-2-1245"></a>#key</code> and does not contain <code class="cv B1.Bullet1">#all-keys</code>, the match fails if the <em class="B1.Bullet1">symbol</em> part of any property is not the <em class="B1.Bullet1">name</em> in some <i class="Parameter B1.Bullet1">pattern-keyword</i>  in the <i class="Parameter B1.Bullet1">property-list-pattern</i>. Comparison of a <em class="B1.Bullet1">symbol</em> to a <em class="B1.Bullet1">name</em> is case-insensitive, ignores backslash quoting, and is unaffected by the lexical context of the <em class="B1.Bullet1">name</em>.
</li>
<li class="B1.Bullet1">If the <i class="Parameter B1.Bullet1">property-list-pattern</i> contains <a name="MARKER-2-1246"></a><code class="cv B1.Bullet1">#rest</code>, bind the pattern variable immediately following <code class="cv B1.Bullet1">#rest</code> to the entire fragment. If the pattern variable has a non-wildcard constraint, parse the <i class="Parameter B1.Bullet1">value</i> part of each property according to this constraint, fail if the parsing fails or does not consume the entire <i class="Parameter B1.Bullet1">value</i> part, and substitute the fragment specified in <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints" on page 157</a> for the <i class="Parameter B1.Bullet1">value</i> part.
</li>
<li class="B1.Bullet1">Each <i class="Parameter B1.Bullet1">pattern-keyword</i> in the <i class="Parameter B1.Bullet1">property-list-pattern</i> binds a pattern variable as follows: 
<ul class="B2.Bullet2">
<li class="B2.Bullet2">A single <a name="MARKER-2-1247"></a>question mark finds the first property whose <em class="B2.Bullet2">symbol</em> is the <em class="B2.Bullet2">name</em> of the <i class="Parameter B2.Bullet2">pattern-keyword</i>. Comparison of a <em class="B2.Bullet2">symbol</em> to a <em class="B2.Bullet2">name</em> is case-insensitive, ignores backslash quoting, and is unaffected by the lexical context of the <em class="B2.Bullet2">name</em>. If the <i class="Parameter B2.Bullet2">pattern-keyword</i>  has a non-wildcard constraint, parse the property's <i class="Parameter B2.Bullet2">value</i>  according to this constraint, fail if the parsing fails or does not consume the entire <i class="Parameter B2.Bullet2">value</i> , and bind the pattern variable to the fragment specified in <a href="drm_82.html#MARKER-9-1256" class="B2.Bullet2">"Pattern Variable Constraints" on page 157</a>. If the <i class="Parameter B2.Bullet2">pattern-keyword</i>  has a wildcard constraint, bind the pattern variable to the property's <i class="Parameter B2.Bullet2">value</i>.
</li>
<li class="B2.Bullet2">A double <a name="MARKER-2-1248"></a>question mark finds every property with a matching <em class="B2.Bullet2">symbol</em>, processes each property's <i class="Parameter B2.Bullet2">value</i> as for a single question mark, and binds the pattern variable to a sequence of the values, preserving the order of properties in the input fragment. This sequence can only be used with double question mark in a template. Constraint-directed parsing applies to each property <i class="Parameter B2.Bullet2">value</i> individually.
</li>
</ul>
</li>
<li class="B1.Bullet1">If a single question mark <i class="Parameter B1.Bullet1">pattern-keyword</i> does not find any matching property, then if a <i class="Parameter B1.Bullet1">default</i> is present, the pattern variable binds to the default expression, otherwise the property is required so the pattern match fails.
</li>
<li class="B1.Bullet1">If a double question mark <i class="Parameter B1.Bullet1">pattern-keyword</i>  does not find any matching property, then if a <i class="Parameter B1.Bullet1">default</i> is present, the pattern variable binds to a sequence of one element, the default expression, otherwise the pattern variable binds to an empty sequence. 
</li>
<li class="B1.Bullet1">Note: the default expression in a <i class="Parameter B1.Bullet1">pattern-keyword</i>  is not evaluated during macro expansion; it is a parsed expression fragment that is used instead of a fragment from the macro call. The default is not subject to a pattern variable constraint.
</li>
</ul>
<a name="HEADING81-32"></a>
<a name="UID-Macros-1752"></a>
<h2 class="H2.Heading2"> Special Rules for Definitions</h2>
<p class="T1.Text1"><a name="MARKER-2-1249"></a>A list-style definition parses as the core reserved word <code class="cv T1.Text1">define</code>, an optional sequence of modifiers, a <em class="T1.Text1">define-list-word</em>, and a possibly-empty <i class="Parameter T1.Text1">list-fragment. </i>The left-hand side of a <i class="Parameter T1.Text1">list-style-definition-rule </i> matches this by treating the <i class="Parameter T1.Text1">definition-head</i> as a <i class="Parameter T1.Text1">pattern-sequence</i> and matching it to the sequence of modifiers, and then matching the <i class="Parameter T1.Text1">pattern</i> to the <i class="Parameter T1.Text1">list-fragment. </i>If no <i class="Parameter T1.Text1">definition-head</i> is present, the sequence of modifiers must be empty. If no <i class="Parameter T1.Text1">pattern  </i>is present, the <i class="Parameter T1.Text1">list-fragment </i>must be empty. The word <code class="cv T1.Text1">define</code> and the <em class="T1.Text1">define-list-word</em> do not participate in the pattern match because they were already used to identify the macro being called and because the spelling of the <em class="T1.Text1">define-list-word</em> might have been changed by renaming the macro during module importing.</p>
<p class="T1.Text1">A body-style definition parses as the core reserved word <code class="cv T1.Text1">define</code>, an optional sequence of modifiers, a <em class="T1.Text1">define-body-word</em>, a possibly-empty <i class="Parameter T1.Text1">body-fragment,</i> the core reserved word <code class="cv T1.Text1">end</code>, and optional repetitions of the <em class="T1.Text1">define-body-word</em> and the <em class="T1.Text1">name</em> (if any) that is the first token of the <i class="Parameter T1.Text1">body-fragment. </i>The left-hand side of a <i class="Parameter T1.Text1">body-style-definition-rule</i> matches this by treating the <i class="Parameter T1.Text1">definition-head</i> as a <i class="Parameter T1.Text1">pattern-sequence</i> and matching it to the sequence of modifiers, and then matching the <i class="Parameter T1.Text1">pattern</i> to the <i class="Parameter T1.Text1">body-fragment. </i>If no <i class="Parameter T1.Text1">definition-head</i> is present, the sequence of modifiers must be empty. If no <i class="Parameter T1.Text1">pattern </i>is present, the <i class="Parameter T1.Text1">body-fragment </i>must be empty. If the <i class="Parameter T1.Text1">body-fragment </i>ends in a semicolon, this semicolon is removed before matching. The optional semicolon in the rule is just decoration and does not participate in the pattern match. The word <code class="cv T1.Text1">define</code> and the <em class="T1.Text1">define-body-word</em> do not participate in the pattern match because they were already used to identify the macro being called and because the spelling of the <em class="T1.Text1">define-body-word</em> might have been changed by renaming the macro during module importing. The word <code class="cv T1.Text1">end</code> and the two optional items following it in the macro call are checked during parsing, and so do not participate in the pattern match.</p>
<p class="T1.Text1">It is an error for a <i class="Parameter T1.Text1">definition-head</i>  to contain more than one wildcard.<a name="MARKER-2-1250"></a></p>
<a name="HEADING81-36"></a>
<a name="UID-Macros-1760"></a>
<h2 class="H2.Heading2"> Special Rules for Statements</h2>
<p class="T1.Text1"><a name="MARKER-2-1251"></a>A statement parses as a <em class="T1.Text1">begin-word</em>, a possibly-empty <i class="Parameter T1.Text1">body-fragment,</i> the core reserved word <code class="cv T1.Text1">end</code>, and an optional repetition of the <em class="T1.Text1">begin-word</em>. The left-hand side of a <i class="Parameter T1.Text1">statement-rule</i> matches this by matching the <i class="Parameter T1.Text1">pattern</i> to the <i class="Parameter T1.Text1">body-fragment. </i>If the rule does not contain a <i class="Parameter T1.Text1">pattern,</i> the <i class="Parameter T1.Text1">body-fragment</i>  must be empty. If the <i class="Parameter T1.Text1">body-fragment</i> ends in a semicolon, this semicolon is removed before matching. The optional semicolon in the rule is just decoration and does not participate in the pattern match. The <em class="T1.Text1">begin-word</em> does not participate in the pattern match because it was already used to identify the macro being called and because its spelling might have been changed by renaming the macro during module importing. The word <code class="cv T1.Text1">end</code> and the optional item following it in the macro call are checked during parsing, and so do not participate in the pattern match.<a name="MARKER-2-1252"></a></p>
<a name="HEADING81-38"></a>
<a name="UID-Macros-1764"></a>
<h2 class="H2.Heading2"> Special Rules for Function Macros</h2>
<p class="T1.Text1"><a name="MARKER-2-1253"></a>A call to a function macro parses as a <em class="T1.Text1">function-word</em> followed by a parenthesized, possibly-empty <i class="Parameter T1.Text1">body-fragment</i>. The left-hand side of a <i class="Parameter T1.Text1">function-rule</i> matches this by matching the <i class="Parameter T1.Text1">pattern</i> to the <i class="Parameter T1.Text1">body-fragment. </i>If the rule does not contain a <i class="Parameter T1.Text1">pattern,</i> the <i class="Parameter T1.Text1">body-fragment</i> must be empty. The <em class="T1.Text1">function-word</em> does not participate in the pattern match because it was already used to identify the macro being called and because its spelling might have been changed by renaming the macro during module importing. The parentheses in the rule are just decoration and do not participate in the pattern match.</p>
<p class="T1.Text1">A function macro can also be invoked by any of the shorthand syntax constructs available for invoking functions. In this case, the arguments are always parsed expression fragments, as described on <a href="drm_77.html#MARKER-9-1199" class="T1.Text1">page 146</a>. However, the left-hand side of a function-rule has to use function-macro-call syntax even if the macro is intended to be called by operator, slot reference, or element reference syntax.<a name="MARKER-2-1254"></a><a name="MARKER-2-1255"></a></p>

</div>

<div class="wm-div-footers">

<div class="wm-div-toc">

<!-- TOC --><ul class="footer">
<li class="footer"><a rel="BELOW" href="drm_81.html#HEADING81-32" class="footer">Special Rules for Definitions</a></li>
<li class="footer"><a rel="BELOW" href="drm_81.html#HEADING81-36" class="footer">Special Rules for Statements</a></li>
<li class="footer"><a rel="BELOW" href="drm_81.html#HEADING81-38" class="footer">Special Rules for Function Macros</a></li>
</ul>


</div>

<hr class="footer" />
<address class="footer">The Dylan Reference Manual - 7 Apr 1998</address>
<p class="footer"><a href="drm_82.html" class="header"><img alt="next" src="next.gif" class="header" /></a> <a href="drm_80.html" class="header"><img alt="prev" src="prev.gif" class="header" /></a> <a href="drm_76.html" class="header"><img alt="up" src="up.gif" class="header" /></a> <a href="drm_1.html" class="header"><img alt="top" src="top.gif" class="header" /></a> <a href="drm_2.html" class="header"><img alt="content" src="content.gif" class="header" /></a> <a href="drm_127.html" class="header"><img alt="index" src="index.gif" class="header" /></a></p>
<p class="footer">Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</p>
<p class="footer">Generated with <a href="http://www.harlequin.com/webmaker" class="footer">Harlequin WebMaker&#174;</a></p>

</div>
</body>
</html>
