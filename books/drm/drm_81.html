<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  
  <!-- Relative Navigation -->
  
  <link rel="up" href="drm_76.html" />
  <link rel="prev" href="drm_80.html" />
  <link rel="next" href="drm_82.html" />
  
  <!-- Absolute Navigation -->
  
  <link rel="top" href="drm_1.html" />
  <link rel="start first" href="index.html" />
  <link rel="contents" href="drm_2.html" />
  <link rel="copyright" href="drm_3.html" />
  <link rel="glossary" href="drm_126.html" />
  <link rel="index" href="drm_127.html" />
  <link rel="last author" href="drm_128.html" />
  
  <!-- Chapters -->
  
  <link rel="chapter" title="About This Book" href="drm_4.html" />
  <link rel="chapter" title="1 Introduction" href="drm_5.html" />
  <link rel="chapter" title="2 Syntax" href="drm_9.html" />
  <link rel="chapter" title="3 Program Structure" href="drm_25.html" />
  <link rel="chapter" title="4 Program Control" href="drm_28.html" />
  <link rel="chapter" title="5 Types and Classes" href="drm_38.html" />
  <link rel="chapter" title="6 Functions" href="drm_47.html" />
  <link rel="chapter" title="7 Conditions" href="drm_52.html" />
  <link rel="chapter" title="8 Collections" href="drm_59.html" />
  <link rel="chapter" title="9 Sealing" href="drm_70.html" />
  <link rel="chapter" title="10 Macros" href="drm_76.html" />
  <link rel="chapter" title="11 The Built-In Classes" href="drm_87.html" />
  <link rel="chapter" title="12 The Built-In Functions" href="drm_96.html" />
  <link rel="chapter" title="13 Other Built-In Objects" href="drm_108.html" />
  <link rel="chapter" title="14 The Built-In Macros and Special Definitions" href="drm_110.html" />
  
  <!-- Appendices -->
  
  <link rel="appendix" title="A BNF" href="drm_116.html" />
  <link rel="appendix" title="B Exported Names" href="drm_119.html" />
  
  <!-- Stylesheet -->
  
  <link title="main style sheet" rel="stylesheet" href="drm.css" type="text/css" />

  <title>Patterns</title>
</head>
<body>

<div class="wm-div-body">
<a name="HEADING81"></a>

<div class="wm-div-headers">
<p class="header"><a href="drm_82.html" class="header"><img alt="next" src="next.gif" class="header" /></a> <a href="drm_80.html" class="header"><img alt="prev" src="prev.gif" class="header" /></a> <a href="drm_76.html" class="header"><img alt="up" src="up.gif" class="header" /></a> <a href="drm_1.html" class="header"><img alt="top" src="top.gif" class="header" /></a> <a href="drm_2.html" class="header"><img alt="content" src="content.gif" class="header" /></a> <a href="drm_127.html" class="header"><img alt="index" src="index.gif" class="header" /></a></p>
<p class="header">10 Macros</p>

</div>
<a name="HEADING81-0"></a>
<a name="UID-Macros-1648"></a>
<h1 class="H1.Heading1">Patterns</h1>
<p class="T1.Text1"><a name="MARKER-2-1237"></a>Approximately speaking, a pattern looks like the construct that it matches, but contains pattern variables that bind to portions of the construct. Hence, a left-hand side in the <var>main-rule-set</var> looks like a macro call. However, the grammar of patterns is not the same as the grammar of programs, but contains just what is required to match the portions of the Dylan grammar that are extensible by macros. Patterns have a simple nested grammar, with semicolons, commas, and brackets used to indicate levels of nesting. See the definition of <var>pattern</var> in <a href="drm_116.html#MARKER-9-2090" class="T1.Text1">Appendix A, "BNF."</a></p>
<p class="T1.Text1">A pattern matches a fragment (a sequence of elementary fragments) by executing the following algorithm from left to right. It is easy to create patterns that are ambiguous when considered as grammars. This ambiguity is resolved by the left to right processing order and the specified try-shortest-first order for matching wildcards. Pattern matching succeeds only if all sub-patterns match. If pattern matching fails, the current rule fails and control passes to the next rule in the current rule set. If all patterns in a rule set fail to match, the macro call is invalid.</p>
<p class="T1.Text1">Multiple occurrences of the same pattern variable name in a single rule's left-hand side are not valid.</p>
<p class="T1.Text1">A <var>pattern</var>  matches a fragment as follows:</p>
<ul class="B1.Bullet1">
  <li class="B1.Bullet1">If the pattern consists of just one pattern-list, go to the next step. Otherwise, divide the pattern into subpatterns and the fragment into subfragments at semicolons, and match subpatterns to subfragments individually in order. The subpatterns and subfragments do not include the semicolons that separate them. Suppose the pattern consists of N + 1 pattern-lists separated by N semicolons. Locate the first N semicolons in the fragment (without looking inside of elementary fragments) and divide up the fragment into subfragments accordingly. The match fails if the fragment contains fewer than N - 1 semicolons. As a special case, if the fragment contains N - 1 semicolons, the match still succeeds and the last subfragment is empty. If the fragment contains more than N semicolons, the extra semicolons will be in the last subfragment.</li>
</ul>
<p class="T1.Text1">A <a name="MARKER-2-1238"></a><var>pattern-list</var>  matches a fragment as follows:</p>
<ul>
  <li class="B1.Bullet1">If the pattern-list consists of just a pattern-sequence, go to the next step. If the pattern-list consists of just a property-list-pattern, go to that step. Otherwise divide the pattern-list into subpatterns and the fragment into subfragments at commas, and match subpatterns to subfragments individually in order. The subpatterns and subfragments do not include the commas that separate them. Suppose the pattern consists of N + 1 subpatterns separated by N commas. Locate the first N commas in the fragment (without looking inside of elementary fragments) and divide up the fragment into subfragments accordingly. The match fails if the fragment contains fewer than N - 1 commas. As a special case, if the fragment contains N - 1 commas, the match still succeeds and the last subfragment is empty. If the fragment contains more than N commas, the extra commas will be in the last subfragment. Note that the subdivision algorithms for commas and semicolons are identical.</li>
</ul>
<p class="T1.Text1">A <a name="MARKER-2-1239"></a><var>pattern-sequence</var>  matches a fragment as follows:</p>
<ul>
  <li class="B1.Bullet1">Consider each simple-pattern in the pattern-sequence in turn from left to right. Each simple-pattern matches an initial subsequence of the fragment and consumes that subsequence, or fails. The entire pattern match fails if any simple-pattern fails, if the fragment is empty and the simple-pattern requires one or more elementary fragments, or if the fragment is not entirely consumed after all simple-patterns have been matched. There is a special backup and retry rule for wildcards, described below.</li>
</ul>
<p class="T1.Text1">A <var><a name="MARKER-2-1240">simple-pattern</a></var> matches a fragment as follows:</p>
<ul>
  <li class="B1.Bullet1">A <em class="BNFCaps B1.Bullet1">name</em> or <code>=&gt;</code> consumes one elementary fragment, which must be identical to the <var>simple-pattern</var>. A <em class="BNFCaps B1.Bullet1">name</em> matches a name that is spelled the same, independent of modules, lexical scoping issues, alphabetic case, and backslash quoting. As a special case, after the word <code>otherwise</code>, an <code>=&gt;</code> is optional in both the pattern and the fragment. Presence or absence of the arrow in either place makes no difference to matching.</li>
  <li class="B1.Bullet1">A <a name="MARKER-2-1241"></a><var>bracketed-pattern</var> matches and consumes a <var>bracketed-fragment</var>. If the enclosed <var>pattern</var> is omitted, the enclosed <var>body-fragment</var> must be empty, otherwise the enclosed <var>pattern</var> must match the enclosed <var>body-fragment</var>  (which can be empty). The type of brackets ( <code>()</code>, <code>[]</code>, or <code>{}</code> ) in the <var>bracketed-fragment</var> must be the same as the type of brackets in the <var>bracketed-pattern</var>.</li>
</ul>
<p class="T1.Text1">A <a name="MARKER-2-1242"></a><var>binding-pattern</var>  matches a fragment as follows:</p>
<ul>
  <li class="B1.Bullet1"><var>pattern-variable</var> <code>::</code> <var>pattern-variable</var> consumes as much of the fragment as can be parsed by the grammar for <var>variable. </var>It matches the first pattern-variable to the <var>variable-name</var> and the second to the <var>type</var>, a parsed expression fragment. If no specializer is present, it matches the second pattern-variable to a parsed expression fragment that is a named value reference to <code>&lt;object&gt;</code> in the Dylan module. This matching checks the constraints on the pattern variable, fails if the constraint is not satisfied, and binds the pattern variable to the fragment.</li>
  <li class="B1.Bullet1"><var>pattern-variable</var> <code>=</code> <var>pattern-variable</var> consumes as much of the fragment as can be parsed by the grammar for <var>variable</var> <code>=</code> <var>expression</var>. It matches the first pattern-variable to the <var>variable</var>, a fragment, and the second to the <var>expression</var>, a parsed expression fragment.</li>
  <li class="B1.Bullet1"><var>pattern-variable</var> <code>::</code> <var>pattern-variable</var> <code>=</code> <var>pattern-variable</var> consumes as much of the fragment as can be parsed by the grammar for <var>variable</var> <code>=</code> <var>expression</var>. It matches the first two pattern-variables the same as the first kind of <var>binding-pattern</var> and it matches the third pattern-variable the same as the second kind of <var>binding-pattern</var>.</li>
</ul>
<p class="T1.Text1">A <var><a name="MARKER-2-1243">pattern-variable</a></var> matches a fragment as follows:</p>
<ul>
  <li class="B1.Bullet1">When the constraint is a wildcard constraint (see <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints" on page 157</a>), the pattern variable consumes some initial subsequence of the fragment, using a backup and retry algorithm. First, the wildcard consumes no elementary fragments, and matching continues with the next <var>simple-pattern</var> in the <var>pattern-sequence</var>. If any <var>simple-pattern</var> in the current <var>pattern-sequence</var> fails to match, back up to the wildcard, consume one more elementary fragment than before, and retry matching the rest of the <var>pattern-sequence</var>, starting one elementary fragment to the right of the previous start point. Once the entire <var>pattern-sequence</var> has successfully matched, the pattern variable binds to a fragment consisting of the sequence of elementary fragments that it consumed.</li>
  <li class="B1.Bullet1">It is an error for more than one of the <var>simple-patterns</var> directly contained in a <var>pattern-sequence</var> to be a wildcard.</li>
  <li class="B1.Bullet1">When the constraint is other than a wildcard constraint, the pattern variable consumes as much of the fragment as can be parsed by the grammar specified for the constraint in <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints" on page 157</a>. If the parsing fails, the pattern match fails. The pattern variable binds to the fragment specified in <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints."</a>  This can be a parsed fragment rather than the original sequence of elementary fragments.</li>
  <li class="B1.Bullet1">The ellipsis <var>pattern-variable</var>, <code>...</code>, can only be used in an auxiliary rule set. It represents a pattern variable with the same name as the current rule set and a wildcard constraint.</li>
</ul>
<p class="T1.Text1">A <a name="MARKER-2-1244"></a><var>property-list-pattern</var>  matches a fragment as follows:</p>
<ul>
  <li class="B1.Bullet1">Parse the fragment using the grammar for <var>property-list<em class="Subscript Parameter B1.Bullet1"><sub>opt</sub></em></var>. If the parsing fails or does not consume the entire fragment, the pattern match fails.</li>
  <li class="B1.Bullet1">If the <var>property-list-pattern</var> contains <a name="MARKER-2-1245"><code>#key</code></a> and does not contain <code>#all-keys</code>, the match fails if the <em class="BNFCaps B1.Bullet1">symbol</em> part of any property is not the <em class="BNFCaps B1.Bullet1">name</em> in some <var>pattern-keyword</var>  in the <var>property-list-pattern</var>. Comparison of a <em class="BNFCaps B1.Bullet1">symbol</em> to a <em class="BNFCaps B1.Bullet1">name</em> is case-insensitive, ignores backslash quoting, and is unaffected by the lexical context of the <em class="BNFCaps B1.Bullet1">name</em>.</li>
  <li class="B1.Bullet1">If the <var>property-list-pattern</var> contains <a name="MARKER-2-1246"><code>#rest</code></a>, bind the pattern variable immediately following <code>#rest</code> to the entire fragment. If the pattern variable has a non-wildcard constraint, parse the <var>value</var> part of each property according to this constraint, fail if the parsing fails or does not consume the entire <var>value</var> part, and substitute the fragment specified in <a href="drm_82.html#MARKER-9-1256" class="B1.Bullet1">"Pattern Variable Constraints" on page 157</a> for the <var>value</var> part.</li>
  <li class="B1.Bullet1">Each <var>pattern-keyword</var> in the <var>property-list-pattern</var> binds a pattern variable as follows:
    <ul class="B2.Bullet2">
      <li class="B2.Bullet2">A single <a name="MARKER-2-1247"></a>question mark finds the first property whose <em class="BNFCaps B2.Bullet2">symbol</em> is the <em class="BNFCaps B2.Bullet2">name</em> of the <var>pattern-keyword</var>. Comparison of a <em class="BNFCaps B2.Bullet2">symbol</em> to a <em class="BNFCaps B2.Bullet2">name</em> is case-insensitive, ignores backslash quoting, and is unaffected by the lexical context of the <em class="BNFCaps B2.Bullet2">name</em>. If the <var>pattern-keyword</var>  has a non-wildcard constraint, parse the property's <var>value</var>  according to this constraint, fail if the parsing fails or does not consume the entire <var>value</var> , and bind the pattern variable to the fragment specified in <a href="drm_82.html#MARKER-9-1256" class="B2.Bullet2">"Pattern Variable Constraints" on page 157</a>. If the <var>pattern-keyword</var>  has a wildcard constraint, bind the pattern variable to the property's <var>value</var>.</li>
      <li class="B2.Bullet2">A double <a name="MARKER-2-1248"></a>question mark finds every property with a matching <em class="BNFCaps B2.Bullet2">symbol</em>, processes each property's <var>value</var> as for a single question mark, and binds the pattern variable to a sequence of the values, preserving the order of properties in the input fragment. This sequence can only be used with double question mark in a template. Constraint-directed parsing applies to each property <var>value</var> individually.</li>
    </ul>
  </li>
  <li class="B1.Bullet1">If a single question mark <var>pattern-keyword</var> does not find any matching property, then if a <var>default</var> is present, the pattern variable binds to the default expression, otherwise the property is required so the pattern match fails.</li>
  <li class="B1.Bullet1">If a double question mark <var>pattern-keyword</var>  does not find any matching property, then if a <var>default</var> is present, the pattern variable binds to a sequence of one element, the default expression, otherwise the pattern variable binds to an empty sequence.</li>
  <li class="B1.Bullet1">Note: the default expression in a <var>pattern-keyword</var>  is not evaluated during macro expansion; it is a parsed expression fragment that is used instead of a fragment from the macro call. The default is not subject to a pattern variable constraint.</li>
</ul>
<a name="HEADING81-32"></a>
<a name="UID-Macros-1752"></a>
<h2 class="H2.Heading2">Special Rules for Definitions</h2>
<p class="T1.Text1"><a name="MARKER-2-1249"></a>A list-style definition parses as the core reserved word <code>define</code>, an optional sequence of modifiers, a <em class="BNFCaps T1.Text1">define-list-word</em>, and a possibly-empty <var>list-fragment. </var>The left-hand side of a <var>list-style-definition-rule </var> matches this by treating the <var>definition-head</var> as a <var>pattern-sequence</var> and matching it to the sequence of modifiers, and then matching the <var>pattern</var> to the <var>list-fragment. </var>If no <var>definition-head</var> is present, the sequence of modifiers must be empty. If no <var>pattern  </var>is present, the <var>list-fragment </var>must be empty. The word <code>define</code> and the <em class="BNFCaps T1.Text1">define-list-word</em> do not participate in the pattern match because they were already used to identify the macro being called and because the spelling of the <em class="BNFCaps T1.Text1">define-list-word</em> might have been changed by renaming the macro during module importing.</p>
<p class="T1.Text1">A body-style definition parses as the core reserved word <code>define</code>, an optional sequence of modifiers, a <em class="BNFCaps T1.Text1">define-body-word</em>, a possibly-empty <var>body-fragment,</var> the core reserved word <code>end</code>, and optional repetitions of the <em class="BNFCaps T1.Text1">define-body-word</em> and the <em class="BNFCaps T1.Text1">name</em> (if any) that is the first token of the <var>body-fragment. </var>The left-hand side of a <var>body-style-definition-rule</var> matches this by treating the <var>definition-head</var> as a <var>pattern-sequence</var> and matching it to the sequence of modifiers, and then matching the <var>pattern</var> to the <var>body-fragment. </var>If no <var>definition-head</var> is present, the sequence of modifiers must be empty. If no <var>pattern </var>is present, the <var>body-fragment </var>must be empty. If the <var>body-fragment </var>ends in a semicolon, this semicolon is removed before matching. The optional semicolon in the rule is just decoration and does not participate in the pattern match. The word <code>define</code> and the <em class="BNFCaps T1.Text1">define-body-word</em> do not participate in the pattern match because they were already used to identify the macro being called and because the spelling of the <em class="BNFCaps T1.Text1">define-body-word</em> might have been changed by renaming the macro during module importing. The word <code>end</code> and the two optional items following it in the macro call are checked during parsing, and so do not participate in the pattern match.</p>
<p class="T1.Text1">It is an error for a <var>definition-head</var>  to contain more than one wildcard.<a name="MARKER-2-1250"></a></p>
<a name="HEADING81-36"></a>
<a name="UID-Macros-1760"></a>
<h2 class="H2.Heading2">Special Rules for Statements</h2>
<p class="T1.Text1"><a name="MARKER-2-1251"></a>A statement parses as a <em class="BNFCaps T1.Text1">begin-word</em>, a possibly-empty <var>body-fragment,</var> the core reserved word <code>end</code>, and an optional repetition of the <em class="BNFCaps T1.Text1">begin-word</em>. The left-hand side of a <var>statement-rule</var> matches this by matching the <var>pattern</var> to the <var>body-fragment. </var>If the rule does not contain a <var>pattern,</var> the <var>body-fragment</var>  must be empty. If the <var>body-fragment</var> ends in a semicolon, this semicolon is removed before matching. The optional semicolon in the rule is just decoration and does not participate in the pattern match. The <em class="BNFCaps T1.Text1">begin-word</em> does not participate in the pattern match because it was already used to identify the macro being called and because its spelling might have been changed by renaming the macro during module importing. The word <code>end</code> and the optional item following it in the macro call are checked during parsing, and so do not participate in the pattern match.<a name="MARKER-2-1252"></a></p>
<a name="HEADING81-38"></a>
<a name="UID-Macros-1764"></a>
<h2 class="H2.Heading2">Special Rules for Function Macros</h2>
<p class="T1.Text1"><a name="MARKER-2-1253"></a>A call to a function macro parses as a <em class="BNFCaps T1.Text1">function-word</em> followed by a parenthesized, possibly-empty <var>body-fragment</var>. The left-hand side of a <var>function-rule</var> matches this by matching the <var>pattern</var> to the <var>body-fragment. </var>If the rule does not contain a <var>pattern,</var> the <var>body-fragment</var> must be empty. The <em class="BNFCaps T1.Text1">function-word</em> does not participate in the pattern match because it was already used to identify the macro being called and because its spelling might have been changed by renaming the macro during module importing. The parentheses in the rule are just decoration and do not participate in the pattern match.</p>
<p class="T1.Text1">A function macro can also be invoked by any of the shorthand syntax constructs available for invoking functions. In this case, the arguments are always parsed expression fragments, as described on <a href="drm_77.html#MARKER-9-1199" class="T1.Text1">page 146</a>. However, the left-hand side of a function-rule has to use function-macro-call syntax even if the macro is intended to be called by operator, slot reference, or element reference syntax.<a name="MARKER-2-1254"></a><a name="MARKER-2-1255"></a></p>

</div>

<div class="wm-div-footers">

<div class="wm-div-toc">

<ul class="footer">
<li class="footer"><a href="drm_81.html#HEADING81-32" class="footer">Special Rules for Definitions</a></li>
<li class="footer"><a href="drm_81.html#HEADING81-36" class="footer">Special Rules for Statements</a></li>
<li class="footer"><a href="drm_81.html#HEADING81-38" class="footer">Special Rules for Function Macros</a></li>
</ul>


</div>

<hr class="footer" />
<address class="footer">The Dylan Reference Manual - 7 Apr 1998</address>
<p class="footer"><a href="drm_82.html" class="header"><img alt="next" src="next.gif" class="header" /></a> <a href="drm_80.html" class="header"><img alt="prev" src="prev.gif" class="header" /></a> <a href="drm_76.html" class="header"><img alt="up" src="up.gif" class="header" /></a> <a href="drm_1.html" class="header"><img alt="top" src="top.gif" class="header" /></a> <a href="drm_2.html" class="header"><img alt="content" src="content.gif" class="header" /></a> <a href="drm_127.html" class="header"><img alt="index" src="index.gif" class="header" /></a></p>
<p class="footer">Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</p>
<p class="footer">Generated with <a href="http://www.harlequin.com/webmaker" class="footer">Harlequin WebMaker&#174;</a></p>

</div>
</body>
</html>
