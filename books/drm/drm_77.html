<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  
  <!-- Relative Navigation -->
  
  <link rel="up" href="drm_76.html" />
  <link rel="prev" href="drm_76.html" />
  <link rel="next" href="drm_78.html" />
  
  <!-- Absolute Navigation -->
  
  <link rel="top" href="drm_1.html" />
  <link rel="start first" href="index.html" />
  <link rel="copyright" href="drm_2.html" />
  <link rel="contents" href="drm_3.html" />
  <link rel="glossary" href="drm_126.html" />
  <link rel="index" href="drm_127.html" />
  <link rel="last author" href="drm_128.html" />
  
  <!-- Chapters -->
  
  <link rel="chapter" title="About This Book" href="drm_4.html" />
  <link rel="chapter" title="1 Introduction" href="drm_5.html" />
  <link rel="chapter" title="2 Syntax" href="drm_9.html" />
  <link rel="chapter" title="3 Program Structure" href="drm_25.html" />
  <link rel="chapter" title="4 Program Control" href="drm_28.html" />
  <link rel="chapter" title="5 Types and Classes" href="drm_38.html" />
  <link rel="chapter" title="6 Functions" href="drm_47.html" />
  <link rel="chapter" title="7 Conditions" href="drm_52.html" />
  <link rel="chapter" title="8 Collections" href="drm_59.html" />
  <link rel="chapter" title="9 Sealing" href="drm_70.html" />
  <link rel="chapter" title="10 Macros" href="drm_76.html" />
  <link rel="chapter" title="11 The Built-In Classes" href="drm_87.html" />
  <link rel="chapter" title="12 The Built-In Functions" href="drm_96.html" />
  <link rel="chapter" title="13 Other Built-In Objects" href="drm_108.html" />
  <link rel="chapter" title="14 The Built-In Macros and Special Definitions" href="drm_110.html" />
  
  <!-- Appendices -->
  
  <link rel="appendix" title="A BNF" href="drm_116.html" />
  <link rel="appendix" title="B Exported Names" href="drm_119.html" />
  
  <!-- Stylesheet -->
  
  <link title="main style sheet" rel="stylesheet" href="drm.css" type="text/css" />

  <title>The Dylan Reference Manual: 10 Macros</title>
</head>
<body>

<div class="wm-div-body">
<a name="HEADING77"></a>

<div class="wm-div-headers">
<div id="navigation-header">
    <p id="book-title">The Dylan Reference Manual</p>
    <p id="basic-navigation"><a class="previous" title="Go to previous page" href="drm_76.html"><img alt="Previous" src="prev.gif" /></a> <a class="next" title="Go to next page" href="drm_78.html"><img alt="Next" src="next.gif" /></a> <a class="up" title="Go to start of chapter" href="drm_76.html"><img alt="Up" src="up.gif" /></a> <a class="start" title="Go to start of book" href="drm_1.html"><img alt="Top" src="top.gif" /></a> <a class="contents" title="Go to table of contents" href="drm_3.html"><img alt="Contents" src="content.gif" /></a> <a class="index" title="Go to index" href="drm_127.html"><img alt="index" src="index.gif" /></a></p>
  </div>

<div id="section-header">
  <p id="section-prefix">Chapter 10</p>
  <p id="section-name">Macros</p>
</div>

<div id="navigation-TOC">
  <ul class="front-matter">
    <li><a href="drm_1.html">Start</a></li>
    <li><a href="drm_3.html">Contents</a></li>
    <li><a href="drm_4.html">About This Book</a></li>
  </ul>
  <ol class="chapters">
    <li><a href="drm_5.html">Introduction</a></li>
    <li><a href="drm_9.html">Syntax</a></li>
    <li><a href="drm_25.html">Program Structure</a></li>
    <li><a href="drm_28.html">Program Control</a></li>
    <li><a href="drm_38.html">Types and Classes</a></li>
    <li><a href="drm_47.html">Functions</a></li>
    <li><a href="drm_52.html">Conditions</a></li>
    <li><a href="drm_59.html">Collections</a></li>
    <li><a href="drm_70.html">Sealing</a></li>
    <li><a href="drm_76.html">Macros</a>
      <ul>
	<li id="current">Overview
	  <ul>
	    <li><a href="#HEADING77-3">Compilation and Macro Processing</a></li>
	  </ul>
	</li>
	<li><a href="drm_78.html">Extensible Grammar</a></li>
	<li><a href="drm_79.html">Macro Names</a></li>
	<li><a href="drm_80.html">Rewrite Rules</a></li>
	<li><a href="drm_81.html">Patterns</a></li>
	<li><a href="drm_82.html">Pattern Variable Constraints</a></li>
	<li><a href="drm_83.html">Templates</a></li>
	<li><a href="drm_84.html">Auxiliary Rule Sets</a></li>
	<li><a href="drm_85.html">Hygiene</a></li>
	<li><a href="drm_86.html">Rewrite Rule Examples</a></li>
      </ul>
    </li>
    <li><a href="drm_87.html">The Built-In Classes</a></li>
    <li><a href="drm_96.html">The Built-In Functions</a></li>
    <li><a href="drm_108.html">Other Built-In Objects</a></li>
    <li><a href="drm_110.html">The Built-In Macros and Special Definitions</a></li>
  </ol>
  <ol class="appendices">
    <li><a href="drm_116.html">BNF</a></li>
    <li><a href="drm_119.html">Exported Names</a></li>
  </ol>
  <ul class="back-matter">
    <li><a href="drm_126.html">Glossary</a></li>
    <li><a href="drm_127.html">Index</a></li>
    <li><a href="drm_128.html">Colophon</a></li>
  </ul>
  <ul class="errata">
    <li><a href="drm_errata.html">Errata</a></li>
  </ul>
</div>

<hr />

</div>

<a name="HEADING77-0"></a>
<a name="UID-Macros-2598"></a>
<h1 class="H1.Heading1">Overview</h1>
<p class="T1.Text1"><a name="MARKER-2-1175"></a>A <a name="MARKER-2-1176"></a>macro is an extension to the core language that can be defined by the user, by the implementation, or as part of the Dylan language specification. Much of the <a name="MARKER-2-1177"></a>grammatical structure of Dylan is built with macros. A macro defines the meaning of one construct in terms of another construct. The compiler substitutes the new construct for the original. The purpose of macros is to allow programmers to extend the Dylan language, for example by creating new control structures or new definitions. Unlike C, Dylan does not intend macros to be used to <a name="MARKER-2-1178"></a>optimize code by inlining. Other parts of the language, such as sealing and <code>define constant</code>, address that need.</p>
<p class="T1.Text1">Throughout this chapter, <var>italic font</var> and <em class="BNFCaps T1.Text1">small caps</em> are used to indicate references to the formal grammar given in <a href="drm_116.html" class="T1.Text1">Appendix A, "BNF."</a></p>
<a name="HEADING77-3"></a>
<a name="UID-Macros-5923"></a>
<h2 class="H2.Heading2">Compilation and Macro Processing</h2>
<p class="T1.Text1"><a name="MARKER-2-1179"></a>Compilation consists of six conceptual phases:</p>
<ol>
  <li><a name="MARKER-2-1180"></a>Parsing a stream of characters into tokens, according to the lexical grammar in <a href="drm_116.html" class="N/.NList=1">Appendix A, "BNF."</a></li>
  <li><a name="MARKER-2-1181"></a>Parsing a stream of tokens into a program, according to the phrase grammar in <a href="drm_116.html" class="N.NList">Appendix A, "BNF."</a></li>
  <li>Macro expansion, which translates the program to a core language.</li>
  <li><a name="MARKER-2-1182"></a>Definition processing, which recognizes special and built-in definitions and builds a compile-time model of the static structure of the program.</li>
  <li>Optimization, which rewrites the program for improved performance.</li>
  <li>Code generation, which translates the program to executable form.</li>
</ol>
<p class="T1.Text1">Portions of a program can be <a name="MARKER-2-1183"></a>macro calls. <a name="MARKER-2-1184"></a>Macro expansion replaces a macro call with another construct, which can itself be a macro call or contain macro calls. This expansion process repeats until there are no macro calls remaining in the program, thus macros have no space or speed cost at run time. Of course, expanding macros affects the speed and space cost of compilation.</p>
<p class="T1.Text1">A <a name="MARKER-2-1185"></a>macro definition describes both the syntax of a macro call and the process for creating a new construct to replace the macro call. Typically the new construct contains portions of the old one, which can be regarded as <a name="MARKER-2-1186"></a>arguments to the macro. A macro definition consists of a sequence of rewrite rules. The left-hand side of each rule is a pattern that matches a macro call. The right-hand side is a <a name="MARKER-2-1187"></a>template for the expansion of a matching call. <a name="MARKER-2-1188"></a>Pattern variables appearing in the left-hand side act as names for macro arguments. Pattern variables appearing in the right-hand side substitute arguments into the expansion. Macro arguments can be constrained to match specified elements of the Dylan grammar. Auxiliary rule sets enhance the rewrite rule notation with named subrules.</p>
<p class="T1.Text1">Some implementations and a future version of the Dylan language specification might allow macro expansions to be produced by compile-time computation using the full Dylan language and an object-oriented representation for programs. Such a "procedural macro" facility is not part of Dylan at this time.</p>
<p class="T1.Text1">The input to, and output from, macro expansion is a <a name="MARKER-2-1189"></a>fragment, which is a sequence of elementary fragments. An elementary fragment is one of the following:</p>
<ul class="B1.Bullet1">
  <li class="B1.Bullet1">A token: the output of the lexical grammar. The bracket tokens <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>#(</code>, and <code>#[</code> are not allowed. Core reserved words (except <code>otherwise</code>), <em class="BNFCaps B1.Bullet1">begin-words</em>, and <em class="BNFCaps B1.Bullet1">function-words</em> are not allowed unless quoted with backslash.</li>
  <li class="B1.Bullet1">A bracketed fragment: balanced brackets ( <code>()</code>, <code>[]</code>, or <code>{}</code> ) enclosing a fragment.</li>
  <li class="B1.Bullet1">A macro call fragment: a macro call.</li>
  <li class="B1.Bullet1">A parsed fragment: a single unit that is not decomposable into its component tokens. It has been fully parsed by the phrase grammar. A parsed fragment is either a function call, a list constant, a vector constant, a definition, or a local declaration.</li>
</ul>
<p class="T1.Text1">The second and third phases of compilation (parsing and macro expansion) are interleaved, not sequential. The parsing phase of the compiler parses a macro call just enough to find its end. See <var>definition-macro-call, statement, function-macro-call, body-fragment, list-fragment,</var> and <var>basic-fragment</var> in <a href="drm_116.html" class="T1.Text1">Appendix A, "BNF."</a> This process of parsing a macro call also parses any macro calls nested inside it. The result is a macro call fragment.</p>
<p class="T1.Text1">This loose grammar for macro calls gives users a lot of flexibility to choose the grammar that their macros will accept. For example, the grammar of macro calls doesn't care whether  a bracketed fragment will be interpreted as an argument list, a parameter list, a set of <code>for</code> clauses, or a module import list.</p>
<p class="T1.Text1"><a name="MARKER-2-1190"></a>The compiler delays computing the expansion of a macro call fragment until it is needed. If an argument to a macro is a macro call, the outer macro call is always expanded first. When the compiler computes the expansion of a macro call fragment, it obeys the macro's definition. Constraints on pattern variables can cause reparsing of portions of the macro call.</p>
<p class="T1.Text1"><a name="MARKER-2-1191"></a>A <var>constituent</var>, <var>operand</var>, or <var>leaf</var>  that is a macro call expands the macro during or before the definition processing and optimization phases. The compiler brackets the expansion in <code>begin</code> &hellip; <code>end</code>, using the standard binding of <code>begin</code> in the Dylan module, and then reparses it as a <var>statement</var>. This reparsing may discover more macro calls. A parse error while reparsing a macro expansion could indicate an invalid macro definition or an incorrect call to the macro that was not detected during pattern matching. Once the cycle of macro expansion and reparsing has been completed, no tokens, bracketed fragments, or macro call fragments remain and the entire source record has become one parsed fragment.</p>
<p class="T1.Text1">This <code><a name="MARKER-2-1192"></a>begin</code> &hellip; <code>end</code> bracketing ensures that the expansion of a macro call will not be broken apart by operator precedence rules when the macro call is a subexpression. Similarly, it ensures that the scopes of local declarations introduced by a macro will not extend outside that macro expansion when the macro call is a statement in a body.</p>
<p class="T1.Text1"><a name="MARKER-2-1193"></a>The fragment produced by parsing a macro call, which is the input to macro expansion, is as follows:</p>
<ul>
  <li class="B1.Bullet1"><a name="MARKER-2-1194"></a>Local declarations and <a name="MARKER-2-1195"></a><a name="MARKER-2-1196"></a>special definitions are parsed fragments.</li>
  <li class="B1.Bullet1">Calls to macros are macro call fragments.</li>
  <li class="B1.Bullet1"><a name="MARKER-2-1197"></a>List constants and vector constants are parsed fragments.</li>
  <li class="B1.Bullet1"><a name="MARKER-2-1198"></a>Anything in brackets is a bracketed fragment.</li>
  <li class="B1.Bullet1">If the macro call was not the result of macro expansion, everything else is represented as sequences of tokens. There are a few restrictions on the tokens, for example semicolons must appear in certain places and bare brackets cannot appear; for details see the definition of <var>body-fragment</var>  and <var>list-fragment</var>  in <a href="drm_116.html" class="B1.Bullet1">Appendix A, "BNF."</a></li>
  <li class="B1.Bullet1">In a macro call that is the result of macro expansion, additional items can be parsed fragments, due to pattern-variable substitution.</li>
  <li class="B1.Bullet1">Many built-in macros expand into implementation-specific parsed fragments.</li>
</ul>
<p class="T1.Text1"><a name="MARKER-9-1199"></a>The fragment produced by parsing an expression is as follows:</p>
<ul>
  <li class="B1.Bullet1"> An expression consisting of a single token returns a one-token fragment. This will be a variable-name, noncollection literal, or <em class="BNFCaps B1.Bullet1">symbol</em>.</li>
  <li class="B1.Bullet1">An expression consisting of just a <a name="MARKER-2-1200"></a>string literal returns a one-token fragment. If the string literal consists of multiple <em class="BNFCaps B1.Bullet1">string</em> tokens, they are concatenated into a single <em class="BNFCaps B1.Bullet1">string</em> token.</li>
  <li class="B1.Bullet1">An expression consisting of just a <a name="MARKER-2-1201"></a>list constant or a <a name="MARKER-2-1202"></a>vector constant returns a list constant or vector constant fragment.</li>
  <li class="B1.Bullet1">An expression consisting of just a <a name="MARKER-2-1203"></a>statement or <a name="MARKER-2-1204"></a>function-macro-call returns a macro call fragment.</li>
  <li class="B1.Bullet1">An <a name="MARKER-2-1205"></a>operator call, <a name="MARKER-2-1206"></a>slot reference, or <a name="MARKER-2-1207"></a>element reference that calls a function macro returns a macro call fragment.</li>
  <li class="B1.Bullet1">A function call, operator call, slot reference, or element reference that calls something other than a function macro returns a function call fragment.</li>
  <li class="B1.Bullet1">Enclosing an expression in parentheses does not change how it parses.</li>
</ul>
<p class="T1.Text1">The term "<a name="MARKER-2-1208"></a>parsed expression fragment" refers to any of the above.</p>
<p class="T1.Text1">The parser recognizes parsed fragments as well as raw tokens. The nonterminals <var>definition</var> and <var>local-declaration</var> in the phrase grammar accept parsed fragments of the same kind. The nonterminal <var>operand</var> accepts parsed function call fragments and macro call fragments. The nonterminal <var>literal</var> accepts list constant and vector constant fragments. The nonterminal <var>simple-fragment</var> accepts parsed function call fragments and macro call fragments. The nonterminal <var>macro</var> accepts macro call fragments. The parser expands bracketed fragments into their constituent tokens before parsing them.<a name="MARKER-2-1209"></a></p>

</div>

<div class="wm-div-footers">

<hr class="footer" />
<address class="footer">The Dylan Reference Manual - 7 Apr 1998</address>
<p class="footer"><a class="previous" title="Go to previous page" href="drm_76.html"><img alt="Previous" src="prev.gif" /></a> <a class="next" title="Go to next page" href="drm_78.html"><img alt="Next" src="next.gif" /></a> <a class="up" title="Go to start of chapter" href="drm_76.html"><img alt="Up" src="up.gif" /></a> <a class="start" title="Go to start of book" href="drm_1.html"><img alt="Top" src="top.gif" /></a> <a class="contents" title="Go to table of contents" href="drm_3.html"><img alt="Contents" src="content.gif" /></a> <a class="index" title="Go to index" href="drm_127.html"><img alt="index" src="index.gif" /></a></p>
<p class="footer">Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</p>
<p class="footer">Originally generated with <a href="http://www.harlequin.com/webmaker" class="footer">Harlequin WebMaker&#174;</a>, subsequently revised.</p>

</div>
</body>
</html>
