<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="top" href="drm_1.html" /><link rel="up" href="drm_70.html" /><link rel="prev" href="drm_74.html" /><link rel="next" href="drm_76.html" /><link title="main style sheet" rel="stylesheet" href="drm.css" type="text/css" /><title>Define Sealed Domain</title></head><body><div class="wm-div-body"><a name="HEADING75"></a><div class="wm-div-headers"><p class="header"><a href="drm_76.html" class="header"><img alt="next" src="next.gif" class="header" /></a> <a href="drm_74.html" class="header"><img alt="prev" src="prev.gif" class="header" /></a> <a href="drm_70.html" class="header"><img alt="up" src="up.gif" class="header" /></a> <a href="drm_1.html" class="header"><img alt="top" src="top.gif" class="header" /></a> <a href="drm_2.html" class="header"><img alt="content" src="content.gif" class="header" /></a> <a href="drm_127.html" class="header"><img alt="index" src="index.gif" class="header" /></a></p><p class="header">9 Sealing</p></div><a name="HEADING75-0"></a><a name="UID-Sealing-2976"></a><h1 class="H1.Heading1"> <a name="MARKER-9-1123"></a>Define Sealed Domain</h1><p class="T1.Text1"><code class="Code T1.Text1"><a name="MARKER-2-1124"></a><a name="MARKER-2-1125"></a>define sealed domain</code> is used to make specific portions of a generic function and of the class hierarchy invariant without disallowing all future changes. The arguments to <code class="cv T1.Text1">define sealed domain</code> are an explicitly known generic function and a series of types, one for each required argument of the generic function.</p><p class="T1.Text1">The complete syntax of <code class="cv T1.Text1">define</code> <code class="cv T1.Text1">sealed domain</code> is given on <a href="drm_112.html#MARKER-9-2024" class="T1.Text1">page 388</a>.</p><p class="T1.Text1">A <code class="Code T1.Text1">define sealed domain</code> definition in a library <i class="Parameter T1.Text1">L</i> for a generic function <i class="Parameter T1.Text1">G</i> with types <i class="Parameter T1.Text1">T<em class="Subscript Parameter T1.Text1">1...Tn</em></i> imposes the following <a name="MARKER-2-1126"></a>constraints on programs:</p><ol>  <li>A method <i class="Parameter N/.NList=1">M</i> that is congruent to <i class="Parameter N/.NList=1">G</i> and that is not an explicitly known method in <i class="Parameter N/.NList=1">L</i> may be added to <i class="Parameter N/.NList=1">G</i> only if at least one of the specializers for <i class="Parameter N/.NList=1">M</i> is disjoint from the corresponding <i class="Parameter N/.NList=1">T</i>.</li>  <li>A method <i class="Parameter N.NList">M</i> may be removed from <i class="Parameter N.NList">G</i> only if at least one of the specializers for <i class="Parameter N.NList">M</i> is disjoint from the corresponding <i class="Parameter N.NList">T</i>.</li>  <li>A class <i class="Parameter N.NList">C</i> (with direct superclasses <i class="Parameter N.NList">D<em class="Subscript Parameter N.NList">1</em></i>...<i class="Parameter N.NList">D<em class="Subscript Parameter N.NList">m</em></i>) that is not explicitly known in <i class="Parameter N.NList">L</i> may be created only if no method in <i class="Parameter N.NList">G</i> actually blocks <i class="Parameter N.NList">C</i>.</li>  <ul class="B2.Bullet2">    <li class="B2.Bullet2">A method <i class="Parameter B2.Bullet2">M</i> (with specializers <i class="Parameter B2.Bullet2">S<em class="Subscript Parameter B2.Bullet2">1</em></i>...<i class="Parameter B2.Bullet2">S<em class="Subscript Parameter B2.Bullet2">n</em></i>) in <i class="Parameter B2.Bullet2">G</i> potentially blocks <i class="Parameter B2.Bullet2">C</i> at argument position <i class="Parameter B2.Bullet2">i</i> if there exist <i class="Parameter B2.Bullet2">j</i> and <i class="Parameter B2.Bullet2">k</i> such that <i class="Parameter B2.Bullet2">D<em class="Subscript Parameter B2.Bullet2">j</em></i> is a pseudosubtype of <i class="Parameter B2.Bullet2">S<em class="Subscript Parameter B2.Bullet2">i</em></i>, <i class="Parameter B2.Bullet2">D<em class="Subscript Parameter B2.Bullet2">k</em></i> is a pseudosubtype of <i class="Parameter B2.Bullet2">T<em class="Subscript Parameter B2.Bullet2">i</em></i>, and <i class="Parameter B2.Bullet2">D<em class="Subscript Parameter B2.Bullet2">k</em></i> is not a pseudosubtype of <i class="Parameter B2.Bullet2">S<em class="Subscript Parameter B2.Bullet2">i</em></i>.</li>    <li class="B2.Bullet2">A method <i class="Parameter B2.Bullet2">M</i> actually blocks <i class="Parameter B2.Bullet2">C</i> if <i class="Parameter B2.Bullet2">M</i> potentially blocks <i class="Parameter B2.Bullet2">C</i> at some argument position, and for every argument position <i class="Parameter B2.Bullet2">i</i> where <i class="Parameter B2.Bullet2">S<em class="Subscript Parameter B2.Bullet2">i</em></i> and <i class="Parameter B2.Bullet2">T<em class="Subscript Parameter B2.Bullet2">i</em></i> are disjoint, <i class="Parameter B2.Bullet2">M</i> potentially blocks <i class="Parameter B2.Bullet2">C</i> at <i class="Parameter B2.Bullet2">i</i>.</li>  </ul></ol><p class="T1.Text1">The third constraint is illustrated by the following example:</p><pre class="Cv.Code">define generic m (x);define class &lt;t&gt; (&lt;object&gt;) end class &lt;t&gt;;define class &lt;s&gt; (&lt;object&gt;) end class &lt;s&gt;;define method m (s :: &lt;s&gt;) end method m;define sealed domain m (&lt;t&gt;);define class &lt;c&gt; (&lt;s&gt;, &lt;t&gt;) end class &lt;c&gt;;</pre><p class="T1.Text1">The definition of class <code class="Code T1.Text1">&lt;c&gt;</code> would be valid if it appeared in the same library as the preceding definitions or in a library used by them, but invalid if it appeared in a different library. The reason is that without the definition of <code class="Code T1.Text1">&lt;c&gt;</code>, the method defined on <code class="Code T1.Text1">m</code> is not within the domain declared by the <code class="Code T1.Text1">define sealed domain</code>, but with the definition of <code class="Code T1.Text1">&lt;c&gt;</code> the method is within that domain.</p><a name="HEADING75-13"></a><a name="UID-Sealing-2154"></a><h2 class="H2.Heading2"> Rationale</h2><p class="T1.Text1"><code class="Code T1.Text1"><a name="MARKER-2-1127"></a>define sealed domain</code> permits the compiler to assume certain properties of the program that can be computed based on explicitly known classes and methods, with a guarantee that an attempt to violate any of those assumptions will be detected.</p><p class="T1.Text1">The goal of rule 3 is that the creation of the class <i class="Parameter T1.Text1">C</i> must not make any method <i class="Parameter T1.Text1">M</i> applicable to a part of the sealed domain to which it was not previously applicable.</p><p class="T1.Text1">The "potentially blocks" concept describes the mechanism for testing whether the set of objects that are instances of both <i class="Parameter T1.Text1">S<em class="Subscript Parameter T1.Text1">i</em></i> and <i class="Parameter T1.Text1">T<em class="Subscript Parameter T1.Text1">i</em></i> (i.e., to which the method is applicable at the <i class="Parameter T1.Text1">i</i>th argument position and that are within the sealed domain at that argument position) would change as a result of creating <i class="Parameter T1.Text1">C</i>. By specifying what valid programs are allowed to do, rule 3 implicitly specifies the assumptions a compiler can make. A <code class="Code T1.Text1">define sealed domain</code> definition accomplishes this by permitting the compiler to eliminate some of the known methods on a generic function from the set of methods that might be applicable to a particular call at runtime. For example, if this leaves exactly one applicable method, the compiler can eliminate a run-time method dispatch and consider additional optimizations such as inlining.</p><p class="T1.Text1">Specifically, suppose the compiler is compiling a call to <i cla