<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link title="main style sheet" rel="stylesheet" href="dpg.css" type="text/css" />
		<link rel="top" href="db_1.html" />
		<link rel="up" href="db_12.html" />
		<link rel="prev" href="db_15.html" />
		<link rel="next" href="db_17.html" />
		<title>1.4   Rapid and productive development of programs</title>
	</head>
<body>

<div class="navigation">
	<p><a href="db_17.html"><img src="next.gif" alt="next" /></a> <a href="db_15.html"><img src="prev.gif" alt="previous" /></a> <a href="db_1.html"><img src="top.gif" alt="top" /></a> <a href="db_2.html"><img src="content.gif" alt="contents" /></a> <a href="db_349.html"><img src="index.gif" alt="index" /></a></p>
</div>

<div class="content" id="heading16-0">
<h1>1.4   Rapid and productive development of programs</h1>
<p>Dylan promotes rapid development and incremental refinement of prototype programs. The language encourages you to spend time early in the programming cycle writing and experimenting with substantive, working code, and not worrying about distracting issues such as memory management and exact type <br />specifications.</p>
<ul>
<li><p>Dylan allows flexible typing of variables, parameters, and return values. You can permit variables, parameters, and return values to be of a general type, so that their values can be objects of any subtype of the general type. Later in the development cycle, when the program specification is refined, you can add more specific type constraints.</p></li>
<li><p>You can choose to allow run-time definition of new classes and methods. Even if you do not so choose, most Dylan development environments allow you to add or change definitions at run time without recompiling or relinking the program, while the program is under development.</p></li>
<li><p>Like those of Java, Dylan implementations provide automatic storage management. You can create and use objects freely, even in complex algorithms, where control flow may make it difficult to tell when an object is no longer needed. You do not explicitly allocate or deallocate memory, and you do not have to worry about failing to free unused memory or referring to memory that has already been freed.</p></li>
<li><p>Dylan includes a powerful <strong>macro</strong> language, based on pattern matching and replacement. Macros let you extend the base language by creating syntactic structures that more concisely match a particular problem domain. Macros can serve as shorthand for common idioms, and can create more abstract or problem-specific constructs that the compiler translates into Dylan.</p></li>
</ul>

</div>

<div class="toc">

<!-- TOC -->

</div>

<div class="footer">
<address>Dylan Programming - 9 Apr 1999</address>
<p><a href="db_17.html"><img src="next.gif" alt="next" /></a> <a href="db_15.html"><img src="prev.gif" alt="previous" /></a> <a href="db_1.html"><img src="top.gif" alt="top" /></a> <a href="db_2.html"><img src="content.gif" alt="contents" /></a> <a href="db_349.html"><img src="index.gif" alt="index" /></a></p>
<p>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</p>

</div>
</body>
</html>
