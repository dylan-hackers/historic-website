<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link title="main style sheet" rel="stylesheet" href="dpg.css" type="text/css" />
		<link rel="top" href="db_1.html" />
		<link rel="up" href="db_12.html" />
		<link rel="prev" href="db_12.html" />
		<link rel="next" href="db_14.html" />
		<title>Dylan Programming: 1.1   Comparison of Dylan and other programming languages</title>
	</head>
<body>

<div class="navigation">
	<p><a href="db_14.html"><img src="next.gif" alt="next" /></a> <a href="db_12.html"><img src="prev.gif" alt="previous" /></a> <a href="db_1.html"><img src="top.gif" alt="top" /></a> <a href="db_2.html"><img src="content.gif" alt="contents" /></a> <a href="db_349.html"><img src="index.gif" alt="index" /></a></p>
</div>

<div class="content" id="heading13-0">
<h1>1.1   Comparison of Dylan and other programming languages</h1>
<p>Each language in wide use for applications has advantages and disadvantages. One way to compare languages is to imagine them arrayed along two axes. One axis ranges from <strong>procedural</strong> to <strong>object-oriented</strong> languages. The other axis ranges from <strong>static</strong> to <strong>dynamic</strong> languages. <a href="#marker-9-26">Figure 1.1</a> shows the comparison of several popular computer-programming languages on a graph.</p>
<ul>
<li><p>A program in a <strong>procedural</strong> language consists of <strong>functions</strong> operating on <strong>data</strong>. The programming task is to choose the best available representation for data, and the best algorithms for manipulating the data. Languages near the procedural end of the axis include C, FORTRAN, and COBOL.</p></li>
<li><p>A program in an <strong>object-oriented</strong> language consists of <strong>objects</strong>, categorized by <strong>class</strong>, that combine data and behavior. The programming task is to define the best class relations to represent objects, and the best set of operations that objects of related classes support. Languages near the object-oriented end of the axis include C++, Java, Smalltalk, and the Common LISP Object System (CLOS).</p></li>
<li><p>A <strong>static</strong> language requires most program structure -- such as the types of variables and function arguments -- to be determined at compile time. The compiler can detect errors and optimize performance at the cost of run-time flexibility. Languages near the static end of the axis include C, C++, and FORTRAN.</p></li>
<li><p>A <strong>dynamic</strong> language allows you to make more run-time changes to program structure, such as passing arguments of different types to the same function and, in some languages, defining new types or classes. A dynamic environment might allow run-time definition and linking. Languages near the dynamic end of the axis include Common LISP and Smalltalk.</p></li>
</ul>
<p>In reality, few languages in commercial use are purely procedural or object oriented, purely static or dynamic. In fact, the trend has been to add missing elements from one pole to languages that are close to the opposite pole. C++ adds object-oriented features to C; dynamic linking is becoming more common; LISP and Smalltalk vendors have made applications smaller and more efficient. This work, however, is hampered by the need to maintain compatibility with features of the language that were not designed with objects, dynamism, or performance in mind.</p>
<table>
	<caption>Figure 1.1: <a name="marker-9-26"></a>Object-oriented and dynamic extents of programming languages.</caption>
	<tr>
		<td>
			<img alt="Object-oriented and dynamic extents of programming languages" title="Object-oriented and dynamic extents of programming languages" src="figure-1.1.png" />
		</td>
	</tr>
</table>
<p>Dylan, in contrast, is a new language that integrates the best ideas from object-oriented, procedural, dynamic, and static languages, while avoiding many of the drawbacks. <a href="#marker-9-27">Figure 1.2</a> shows where Dylan fits on the graph.</p>
<table>
	<caption>Figure 1.2: <a name="marker-9-27"></a>Object-oriented and dynamic extents of Dylan and other languages. </caption>
	<tr>
		<td>
			<img alt="Object-oriented and dynamic extents of Dylan and otherlanguages" title="Object-oriented and dynamic extents of Dylan and other languages" src="figure-1.2.png" />
		</td>
	</tr>
</table><p>Dylan's goals are simple:</p>
<ul>
<li><p>Promote modular, reusable, component-oriented programs.</p></li>
<li><p>Support powerful and familiar procedural programming.</p></li>
<li><p>Encourage rapid and productive development of programs.</p></li>
<li><p>Permit delivery of safe, efficient, compact applications.</p></li>
</ul>
<p>Let's take a brief look at features of Dylan that support these goals.</p>

</div>

<div class="toc">

<!-- TOC -->

</div>

<div class="footer">
<address>Dylan Programming - 9 Apr 1999</address>
</div>
<div class="navigation">
	<p><a href="db_14.html"><img src="next.gif" alt="next" /></a> <a href="db_12.html"><img src="prev.gif" alt="previous" /></a> <a href="db_1.html"><img src="top.gif" alt="top" /></a> <a href="db_2.html"><img src="content.gif" alt="contents" /></a> <a href="db_349.html"><img src="index.gif" alt="index" /></a></p>
</div>
<div class="copyright">
	<p>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</p>
</div>
</body>
</html>
