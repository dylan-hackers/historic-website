<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link title="main style sheet" rel="stylesheet" href="dpg.css" type="text/css" />
		<link rel="top" href="db_1.html" />
		<link rel="up" href="db_113.html" />
		<link rel="prev" href="db_115.html" />
		<link rel="next" href="db_117.html" />
		<title>Dylan Programming: 9.3.3   Method dispatch and unions</title>
	</head>
<body>

<div class="navigation">
	<p><a href="db_117.html"><img src="next.gif" alt="next" /></a> <a href="db_115.html"><img src="prev.gif" alt="previous" /></a> <a href="db_1.html"><img src="top.gif" alt="top" /></a> <a href="db_2.html"><img src="content.gif" alt="contents" /></a> <a href="db_349.html"><img src="index.gif" alt="index" /></a></p>
</div>

<div class="content" id="heading116-0">
<h1>9.3.3   <a name="marker-9-304"></a>Method <a name="marker-2-305"></a>dispatch and unions</h1>
<p>When a type is a union, Dylan uses the following rules:</p>
<p>1.  An object is an instance of a union if it is an instance of any of the types that make up that union.</p>
<p>2.  If none of the types that make up a union is a subtype of any other, then </p>
<ul>
<li><p>A nonunion type is a proper subtype of a union if the nonunion type is a subtype of any of the types that make up the union.</p></li>
<li><p>A union is a proper subtype of a nonunion type if all types that make up the union are subtypes of the nonunion type, and if all the types that make up the union, taken together, are not equivalent to the nonunion type.</p></li>
<li><p>A union is a proper subtype of another union if <em>each</em> of the types that make up the first union is a subtype of <em>one</em> of the types that make up the other union, and if the two unions are not equivalent.</p></li>
</ul>
<p>For example, suppose that we have these definitions:</p>
<pre>
define constant &lt;false-or-integer&gt; = type-union(&lt;integer&gt;, singleton(#f));
<em>// Method 1
</em>define method say (x :: &lt;false-or-integer&gt;) ... end method say;
<em>// Method 2
</em>define method say (x :: &lt;integer&gt;) ... end method say;
</pre>
<p>Now, if <code>say</code> is called with an argument that is an integer, both methods are applicable, and method 2 is more specific than method 1. If <code>say</code> is called with an argument of <code>#f</code>, only method 1 is applicable.</p>

</div>

<div class="toc">


</div>

<div class="footer">
<address>Dylan Programming - 9 Apr 1999</address>
</div>
<div class="navigation">
	<p><a href="db_117.html"><img src="next.gif" alt="next" /></a> <a href="db_115.html"><img src="prev.gif" alt="previous" /></a> <a href="db_1.html"><img src="top.gif" alt="top" /></a> <a href="db_2.html"><img src="content.gif" alt="contents" /></a> <a href="db_349.html"><img src="index.gif" alt="index" /></a></p>
</div>
<div class="copyright">
	<p>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</p>
</div>
</body>
</html>
