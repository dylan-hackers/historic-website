<HTML>
<HEAD>
<TITLE>The d2c Dylan-to-C compiler</TITLE>
</HEAD>

<BODY>
<DL>


<DT><H2>The d2c Dylan-to-C compiler:</H2>
<DD>
<MENU>
<LI><A HREF="#LIMITATIONS">Limitations</A>
<LI><A HREF="#D2C-ARGS">Command-line arguments</A>
<LI><A HREF="#LIDFILE">LID file format</A>
<LI><A HREF="#EXTENSIONS">Extensions and Libraries</A>
<LI><A HREF="#MINDY">Mindy compatibility notes</A>
<LI><A HREF="#DIG">Debugger</A>
    <UL>
    <LI><A HREF="#DIGCOMM">DIG Commands</A>
    <LI><A HREF="#DIGCOTCHA">DIG Gotchas</A>
    </UL>
<LI><A HREF="#ENVIRONMENT">Environment</A>
<LI><A HREF="#FUNREP">Function Representations</A>
<LI><A HREF="#NAMING">Naming</A>
    <UL>
    <LI><A HREF="#CHARSET">Character Set Translation</A>
    <LI><A HREF="#BASICNAME">Basic Name Translation</A>
    <LI><A HREF="#DERIVEDNAME">Derived Name Translation</A>
    </UL
<LI><A HREF="#OBJREP">Object representations</A>
<LI><A HREF="#SPECADJ">Special adjectives</A>
<LI><A HREF="#OPT">Optimizations</A>
<LI><A HREF="#FILES">Generated Files</A>
<LI><A HREF="#CTC">Compile Time Constants</A>
</MENU>

<P>
<DT><H2><A NAME=LIMITATIONS>Limitations</A></H2>
<DD>

d2c does not implement all of Dylan.  In particular:
<UL>
 <LI> <CODE>make(&LT;class&GT;)</CODE> is not implemented.
 <LI> <CODE>slot-initialized?()</CODE>, <CODE>applicable-method?()</CODE> and
    <CODE>sorted-applicable-methods()</CODE> 
    are not implemented.
 <LI> <CODE>class</CODE> and <CODE>each-subclass</CODE> slot allocation are not
supported.
 <LI> The <CODE>keyword</CODE> clause to "<CODE>define class</CODE>" for
defining initargs (e.g. keyword foo:, ...) are parsed but ignored.

 <LI> The special syntax for <code>aref</CODE>, <CODE>element</CODE>, and
<CODE>singleton</CODE> is supposed to 
    look up the name in the context of the operation.  Instead, we always
    look it up in the <CODE>Dylan</CODE> library.

 <LI> In macro templates, unhygienic name references (e.g. ?=name) are not
    implemented.
 <LI> In macro property list patterns, the key default must be either a
    literal constant or a variable reference instead of any kind of
    expression as the DRM claims or a basic-fragment as Moon suggests.
 <LI> The ``<CODE>for</CODE>'' macro is supposed to evaluate the types
    interleaved with 
    the init expressions, but it does not.  In fact, in some cases, it
    will evaluate the type expression each time though the loop.
 <LI> Anything involving the runtime creation of classes is not supported.
    This means that the expressions in all class superclass lists must
    obviously be <A HREF="#CTC">compile-time constants</a>.
 <LI> Many violations of ``<CODE>define sealed domain</CODE>'' are not
detected.
</UL>


<DT><H2><A NAME="D2C-ARGS">Command-line arguments</A></H2>
<DD>
<PRE>
    d2c -gMndT {-t<VAR>directory</VAR>} {-L<VAR>directory</VAR>}*
        {-D<VAR>feature</VAR>}* {-U<VAR>feature</VAR>*}
        <VAR>lid-file</VAR>
</PRE>

<P>
  d2c compilation is driven by a LID (Library Interchange Description) file
  describing the library contents and various compilation options.  It serves a
  similar purpose to a make file (but we use make too.)  See the description of
  the LID file format below.

<P>
  In operation, d2c reads and processes the dylan files, generating .c and .s
  files and a temporary .mak makefile.  It then runs gmake on this makefile.

<P>
  d2c recognizes these switches:
<DL>
<DT><SAMP>-g</SAMP>
<DD>Dump definitions needed to support debugging with gdb/dig.

<DT><SAMP><A NAME="DASH-ELL">-L</A></SAMP><VAR>directory</VAR>
<DD>Add <VAR>directory</VAR> to the <A HREF="#DYLANPATH">library search
path</a>.

<DT><SAMP>-D</SAMP><VAR>feature</VAR><BR>
<SAMP>-U</SAMP><VAR>feature</VAR>
<DD>
Define or undefine a feature for <CODE>#if</CODE>
<A HREF="#SHARP-IF">conditional compilation</A>.  Features may
also be specified in the <A HREF="#LIDFILE">LID file</A> by the 
"<code>Features:</code>" option.

<DT><SAMP>-M</SAMP>
<DD>Generate dependency info to be included in makefiles.  This is included in
higher level makefiles such as those generated by the Perl
<A HREF="tools.html#MAKGEN">gen-makefile</A> script used to
compile the runtime system and compiler. 

<DT><SAMP>-p</SAMP><VAR>pathname</VAR>
<DD>
Used to specify the location for the platform description database
file.  The default is "<SAMP>$DYLANDIR/etc/platforms.descr</SAMP>".

<DT><SAMP>-no-binaries</SAMP>
<DD>
Inhibits compilation of the generated C code for cross-compilation.  You can
later compile by running make on the 
"<SAMP>cc-</SAMP><VAR>unit prefix</VAR><SAMP>-files.mak</SAMP>" or by using the
<A HREF="tools.html#MAKEGEN">Makegen</a> created
"<samp>cc_files</samp>" target.

<DT><SAMP>-T</SAMP><VAR>target</VAR>
<DD>
Generate code for the given target machine.  Normally defaults to this
platform.  See the <SAMP>platforms.descr</SAMP> file for the names of the
supported platforms.  Often used with <SAMP>-no-binaries</samp>.

<DT><SAMP>-d</SAMP>
<DD>Compiler debug mode (for debugging this compiler)
</DL>


<DT><H2><A NAME=LIDFILE>LID file format</A></H2>
<DD>
<P>
A LID file is composed of entries of the form
"<VAR>keyword</VAR><SAMP>: </SAMP><VAR>value</var>", similar to mail
headers and to the Dylan file header format.  Currently d2c expects the list of
source files to appear as the "main body" of the LID file, after the header and
a blank line.  In the Harlequin LID format, there is a "<code>Files: </code>"
entry which is used instead, and which we do not yet support.

<P>
  d2c recognizes these LID entries:
<DL>
<DT><CODE>Library: </CODE><VAR>dylan-library-name</VAR>
<DD>
    The Dylan name for the library that we are defining.  There must be a
    corresponding "<CODE>define library</CODE>" somewhere in the source for this library.

<DT><CODE>Unit-prefix: </CODE><VAR>c_legal_identifier_fragment</VAR>
<DD>
    This prefix is used to make the C translation of names in this library
    unique w.r.t. any other libraries that might be used.  This defaults to the
    library name, so only needs to be specified if the library name contains
    illegal C name characters (such as "<CODE>-</CODE>").

<DT><CODE>Unique-ID-base: </CODE><VAR>decimal-integer</VAR>
<DD>
    Unique class identifiers for classes defined in this library are assigned
    sequentially starting with the specified integer.  This should always be
    specified, but you won't get a sensible error if it is missing.  The base
    should be sufficiently far from the base for any other library so that
    class IDs won't overlap.  You will get a compile-time error if overlap
    occurs.  A good base for user code would be 30000.

<DT><CODE>Executable: </CODE><VAR>result-file-name</VAR>
<DD>Specifies that we are building a runnable application rather than a
    library.  The executable is generated with the specified name.

<DT><CODE><A NAME="ENTRY-POINT">Entry-Point: </A></code><VAR>dylan-module</VAR><CODE>:</CODE><VAR>dylan-variable</VAR>
<DD>
When generating an executable, this LID option specifies which dylan function
is called as the main entry point.  You can also have no main entry point, in
which case the program exits after running all of the top level forms.  This
entry-point function is called with two arguments, argc (an integer) and argv
(a raw pointer).  Note that this is incompatible with Mindy, and rather brutal
as well.  You can get the Mindy semantics of calling
<code>Extensions:Main</code> by using the <CODE>Extensions</CODE> module in
your main module and then specifying:
"<CODE>Entry-Point: </CODE><VAR>mymodule</var><code>:%main</code>"
in the LID file.  The <code>%Main</CODE> function parses the arguments and then
calls <CODE>Main</CODE>.

<DT><CODE>Linker-options: </code><var>various "ld" flags</var>
<DD>
    This option specifies flags which must be passed to ld when linking against
    this library.  This is primarily used when a foreign library is called via
    one of the undocumented callout mechanisms.  For example, Dylan.lid
    specifies "<CODE>-lm</code>" so that it can use the math library.  This
    dependency is automatically propagated to users of the library.
	
<DT><CODE>Features: </CODE>{<VAR>feature</VAR> | <CODE>~</CODE><VAR>feature</VAR>}*
<DD>
The argument is a space-separated list of features or misfeatures.  If the
token begins with "<CODE>~</code>", then the rest of the token is interpreted as a feature
to remove.  Otherwise, the token is added as a feature.
</DL>

Unrecognized LID entries are quietly ignored.  This handles any comment-like
LID entries such as "Author: ", etc.  d2c also recognizes <CODE>//</CODE> as a
comment-to-end-of-line sequence (equivalent to whitespace.)
<P>
Here is a sample LID file:
<HR>
<PRE>
rcs-header: $Header: /scm/cvs/www/old-docs/htdocs/d2c.html,v 1.1 1998/12/30 04:13:03 emk Exp $
library: my-program
unit-prefix: myprog
unique-id-base: 30000
executable: mp
entry-point: main:%main

myprog-exports.dylan
myprog.dylan
</PRE>
<HR>

<P>
<DT><H2><A NAME=EXTENSIONS>Extensions and Libraries</A></H2>
<DD>
d2c has been written so that most of the Dylan code can be shared between Mindy
and d2c.  Dylan extensions (such as conditional compilation) that are
implemented by both Mindy and d2c are described 
<A HREF="../../libraries/extensions.html">here</A>.  The common libraries are 
<A HREF="../common">here</A>.

<P>
<DT><H2><A NAME=MINDY>Mindy compatibility notes</A></H2>
<DD>
 <LI> In d2c the "main" entry is specified by the Entry-point: LID file
    option, and can be called whatever you want.  This differs from Mindy where
    there is a standard variable "dylan:extensions:main".  However you can the
mindy semantics by using <CODE>%main</CODE>, see 
<CODE><A HREF="#ENTRY-POINT">Entry-Point:</a></CODE>.
 <LI> The "<CODE>define library</CODE>" and "<CODE>define module</CODE>" forms
    for a library must be in a 
    separate file which is the first file specified in the LID file.  This file
    should specify "<CODE>Module: Dylan-User</CODE>" in its header.
 <LI> In general, d2c is much more picky about all sorts of errors.  It
      enforces type-related stuff to a much greater degree, and is even in some
    cases more picky about syntax.
 <LI> Unlike Mindy, d2c does implement macros.  In some cases this means that
    syntax error messages are not as good.  If you can't figure out a d2c
    syntax error, try Mindy.
 <LI> The d2c runtime does not automatically force output on 
    <CODE>*standard-output*</CODE> on process exit, so you may need to add
    explicit calls to <code>force-output</code>.
 <LI>  d2c is missing the TK and Inspector libraries.  Also,
    the d2c Random library is missing the more exotic functionality of
    the Mindy Random library, like <CODE>random-gaussian()</CODE> and
    <CODE>random-exponential()</CODE>.
 <LI> Mindy has some Dylan extensions which d2c does not implement.  The most
significant omission is threads.
<P>
<DT><H2><A NAME=DIG>Debugging D2C code with DIG</A></H2>
<DD>

Dig is a wrapper for GDB which incorporates some specialized domain knowledge
concerning the Dylan language and the D2C compiler.  For the most part, you
will seem to still be debugging the generated C code with GDB.  However, some
commands have been modified to allow a richer interface to Dylan objects and
functions.

<P>
<EM>Dig currently only compiles on HP/Ux and Win32, and is probably not useful
on the latter.  Feel free to get it working on other platforms.  dig is not
strictly necessary in any case, but it does sugarcoat some of the 
<A HREF="#NAMING">naming</A> issues.
</EM>

<P>
<H3><A NAME=DIGCOMM>DIG Commands</A></H3>
In general, every GDB command still exists within DIG (although you may not be
able to abbreviate it as expected -- for example, the "interactive" command
shadows the "info" command, so that you must type at least "inf").  However
some commands have been modified or added to facilitate debugging of Dylan
code.  The commands below reflect only the added capabilities.
<P>
<DL>
<DT><CODE>print</CODE> <DD> This command extends the existing print command by allowing it
   to print Dylan values and call Dylan functions.  This actually comprises
   three different special capabilities:  
<OL>
<LI>    DIG applies heuristics to translate Dylan variable names into their C
        equivalents.  It guess right most of the time, but the results are not
        guaranteed.  Sometimes there are several possibilities -- in this case
        it will ask you for clarification.
<LI>    If the expression value is a Dylan object then DIG invokes "<CODE>print</CODE>" to
        provide a meaningful description of the object.  (The choice of
        <EM>which</EM> "<CODE>print</CODE>" to use depends upon the setting of <CODE>*warning-output*</CODE>.)
        Because DIG calls a function within your program, the program must be
        running before Dylan values may be printed.
<LI>    If the expression contains a Dylan function call, then DIG invokes
        that Dylan function.  Arguments of the form "foo: bar" are translated
        correctly.
</OL>

<DT><CODE>find</CODE> <DD> prints the translation of a Dylan variable name into its C
   equivalent. 
<DT><CODE>break</CODE> <DD> if you specify a Dylan generic function, then DIG will set
 breakpoints in <EM>all</EM> of that function's methods.  Let me know if this
 feature proves to be useful.
<DT><CODE>interactive</CODE> <DD> by default, anything typed into DIG is assumed to be a DIG
   command.  If you need to provide input to your program, you must use this
   command to toggle the "interactive mode".  In interactive mode, you may
   type data into your process.  However, any type-ahead may produce strange
   and unpredictable results.
<DT><CODE>prompt</CODE> <DD> change DIG's command prompt.  (You should <EM>not</EM> use gdb's
native "<CODE>set prompt</CODE>" command.  Bad things will happen.)
<DT><CODE>quit</CODE> <DD> does about what you'd expect, but does some extra clean-up work.
<DT><CODE>gdb</CODE> <DD> passes the following text to GDB verbatim.  This allows you, for
   example, to use GDB's "<CODE>print</CODE>" command instead of DIG's.
</DL>
<P>
<H3><A NAME=DIGCOTCHA>DIG Gotchas</A></H3>
<UL>
<LI>Because of the challenges of name translation, the "<CODE>print</CODE>" and "<CODE>break</CODE>"
   commands may be noticeably slower than you expect.  Since translations
   are cached, it will get faster as you go along.
<LI>If you try to print something that looks like a Dylan object, but isn't
   valid, DIG will encounter a "beg fault" and have to recover.  This has the
   annoying side-effect of changing the "current frame" to be at the bottom of
   the call stack, regardless of where you were before.
<LI>Like GDB, DIG has problems with optimized code.  Variables may be re-used
   (or eliminated), function calls may be inlined, and things will generally
   be less predictable.  In addition, some Dylan functions may disappear if
   you do not pass the "<CODE>-g</CODE>" switch to D2C.
<LI>There are probably many other gotchas, but I don't know about them.  Please
   tell me about anything not mentioned above.
</UL>

    
<DT><H2><A NAME=ENVIRONMENT>Environment</A></H2>
<DD>

These environment variables are used by D2C:
<DL>
<DT><SAMP>DYLANDIR</SAMP>
<DD>
 The root of the installed Gwydion tree.  In the default configuration, this
defaults to "<SAMP>/usr/local</SAMP>" on Unix and "<SAMP>c:\dylan</SAMP>" on
win32.  This variable in turn establishes the defaults for
<SAMP>DYLANPATH</SAMP> and the <SAMP>"platforms.descr"</SAMP> file.


<DT><SAMP><A NAME=DYLANPATH>DYLANPATH</A></SAMP>
<DD>The search path for dylan libraries.  Directories in the
<SAMP>DYLANPATH</SAMP> are searched after any directories specified by explicit
<SAMP><A href="#dash-ell">-L</A></SAMP> options.  If not set, this defaults to 
"<SAMP>.:$DYLANDIR/lib/dylan</SAMP>" ("<SAMP>.;%DYLANDIR%\lib\dylan</SAMP>"  on
Win32).  If set, the value must include the
directory where the "<CODE>Dylan</CODE>" library is to be found.

<DT><SAMP>PATH</SAMP>
<DD>
d2c expects to find make and the C compiler in <SAMP>PATH</SAMP>.  
On Unix we use the gnu tools gmake, gcc, and ldb.
Other compilers can work,
but at a minimum this requires a new platform description in 
"<SAMP>$DYLANDIR/etc/platforms.descr</SAMP>".
You must also have some of the GNU-win32 tools to run d2c on Windows, though
make and Visual C++ are normally used for compilation.
  
To build d2c, you also need perl and the various scripts in the
<SAMP>tools/</SAMP>" directory.
<P>
The gnu assembler must be used in conjunction with the generated code
from gcc.  If you somehow end up running the HP/UX "as" with gcc,
it will produce many errors about STAB entries, etc.

<DT><SAMP>CCFLAGS</SAMP>
<DD>

This variable holds the flags passed to the C compiler. The default is platform
specific, but always includes "<SAMP>-I$DYLANDIR/include</SAMP>".  If you do
set this variable, you must also specify the Dylan system include directory.
The default optimization flags for gcc are
"<SAMP> -g -O4 -finline-functions</SAMP>".  You can roughly halve  the size of
the executable by omitting the <SAMP>-g</SAMP>, but at the cost of
debuggability.  Leaving out the other optimize flags will speed compilation at
the cost of runtime speed.
</DL>


<DT><H2><A NAME=FUNREP>Function Representations</A></H2>
<DD>
In d2c, there are two distinct things that may be thought of as "the
function".  The first is the actual C code d2c generates for the
function.  The second is an actual Dylan object (a "function object"),
which is a general instance of &lt;function&gt;.  Function objects are not
created if the compiler can prove it isn't necessary (which is usually
the case for functions that aren't exported from a library), where
"necessary" means that the function might be stored into a variable,
passed to another function, or otherwise used as a first-class value.
<P>
The actual C code comes in three pieces, or entries, with each entry
being a separate C function.  At a call site, the compiler can either
know exactly what function is being called or it might not have a clue
(e.g. inside map where it calls the passed in function).  So to keep
from having to pay the penalty of runtime checking everything all the
time instead of just when necessary, we generate multiple entry points
for each function.
<P>
The main entry is the entry that is used when the compiler can
determine that everything is fine.  It doesn't have to check any
argument types or figure out what values correspond to what keywords.
<P>
The general entry is the entry that is used in a random call where the
compiler can't tell anything.  It checks the argument types,
decodes the keywords, and then calls the main entry.
<P>
The generic entry is like the general entry, except that it is only
used when the method was invoked via some generic function.  The
generic function dispatch stuff already guarantees that they argument
types are okay, so it only has to decode the keywords before calling
the main entry.
</TEXT>
<P>
<DL>
<DT>Note:
<DD> the various entries are just different pieces of C code.  There
is no dylan object that correspond to them.  If the compiler can prove
a given entry won't be used, d2c will omit that entry.
</DL>

<DT><H2><A NAME=NAMING>Naming</A></H2>
<DD>
d2c generates C code, and thus must come up with a unique, legal C
identifier for each thing that is to be referenced.  (We say "thing"
because it isn't necessarily a Dylan object.)
d2c starts by computing a unit prefix ("unit" being synonymous with
"library").  The unit prefix can be user specified; if not specified, it
defaults to the library name in all lowercase.


<H3><A NAME=CHARSET>Character Set Translation</A></H3>

Since Dylan allows characters in identifiers that C does not, we must
translate these punctuation characters into alphanumeric sequences.  Because
Dylan is case-insensitive we also fold all alphabetic characters to lowercase.
This frees the uppercase characters to be used to represent the extra
characters.  We translate characters which aren't legal in C
as following:
<BLOCKQUOTE>
        '<code> </code>' =&gt; "<code>BLANK</code>"<BR>
        '<CODE>!</CODE>' =&gt; "<CODE>D</CODE>"<BR>
        '<CODE>%</CODE>' =&gt; "<CODE>PCT</CODE>"<BR>
        '<CODE>$</CODE>' =&gt; "<CODE>C</CODE>"<BR>
        '<CODE>&amp</CODE>' =&gt; "<CODE>AND</CODE>"<BR>
        '<CODE>*</CODE>' =&gt; "<CODE>V</CODE>"<BR>
        '<CODE>+</CODE>' =&gt; "<CODE>PLUS</CODE>"<BR>
        '<CODE>-</CODE>' =&gt; "<CODE>_</CODE>" <BR>
        '<CODE>/</CODE>' =&gt; "<CODE>SLASH</CODE>"<BR>
        '<CODE>&lt</CODE>' =&gt; "<CODE>LESS</CODE>"<BR>
        '<CODE>=</CODE>' =&gt; "<CODE>EQUAL</CODE>"<BR>
        '<CODE>&gt</CODE>' =&gt; "<CODE>GREATER</CODE>"<BR>
        '<CODE>?</CODE>' =&gt; "<CODE>QUERY</CODE>"<BR>
        '<CODE>^</CODE>' =&gt; "<CODE>RAISE</CODE>"<BR>
        '<CODE>_</CODE>' =&gt; "<CODE>X_</CODE>"<BR>
        '<CODE>|</CODE>' =&gt; "<CODE>OR</CODE>"<BR>
        '<CODE>~</CODE>' =&gt; "<CODE>NOT</CODE>"<BR>
        otherwise =&gt; "<STRONG>X</STRONG><var>hex code</var>"
</BLOCKQUOTE>
As a special case to deal with the Dylan <code>&LT;class&GT;</code> naming
convention, the brackets are stripped off of the variable name, and
<code>CLS_</code> is prefixed to the name.  So <code>&LT;list&GT;</code>
becomes <CODE>CLS_list</CODE> instead of <CODE>LESSlistGREATER</CODE>.

<H3><A NAME=BASICNAME>Basic Name Translation</A></H3>
A basic name is a module binding (like "define module" or "define
constant").  The C name is formed by concatenating the unit prefix, module name
and variable name, separated by uppercase Z's:
<DL>
<dd><var>unix prefix</var><strong>Z</strong><var>module name</var><strong>Z</strong><var>basic name</var>
</DL>

<H3><A NAME=DERIVEDNAME>Derived Name Translation</A></H3>

d2c needs to create C names for many global definitions which are related to
some Dylan variable but which are not the actual Dylan value of that variable.
These derived names are created by adding suffixes to the basic name:
<dl>
<dt><var>GF name</var><code>_METH</code>
<dd>Some method on the base name.

<dt><var>GF name</var><code>_DISCRIM</code>
<dd>Discriminator for a generic function.

<dt><var>method name</var><code>_GENERAL</code>       
<dd>Default entry for a method.

<dt> <var>method name</var><code>_GENERIC</code>
<dd>Method entry used by GF dispatch.

<dt><var>method name</var><code>_MAIN</code>
<dd>The actual body of a method.

<dt><var>method name</var><code>_INT_</code><var>local method name</var>
<dd>Local method inside named method.

<DT><VAR>method name</var><code>_INT_method</code>
<DD>Some <code>method</code> form inside the named method.

<DT><var>slot name</var><code>_DEFER</code>           
<DD>Deferred evaluation of a slot type.

<DT><var>slot name</var><code>_INIT</code>
<DD>Slot init function.

<dt><var>slot name</var><code>_SETTER</code>          
<dd>Method used to implement setting a slot.

<DT><var>slot name</var><code>_GETTER</code>
<DD> Method used to implement setting a slot

<DT><var>var name</var><code>_TYPE</code>
<DD>Holds the type of a variable when the type isn't constant.

<DT><var>var name</var><code>_VAR</code>
<DD>The actual value of a Dylan variable.

<DT><var>class name</var><code>_MAKER</code>
<DD>Internal constructor for a class.

<DT><code>LINE_542</code>
<DD>Some function resulting from compiling line 542.

<DT><code>UNKNOWN</code>
<DD>As above, except we don't where it came from.

<DT><var>some name</var><code>_542</code>
<DD>The 542'nd distinct instance of name.
<code>_VAR</code> names are guaranteed never to have this uniquifier suffix.
</DL>

<P>
As you might infer from the preceding, some suffixes can be combined, but
except for <code>_INT_</code> not to an arbitrary depth.  Some examples:
<PRE>
	dylanZdylan_visceraZCLS_type    /* &lt;type&gt; */

        /* general-entry for maker for &lt;type-error&gt; */
	dylanZdylan_visceraZCLS_type_error_MAKER_GENERAL

	/* signal{&lt;condition&gt;} internal search */
	dylanZdylan_visceraZsignal_METH_INT_search_MAIN

	dylanZdylan_visceraZVdebuggerV_VAR     /* *debugger* */
</PRE>

For local variables, we simply add "<code>L_</code>" to the front of the name.
This may result in a non-unique name.  In which case, a uniquifier is
appended to the end; see the "<var>some name</var><code>_542</code>" rule
above.

<P>

<DT><H2><A NAME=OBJREP>Object representations</A></H2>
<DD>

In general, d2c picks the most specific representation that it can be
sure will work.  For instance, if d2c is sure that a given object is
an &lt;integer&gt;, then it will use the C type "long" to represent the
object.  If, however, d2c only knows for sure that the object is an
&lt;object&gt;, d2c will use the descriptor_t representation, even if it
later turns out the &lt;object&gt; is in fact an &lt;integer&gt;.

<BLOCKQUOTE>
<TABLE BORDER>
<TR><TH>known dylan type</TH>		<TH>c type</TH> </TR>
<TR><TD>&lt;integer&gt</TD>		<TD>long</TD></TR>
<TR><TD>&lt;single-float&gt</TD>	<TD>float</TD></TR>
<TR><TD>&lt;double-float&gt</TD>	<TD>double</TD></TR>
<TR><TD>&lt;extended-float&gt</TD>	<TD>long double</TD></TR>
<TR><TD>&lt;raw-pointer&gt</TD>		<TD>void *</TD></TR>
<TR><TD>no data word</TD>		<TD>heapptr_t</TD></TR>
<TR><TD>&lt;object&gt</TD>		<TD>descriptor_t</TD></TR>
</TABLE>
</BLOCKQUOTE>

<DL>
<DT>Note:
<DD> There isn't a dylan type that can describe the set of objects
that use the heapptr_t representation.  See above.
<P>
<DT>Note 2:
<DD> If a functional (see below) class has exactly one data slot
that can be magically represented, it is also magically represented in
the same way.  &lt;character&gt; falls into this category.
</DL>

<P>
An immediate representation is one where the actual data is directly
there.  As opposed to a pointer representation where the actual data
lives in the heap and is referenced via a pointer.
<P>
The general representation is the fully general representation that
can be used to represent any Dylan object.  It consists of a heap
pointer and a data word.  (i.e. descriptor_t)
The heap pointer representation is used to represent anything that
doesn't need the data word.  (i.e. heapptr_t)
<P>
"Boxed" and "unboxed" are somewhat vague terms that one will often
hear on the 'net.  Unboxed data is the raw data, the good stuff, with
no overhead.  The drawback is that if you don't know the type of the
raw data (is it an integer, a character, or a float?), it's just a
bunch of bits.  Boxing means to add meta-data (the type of the data)
so that the data can be interpreted unambiguously.  The d2c immediate
representation is an unboxed representation, while the d2c general
representation is a boxed representation.  Depending on the situation,
the heap pointer representation might be considered either boxed or
unboxed.

<P>
<DT><H2><A NAME=SPECADJ>Special adjectives</A></H2>
<DD>

<DL> <DT><code>inline</code><DD> Methods can be declared inline.  If a method
is inline, then the body of the method is duplicated at all valid call sites.
This allows optimization of the called code based on the calling context.

<DT><code>movable</code><DD>Methods and generic functions can be declared
movable.  A movable function is one that doesn't depend on when it happens.  In
other words, in can't depend on any global state, just the arguments.

<P>
Plus is an example of a movable function:
<code>2 + 2</code> is always <code>4</code> no matter
when.  <code>movable</code> implies <code>flushable</code>; see below.

<DT><code>flushable</code><DD>
Methods and generic functions can be declared flushable.
This means that the function may depend on global state, but cannot
change any global state.  Extracting the value of a slot is a
flushable operation (assuming the slot is guaranteed to be
initialized).  If the result of a flushable function isn't used, the
call can be dropped.

<DT><CODE>functional</CODE><DD>Classes can be declared functional.  The
slots of functional classes have to be constant (and in fact, default to
constant).  Furthermore, equality (<code>==</code>) is defined in terms of the
slot values, not the pointer identity of the heap representation of the object.
Actually, currently you have to define a <code>functional-==</code> method that
checks to see if two instances of a functional class are the same yourself.  So
you could intentionally get it wrong, and then strange things would happen.
But the idea is that the instances will be <code>==</code> iff the object-class
for them both is the same and all slots are <code>==</code>.  Functional
classes may have subclasses, but be sure to define <code>functional-==</code>
methods accordingly.
</DL>

<DT><H2><A NAME=OPT>Optimizations</A></H2>
<DD>
<P>

d2c performs the following optimizations:
<BLOCKQUOTE>
common sub-expression
elimination (CSE), optimistic type inferencing, compile time method
selection, inlining, code motion.
</BLOCKQUOTE>
See also <A HREF="#CTC">compile time constants.</A>



<DT><H2><A NAME=FILES>Generated Files</A></H2>
<DD>
<P>
<DL>
d2c generates a variety of files.  They are:
<DT> <SAMP>*.c</SAMP>
<DD> d2c generates a .c file for each .dylan file it processes.

<DT><VAR>unitprefix</VAR><SAMP>-inits.c</SAMP><DD> contains code for performing
various initializations for this particular library.  This includes executing
any top-level expressions contained in the library.

<DT><VAR>unitprefix</VAR><SAMP>-heap.s</SAMP><DD> contains the initial heap
image for this particular library.

<DT><SAMP>cc-</SAMP><VAR>unitprefix</VAR><SAMP>-files.mak</SAMP><DD> A makefile
which contains rules for compiling all the .c and .s files, and linking either
an executable or a library, depending on which the LID file specifies.

<DT><SAMP>library.lib.du</SAMP><DD> (Only generated when not building an
executable) Contains various information about the library that d2c needs to
remember.

<DT><SAMP>inits.c</SAMP><DD> (Only generated when building an executable) It
invokes each library's initialization routines, then calls the entry-point
function (if any).

<DT><SAMP>heap.s</SAMP><DD> (Only generated when building an executable) It
contains initial heap information that is of a global nature.  For instance,
because all symbols with the same value are <code>==</code>, the literal
<code>#"foo"</code> in the String-extensions library is <code>==</code> to the
literal <code>#"foo"</code> in the Streams library, and so cannot go in either
library's <VAR>unitprefix</VAR><SAMP>-heap.s</SAMP>.  Currently symbols are the
only object with this property.
</DL>

<DT><H2><A NAME=CTC>Compile Time Constants</A></H2>
<DD>

In Dylan, the type in a type declaration is an expression just like any other.
This means that in general, the compiler can't tell what a type declaration
means without running the program.  That won't work, so what d2c actually does
is recognize simple type expressions and then exploit the obtained type
information for optimization and type inference.  

<P>
If the type expression isn't an obvious compile-time constant, then d2c gains
no useful information from it, but is required to go to extra work to implement
a run-time check.  For this reason, your code will compile much better if you
only use type expressions which d2c can recognize as being constant.




The notion of compile time constant lies at the heart of many of d2c's
optimizations.  

<P>
To start with, some terminology:
<DL>
<DT>ctype<DD>The compile-time representation of a Dylan type.  If a type is not
constant, it is represented as an <CODE>&lt;unknown-ctype&gt;</CODE>, which
frustrates any attempt at further type inference.

<DT>ct-value<DD> 
A compile-time value.  The phrase "compile time
constant" is synonymous.  &lt;ct-value&gt; is not a subclass of
&lt;ctype&gt;, nor the other way around.  However, there are many
classes which are subtypes of both &lt;ctype&gt; and &lt;ct-value&gt;.

<DT>EQL-value<DD>A value is an eql-value if members of its class can be
compared with ==.  &lt;class&gt;es, &lt;integer&gt;s, &lt;character&gt;s, and
&lt;symbol&gt;s are eql-values; in d2c non-class &lt;type&gt;s are not.

<DT>eql-ct-value<DD> A ct-value which is also an eql-value.
</DL>


<P>If we can figure out a ct-value equivalent to an expression parse, we say
that expression is ct-evaluable.  An expression is ct-evaluable if
any of the following holds:
<UL>
<LI> The expression is a literal.

<LI>
        The expression is a body (e.g. the guts of a
        begin/end), and each expression in the body is ct-evaluable.
        (A body whose last component expression is ct-evaluable, but
        which also has non-ct-evaluable expressions in it, might have
        side effects.  Thus, the body can't be ct-evaluable because
        that might suppress the side effects.)

<LI>
        The expression is a reference to a binding, and that
        binding is to a module binding rather than a local binding,
        and the definition it is bound to is ct-evaluable (see below).

<LI>
        The expression is a function call, and the arguments
        to the function are all ct-evaluable, and the function itself
        is a direct reference to a module binding which is a function
        (ie, we know which function to invoke), and the function has
        built-in support, and the function call meets the conditions
        of that specific function (see below).
</UL>

<P>Some definitions are ct-evaluable, and some are not:
<UL>
<LI>
        A "define variable" definition is never ct-evaluable, because
        it is variable.
<LI>
        A "define constant" is ct-evaluable if the type constraint is
        ct-evaluable and the initial value is ct-evaluable.
<LI>
        A "define generic" is ct-evaluable if all specializers, all
        result types, and the type constraints on #rest types are
        ct-evaluable.
<LI>
        A "define method" doesn't usually define a module binding;
        define generics do.  However, if the define method introduces
        an implicit generic, that implicit generic is ct-evaluable.
<LI>
        "define function" in d2c is equivalent to "define method".
<LI>
        "define class" is ct-evaluable if all its superclasses are
        ct-evaluable.  (Note that d2c currently will puke if a class
        has a non-ct-evaluable superclass, so effectively all classes
        in d2c are ct-evaluable.)
<LI>
        "define macro", "define module", and "define library" don't
        produce module bindings.
</UL>

<P>
For function calls to most functions with built-in support, simply
knowing that the arguments and the function are ct-evaluable is enough
to make the function call ct-evaluable.  These functions include:
<BLOCKQUOTE>
<CODE>
        type-union, false-or, subclass, direct-instance, negative,
        abs, \+, \-, \*, ash, \^, logior, logxor, logand, lognot
</CODE>
</BLOCKQUOTE>

<code>limited(&lt;integer&gt;)</code> and 
<code>limited(&lt;collection&gt;)</code> are also ct-evaluable if
their arguments are ct-evaluable.
<P>
However, two functions are different.  In addition to requiring that
the arguments and the function are ct-evaluable, they impose
additional constraints:
<DL>
<DD>
<code>singleton(</code><var>obj</var><code>)</code>
is ct-evaluable only if <var>obj</var> is an
eql-ct-value.

<P>
<code>one-of(</code><var>obj1, obj2, ...</var><code>)</code>
is ct-evaluable only if every arg is an eql-ct-value.
</DL>

<P>
The most common way to construct a type which is not ct-evaluable is
to create a singleton of a non-class type.  For instance, although
<PRE>
        type-union(&lt;foo&gt;, &lt;bar&gt;)
</PRE>

is ct-evaluable, 
<PRE>
        singleton(type-union(&lt;foo&gt;, &lt;bar&gt;))
</PRE>
is not.

</DL>

<P ALIGN=CENTER><HR>[ <A
HREF="http://legend.gwydion.cs.cmu.edu/gwydion">Gwydion home page</A> |
<A HREF="mailto:gwydion-group@cs.cmu.edu">mail to gwydion-group</A>
]</P>

</BODY>
</HTML>
