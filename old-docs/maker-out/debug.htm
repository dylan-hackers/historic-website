<HTML>
<HEAD>
<TITLE>Gwydion Dylan The Mindy Debugger   The Mindy Debugger</TITLE>
<LINK REL="ToC" HREF="httoc.htm">
<LINK REL="Index" HREF="htindex.htm">
<LINK REL="Next" HREF="inspect.htm">
<LINK REL="Previous" HREF="mindy.htm"></HEAD>
<BODY>

<H2>The Mindy Debugger</H2>
<P ALIGN=CENTER>
<A HREF="mindy.htm" TARGET="_self"><IMG SRC="gmindy/blrprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>
<A HREF="httoc.htm" TARGET="_self"><IMG SRC="gmindy/blrtoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>
<A HREF="htindex.htm" TARGET="_self"><IMG SRC="gmindy/blrindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>
<A HREF="inspect.htm" TARGET="_self"><IMG SRC="gmindy/blrnext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>
<A HREF="http://legend.gwydion.cs.cmu.edu/gwydion" TARGET="_self"><IMG SRC="gmindy/blrhome.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="See Page"></A>

<P>
<CENTER><TABLE BORDER=1 CELLSPACING=1 ><TR>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="mindy.htm#E28E1">Mindy Compiler</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="debug.htm#E28E2">Mindy Debugger</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="inspect.htm#E28E3">Mindy Object</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="EXTENS~1.htm#E28E4">Extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="streams.htm#E28E5">Streams Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="STANDA~1.htm#E28E6">Standard IO</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="print.htm#E28E7">Print Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="format.htm#E28E8">Format Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="melange.htm#E28E9">Melange Interface</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="dylan-tk.htm#E28E10">TK Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="COLLEC~1.htm#E28E11">Collection extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="TABLE-~1.htm#E28E12">Table Extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="STRING~1.htm#E28E13">String extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="REGULA~1.htm#E28E14">Regular Expressions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="TRANSC~1.htm#E28E15">Transcendental Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="time.htm#E28E16">Time Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="random.htm#E28E17">Random Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="matrix.htm#E28E18">Matrix Library</A>
</TD></FONT>
</TR></TABLE>
</CENTER><HR ALIGN=CENTER>
<P>
<UL>
<LI>
<A HREF="#E8E19" >1. Introduction</A>
<LI>
<A HREF="#E8E20" >2. Stack Manipulation Commands</A>
<LI>
<A HREF="#E8E21" >3. Examining Variables</A>
<LI>
<A HREF="#E8E22" >4. Libraries and Modules</A>
<LI>
<A HREF="#E8E23" >5. Evaluating Expressions</A>
<LI>
<A HREF="#E8E24" >6. Debugger Variables</A>
<LI>
<A HREF="#E8E25" >7. Restarts and Returning</A>
<LI>
<A HREF="#E8E26" >8. Interrupting and Single Stepping</A>
<LI>
<A HREF="#E8E27" >9. Breakpoints</A>
<LI>
<A HREF="#E8E28" >10. Threads</A>
<LI>
<A HREF="#E8E29" >11. Inspect and Xinspect</A>
<LI>
<A HREF="#E8E30" >12. Miscellaneous Commands</A>
<LI>
<A HREF="#E8E31" >13. Copyright and Terms Of Use</A></UL>
<HR ALIGN=CENTER>
<P ALIGN=CENTER><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<A NAME="E28E2"></A>
<H1 ALIGN=CENTER>
<CENTER><B> The </B><A NAME="I2"></A><B>Mindy Debugger</B></CENTER></H1>
<P ALIGN=CENTER><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P><I>Copyright (c) 1994, 1995, 1996, 1997 Carnegie Mellon University All rights reserved.  Refer to the </I><I>end of this document for precise terms of use. </I>
<BR>
<A NAME="E8E19"></A>
<H2><B>1. </B><B>Introduction</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>When something goes wrong with your program, Mindy drops into the debugger. From the debugger, you can examine the stack, print out variables, evaluate expressions, and do various other things that can be helpful in figuring out what went wrong.
<P>For example, if you did not define a method for main, after starting Mindy you would see something like the following:
<CODE>
<PRE>    No applicable methods for main with arguments #[&quot;mindy&quot;]
<BR>
<BR>    thread [0] D   main
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x1023fa91})
<BR>    mindy&gt; </PRE>
</CODE>
<P>The first line is the error message.  The second line tells you about the thread that encountered the error.  For more information about threads see Section <I>Threads</I>.  The third line tells you about the current stack frame for the thread; in this example, the last function called, which is at the top of the stack, is the <A NAME="I3"></A><B>invoke-debugger</B> function.  It was called with one argument, a <B>&lt;simple-error&gt;</B>.
<P>The following sections discuss the various commands provided by the debugger.  As a general rule, you can invoke a command by typing at least a unique prefix of its name.  There are three commonly used commands for which a single letter suffices, regardless of all other command names:
<UL>
<LI>(d)own
<LI>(l)ocals
<LI>(c)ontinue
</UL>
<P>Throughout this document, some examples build on previous examples, even when those previous examples come from previous sections of the document. If there is a reference to the &quot;previous example&quot;, then please look to the previous section's text.
<P>This documentation uses the term <I>built-in</I> for definitions created in C code, within Mindy's implementation.  Opposed to built-in definitions are definitions written in Dylan code.  Parts of Mindy are built-in and parts are defined in Dylan code.  Of course, all user code is written in Dylan. Some debugger commands behave differently depending on whether the object being manipulated was defined in Dylan code or built-in.
<BR>
<A NAME="E8E20"></A>
<H2><B>2. </B><A NAME="I4"></A><B>Stack Manipulation Commands</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>The Mindy debugger offers a few commands for moving up and down the stack. The two most common commands are <A NAME="I5"></A>up and <A NAME="I6"></A>down.  Mindy considers the most recently called function to be at the top of the stack and the least recently called function to be at the bottom of the stack.  Hence, moving down the stack moves you from a callee to its caller.  For example, if you were to type down after the previous example, you would see something like the following:
<CODE>
<PRE>    mindy&gt; down
<BR>    fp 0x10034078: error({&lt;simple-error&gt; 0x1023fa91}, #[], #())
<BR>    /afs/cs.cmu.edu/project/gwydion/mindy/src/runtime/cond.dylan
<BR>    132     signal(cond);
<BR>    mindy&gt; </PRE>
</CODE>
<P>The first line tells you about the new current frame, which is a call to the <B>error</B> function.  For a function written in Dylan, as opposed to a built-in function, the debugger tries to show the line of source code associated with the current frame.  If the debugger could not find the source file, it still prints the line number from the source file.
<P>While moving down the stack, you might have expected to see a call to the <B>signal</B> function before seeing a call to the <B>error</B> function.  This does not happen because <B>signal</B> tail calls <B>invoke-debugger</B>.  When a function tail calls another function, the callee reuses the current stack frame of the caller.
<P>In addition to the up and down commands, you can move to a specified stack frame using the <A NAME="I7"></A>frame command.  The debugger numbers stack frames starting at zero at the top of the stack.  Currently, the debugger does not print frame numbers when it prints frame information, so moving with the frame command is only useful as a rough thumb bar.  The following is an example of using this command to go to the top of the stack:
<CODE>
<PRE>    mindy&gt; frame 0
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x1023fa91})
<BR>    mindy&gt; </PRE>
</CODE>
<P>If you use the frame command without supplying a frame number, the command prints the current frame's information.  This is useful if the description of the current frame has scrolled off the screen, and you want to see it again.
<P>You can view the entire stack by using the <A NAME="I8"></A>backtrace command.  The current frame stays the same, but the backtrace command always shows the entire stack from the top to the bottom.  The following is example output from this command:
<CODE>
<PRE>    mindy&gt; backtrace
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x1023fa91})
<BR>    fp 0x10034078: error({&lt;simple-error&gt; 0x1023fa91}, #[], #()) \
<BR>    [/afs/cs.cmu.edu/project/gwydion/mindy/src/runtime/cond.dylan, line 132]
<BR>    fp 0x10034058: main()
<BR>    mindy&gt; </PRE>
</CODE>
<BR>
<A NAME="E8E21"></A>
<H2><B>3. </B><A NAME="I9"></A><B>Examining Variables</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>The <A NAME="I10"></A>locals command prints the value for every local variable in the function associated with the current frame.  If you were at the frame for the <B>error</B> call in the previous example, using the locals command would look like the following:
<CODE>
<PRE>    mindy&gt; locals
<BR>    noise: #[]
<BR>    cond: {&lt;simple-error&gt; 0x1023fa91}
<BR>    mindy&gt; </PRE>
</CODE>
<P>You can use the <A NAME="I11"></A>print command to print a specific local variable.  The following is an example of printing the <B>cond</B> variable shown in the previous sample output:
<CODE>
<PRE>    mindy&gt; print cond
<BR>    $0={&lt;simple-error&gt; 0x1023fa91}
<BR>    mindy&gt; </PRE>
</CODE>
<P>The print command can also print the value of global variables:
<CODE>
<PRE>    mindy&gt; print size
<BR>    $1={&lt;generic-function&gt; size}
<BR>    mindy&gt; </PRE>
</CODE>
<P>For information on the labels the debugger assigns to values (that is, the $N identifications), see Section <I>Debugger Variables</I>.
<P>If the debugger does not find a local variable with the name you supplied, the debugger looks for a global variable by that name in the current library and module.  For more information about libraries and modules, see Section <I>Libraries and </I><I>Modules</I>.  
<P>You can refer to global variables in libraries and modules that are not the current library and module by prefixing variable names with module and/or library names. We support a <A NAME="I12"></A>colon notation that only works in the Mindy debugger and has nothing to do with legal Dylan syntax. For example, foo:bar:baz refers to the baz variable in the bar module of the foo library. There must not be any whitespace anywhere in the <I>identifier</I>. To refer to a variable in the current library but in a module that is not the current module, use the form quux:splat, which refers to the splat variable in the quux module.
<P>For more information about the print command, see Section <I>Evaluating Expressions</I>.
<BR>
<A NAME="E8E22"></A>
<H2><B>4. </B><B>Libraries and Modules</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>When evaluating expressions, the debugger uses the <I>current library</I> and <I>current module</I>.  When the debugger starts up, it guesses at what library and module to make current.  If you want to access a global variable from another module or library, you first make another module or library be the current one with the <A NAME="I13"></A>library or <A NAME="I14"></A>module command.  If you invoke the library command without an argument, it lists the available libraries and tells you which one is the current one.  If you invoke the library command with an argument, the debugger makes that library be the current library. In the same way, the module command either lists the modules of the current library, or it selects another module be the current module.  The following are examples of using the library command:
<CODE>
<PRE>    mindy&gt; library
<BR>    Dylan-User
<BR>    Dylan
<BR>
<BR>    Current library is Dylan
<BR>    mindy&gt; library dylan-user
<BR>    mindy&gt; </PRE>
</CODE>
<P>The following is an example of using the module command after having just switched to the Dylan-user library:
<CODE>
<PRE>    mindy&gt; module
<BR>       Dylan-User
<BR>     i File-Descriptors
<BR>     i Threads
<BR>     i Extensions
<BR>     i System
<BR>     i Dylan
<BR>
<BR>    The current module is Dylan-User
<BR>    mindy&gt; </PRE>
</CODE>
<P>The i in the second column indicates that those modules are being imported into the Dylan-user library as opposed to being defined there.  The module command also indicates which modules are exported from the current library. For example, if you were to switch to the Dylan library, the module command would produce the following output:
<CODE>
<PRE>    mindy&gt; library dylan
<BR>    mindy&gt; module
<BR>       Dylan-User
<BR>     x  File-Descriptors
<BR>     x  Threads
<BR>        Builtin-Stuff
<BR>     x  Extensions
<BR>     x  System
<BR>     x  Dylan
<BR>
<BR>    The current module is Dylan-User
<BR>    mindy&gt; </PRE>
</CODE>
<P>The x in the first column indicates that those modules are exported. There were no xs in the listing of modules in the Dylan-user library because no modules are exported from the Dylan-user library.  There were no is in the listing of modules for the Dylan library because the Dylan library does not import any modules.
<P>Whenever you change libraries with the library command, the debugger resets the current module to the Dylan-user module.  This is because the debugger needs to make a module current in the new library, and every library has a Dylan-user module.
<BR>
<A NAME="E8E23"></A>
<H2><B>5. </B><A NAME="I15"></A><B>Evaluating Expressions</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>The print command can evaluate simple expressions and print their results. The following is an example:
<CODE>
<PRE>    mindy&gt; print list(1, 2, 3)
<BR>    $2=#(1, 2, 3)
<BR>    mindy&gt; print vector(4, 5, 6)
<BR>    $3=#[4, 5, 6]
<BR>    mindy&gt;</PRE>
</CODE>
<P>The print command evaluates the variable list and then invokes that function with the arguments 1, 2, and 3.  The debugger labels values printed with a dollar sign and a number, and you can use these labels in later expressions. For more information on these, see Section <I>Debugger Variables</I>.
<P>The expressions that the debugger accepts are limited.  An expression can be one of the following:
<UL>
<LI>One of the following literals:
</UL>
<P><B>&#149; </B><B> </B>decimal number (47)
<P><B>&#149; </B><B> </B>keyword (foo:)
<P><B>&#149; </B><B> </B>string (&quot;foo&quot;)
<P><B>&#149; </B><B> </B>#t
<P><B>&#149; </B><B> </B>#f
<UL>
<LI>A variable name.
<LI>A debugger variable (for example, $5).
<LI>A function call (for example, foo(a, b) and bar(c, quux: 3)). Note that dot notation (object.slot) and infix operators (x + y) are not supported.
<LI>The address, in hexidecimal (C format, not Dylan), of a valid dylan object (for example, 0x102050b1).  Note: use this feature with care, as a mistyped address can cause Mindy to dump core.
</UL>
<P>If the expression results in multiple values, all the values are printed on a single line:
<CODE>
<PRE>    mindy&gt; print values(1, 2, 3)
<BR>    $4=1, $5=2, $6=3</PRE>
</CODE>
<P>If an error occurs while the debugger is evaluating the expression, it prints the error message, aborts the print command, and returns to the debugger prompt.  The following is an example of this situation:
<CODE>
<PRE>    mindy&gt; print error(&quot;oops&quot;)
<BR>    invocation failed:
<BR>      oops
<BR>    mindy&gt; </PRE>
</CODE>
<P>The <A NAME="I16"></A>call command is like the print command, but the call command does not handle errors by aborting.  When you use the call command, and the expression causes an error, the debugger returns to its prompt, but any stack frames that were created due to the call command are now visible for inspection.  The following is an example of using the call command:
<CODE>
<PRE>    mindy&gt; call error(&quot;oops&quot;)
<BR>
<BR>    oops
<BR>
<BR>    thread [0] D   main
<BR>    fp 0x100341f4: invoke-debugger({&lt;simple-error&gt; 0x102456b1})
<BR>    mindy&gt; </PRE>
</CODE>
<P>The print and call commands can also evaluate multiple, comma-separated expressions:
<CODE>
<PRE>    mindy&gt; print 1, 2, 3
<BR>    $7=1
<BR>    $8=2
<BR>    $9=3
<BR>    mindy&gt; </PRE>
</CODE>
<BR>
<A NAME="E8E24"></A>
<H2><B>6. </B><A NAME="I17"></A><B>Debugger Variables</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>The print or call commands label every value printed, and these labels identify <I>debugger variables</I>.  You can use these identifers in later expressions to refer to previously computed values.  The following is an example:
<CODE>
<PRE>    <A NAME="I18"></A>mindy&gt; p list(1, 2, 3)
<BR>    $4=#(1, 2, 3)
<BR>    mindy&gt; p second($4)
<BR>    $5=2
<BR>    mindy&gt; </PRE>
</CODE>
<P>The notation <A NAME="I19"></A>$-N provides a dynamic alternative to identifying debugger variables.  This notation refers to previously printed values by using N as a count from the most recently printed value to the least recently printed. The counting begins at one.
<CODE>
<PRE>    mindy&gt; print a:, b:, c:, d:
<BR>    $12=a
<BR>    $13=b
<BR>    $14=c
<BR>    $15=d
<BR>    mindy&gt; print $-1, $-2, $-3, $-4
<BR>    $16=d
<BR>    $17=c
<BR>    $18=b
<BR>    $19=a
<BR>    mindy&gt; </PRE>
</CODE>
<P>You can use <A NAME="I20"></A>$ as a shorthand for $-1, and <A NAME="I21"></A>$$ for $-2:
<CODE>
<PRE>    mindy&gt; p 2
<BR>    $20=2
<BR>    mindy&gt; p list($, 4)
<BR>    $21=#(2, 4)
<BR>    mindy&gt; p list($$, 6)
<BR>    $22=#(2, 6)
<BR>    mindy&gt; </PRE>
</CODE>
<P>Mindy keeps references to all debugger variables to prevent them from being garbage collected.  If you no longer care about previously printed values, you might want to use the <A NAME="I22"></A>flush command to get rid of them:
<CODE>
<PRE>    mindy&gt; flush
<BR>    Flushed all debugger variables.
<BR>    mindy&gt; p $0
<BR>    invocation failed:
<BR>    No debug variable $0
<BR>    mindy&gt; p list(a:, b:, c:)
<BR>    $0=#(a, b, c)
<BR>    mindy&gt; </PRE>
</CODE>
<P>You can use <A NAME="I23"></A>$aN notation to refer to the arguments passed to the function call associated with the current stack frame.  N is the argument number, counting from zero.  The following is an example:
<CODE>
<PRE>    mindy&gt; frame
<BR>    fp 0x10034078: error({&lt;simple-error&gt; 0x1023fa91}, #[], #())
<BR>    /afs/cs.cmu.edu/project/gwydion/mindy/src/runtime/cond.dylan
<BR>    132     signal(cond);
<BR>    mindy&gt; p $a0
<BR>    $1={&lt;simple-error&gt; 0x1023fa91}
<BR>    mindy&gt; p $a1
<BR>    $2=#[]
<BR>    mindy&gt; p $a2
<BR>    $3=#()
<BR>    mindy&gt; </PRE>
</CODE>
<P>The $aN notation does not identify a debugger variable, and the debugger does not have to create storage for these values because they are already stored on the call stack.  The flush command has no effect on argument values.
<BR>
<A NAME="E8E25"></A>
<H2><B>7. </B><A NAME="I24"></A><B>Restarts and Returning</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>This section discusses invoking Dylan restart handlers and returning values for conditions whose recovery protocols allow returning.  If you do not know what these are, see the <I>Dylan Reference Manual</I>.
<P>The debugger has commands that allow you to try to continue executing your program.  The most common way to continue execution is to invoke a Dylan restart.  To either list the available restarts or invoke a restart, you use the <A NAME="I25"></A>restart command:
<CODE>
<PRE>    mindy&gt; call cerror(&quot;go on&quot;, &quot;oops&quot;)
<BR>
<BR>    oops
<BR>
<BR>    thread [0] D   main
<BR>    fp 0x1003428c: invoke-debugger({&lt;simple-error&gt; 0x10245361})
<BR>    mindy&gt; restart
<BR>    0 [{class &lt;simple-restart&gt;}]: go on
<BR>    1 [{class &lt;abort&gt;}]: Blow off call
<BR>    mindy&gt; restart 0
<BR>    $0=#f
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x1023fa91})
<BR>    mindy&gt; </PRE>
</CODE>
<P>In this example, the restart command lists two restarts.  The <B>cerror</B> function establishes the &quot;go on&quot; restart (numbered 0).  The call command establishes the &quot;Blow off call&quot; restart (numberd 1).  The restart 0 command caused <B>cerror </B>to return #f, which the call command printed.
<P>The <A NAME="I26"></A>abort command invokes the first restart that handles <B>&lt;abort&gt;</B> restarts. The following is an example of this command:
<CODE>
<PRE>    mindy&gt; call error(&quot;oops&quot;)
<BR>
<BR>    oops
<BR>
<BR>    thread [0] D   main
<BR>    fp 0x100341fc: invoke-debugger({&lt;simple-error&gt; 0x10241d49})
<BR>    mindy&gt; abort
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x1023fa91})
<BR>    mindy&gt; </PRE>
</CODE>
<P>If Mindy entered the debugger due to a condition that allows returning as part of its recovery protocol, then you can use the return command.  For example, consider an <B>&lt;ignorable-error&gt;</B> condition that is a subclass of <B>&lt;error&gt;</B> and that allows returning as part of its recovery protocol.  The following example shows returning from the signalling of this condition:
<CODE>
<PRE>    mindy&gt; call signal(make(&lt;ignorable-error&gt;))
<BR>
<BR>    {&lt;ignorable-error&gt; 0x10247759}
<BR>
<BR>    thread [0] D   main
<BR>    fp 0x100341d4: invoke-debugger({&lt;ignorable-error&gt; 0x10247759})
<BR>    mindy&gt; restart
<BR>    0 [{class &lt;abort&gt;}]: Blow off call
<BR>
<BR>    Returning is allowed:
<BR>      ignore it.
<BR>    mindy&gt; return
<BR>    $0=#f
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x10244831})
<BR>    mindy&gt; </PRE>
</CODE>
<BR>
<A NAME="E8E26"></A>
<H2><B>8. </B><A NAME="I27"></A><B>Interrupting and Single Stepping</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>Sometimes it is useful to interrupt your program to see where it is currently executing.  Consider the following program as an example:
<CODE>
<PRE>    module: Dylan-User
<BR>
<BR>    define method main (#rest noise)
<BR>      foo(#t);
<BR>    end;
<BR>
<BR>    define method foo (x)
<BR>      if (x)
<BR>        foo(#f);
<BR>      else
<BR>        foo(#t);
<BR>      end;
<BR>    end;</PRE>
</CODE>
<P>If you were to run this program and then interrupt it, you would see output similar to the following:
<CODE>
<PRE>    ^C
<BR>    Interrupted
<BR>    thread [0] R   main
<BR>    fp 0x10034060: foo(#f, #())
<BR>    foo.dylan
<BR>    8       if (x)
<BR>    mindy&gt; </PRE>
</CODE>
<P>After interrupting the program you have the full debugger at your disposal, as if an error had occurred.  Additionally, you can use the <A NAME="I28"></A>continue command to resume execution:
<CODE>
<PRE>    mindy&gt; continue</PRE>
</CODE>
<P>You can also use the <A NAME="I29"></A>step command to advance line by line through your program.  When stepping, if the debugger encounters a function call, it descends into that function and steps line by line.  The following is an example:
<CODE>
<PRE>    ^C
<BR>    Interrupted
<BR>    thread [0] R   main
<BR>    fp 0x10034060: foo(#f, #())
<BR>    foo.dylan
<BR>    8       if (x)
<BR>    mindy&gt; step
<BR>    foo.dylan
<BR>    11      foo(#t)
<BR>    mindy&gt; step
<BR>    foo.dylan
<BR>    8       if (x)
<BR>    mindy&gt; step
<BR>    foo.dylan
<BR>    9       foo(#f)
<BR>    mindy&gt; step
<BR>    foo.dylan
<BR>    8       if (x)
<BR>    mindy&gt; </PRE>
</CODE>
<P>The next command is the same as the step command, but the next command tries to avoid descending into function calls.
<BR>
<A NAME="E8E27"></A>
<H2><B>9. </B><B>Breakpoints</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>The easiest way to insert a breakpoint into a Mindy program is to insert a call to <B>break</B> into the program text, recompile the program, and rerun it.<B>break</B> is exported from the Extensions module of the Dylan library.
<P>The debugger also has a primitive facility for setting breakpoints in methods written in Dylan, as opposed to built-in methods.  The <A NAME="I30"></A>breakpoint command takes two arguments, a reference to a method in which to install the breakpoint, and the line number at which to install the breakpoint.  For example, consider the following program:
<CODE>
<PRE>    module: dylan-user
<BR>
<BR>    define constant foo =
<BR>      method ()
<BR>        puts(&quot;this is a test\n&quot;);
<BR>        puts(&quot;of breakpoints.\n&quot;);
<BR>        #f;
<BR>      end;</PRE>
</CODE>
<P>If you were to put a breakpoint at line 6 (the second puts), Mindy would produce output similar to the following:
<CODE>
<PRE>    mindy&gt; break foo, 6
<BR>    breakpoint 1 installed in {anonymous &lt;byte-method&gt; 0x10243d31\
<BR>    #()} at line 6 (pc 47)
<BR>    mindy&gt; call foo()
<BR>    this is a test
<BR>    Breakpoint
<BR>    thread [0] R   main
<BR>    fp 0x100341dc: {anonymous &lt;byte-method&gt; 0x10243d31 #()}(#())
<BR>    foo.dylan
<BR>    6       puts(&quot;of breakpoints.\n&quot;);
<BR>    mindy&gt; </PRE>
</CODE>
<P>The continue and step commands can be used to continue execution (see Section <I>Interrupting and Single Stepping</I>):
<CODE>
<PRE>    mindy&gt; step
<BR>    of breakpoints.
<BR>    foo.dylan
<BR>    7       #f;
<BR>    mindy&gt; c
<BR>    $0=#f
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x10243e49})
<BR>    mindy&gt; </PRE>
</CODE>
<P>The breakpoint command evaluates its first argument, so you can use an arbitrary expression for the function.  For example, you could use <B>find-method</B> to extract a specific method from a generic function and insert a breakpoint in that method:
<CODE>
<PRE>    mindy&gt; br find-method(size, list(&lt;table&gt;)), 886
<BR>    breakpoint 1 installed in {&lt;byte-method&gt; size #({class &lt;table&gt;})}\
<BR>    at line 886 (pc 35)
<BR>    mindy&gt;</PRE>
</CODE>
<P>The breakpoint command with no arguments lists the currently installed breakpoints:
<CODE>
<PRE>    mindy&gt; breakpoint
<BR>    id  where
<BR>     1  pc 47 in {&lt;component&gt; 0x10204ea9}
<BR>    mindy&gt; </PRE>
</CODE>
<P>The <A NAME="I31"></A>delete N command removes a breakpoint, where N is the breakpoint ID reported in the breakpoint listing.
<P>Sometimes the Mindy compiler has to split a single top level form into multiple methods.  When this happens, the debugger cannot always figure out where to insert your breakpoint.  Consider the following program:
<CODE>
<PRE>    module: dylan-user
<BR>
<BR>    define constant foo =
<BR>      method ()
<BR>        block (exit)
<BR>          puts(&quot;this is a test\n&quot;);
<BR>          puts(&quot;of breakpoints.\n&quot;);
<BR>          #f;
<BR>        end;
<BR>      end;</PRE>
</CODE>
<P>When this program is compiled, the compiler has to put the contents of the block in a seperate method.  Because of this, if you were to try to insert a breakpoint at line 7 it would not work:
<CODE>
<PRE>    mindy&gt; break foo, 7
<BR>    {anonymous &lt;byte-method&gt; 0x10243f59 #()} does not span line number 7
<BR>    mindy&gt;</PRE>
</CODE>
<P>To insert a breakpoint into this method, you need to use the <A NAME="I32"></A>disassemble command.  It disassembles a method and all Mindy-generated methods that might be associated with that method.  For example:
<CODE>
<PRE>    mindy&gt; disassemble foo
<BR>    anonymous component, from &quot;foo.dylan&quot;
<BR>    5           block (exit)
<BR>        47: b0              push    function catch
<BR>        48: 21              push    const(1)        {&lt;method-info&gt; 0x10205149}
<BR>        49: b2              push    function list
<BR>        50: a3              push    value &lt;object&gt;
<BR>        51: 91              call    nargs = 1, for single
<BR>        52: 0e              push    #()
<BR>        53: 10              push    #t
<BR>        54: 06              make-method
<BR>        55: 71              call    nargs = 1, tail
<BR>    {&lt;method-info&gt; 0x10205149}, anonymous component, from &quot;foo.dylan&quot;
<BR>    5           block (exit)
<BR>        51: 31              push    arg(1)
<BR>        52: 20              push    const(0)        {&lt;method-info&gt; 0x102050b1}
<BR>        53: b1              push    function list
<BR>        54: 90              call    nargs = 0, for single
<BR>        55: 0e              push    #()
<BR>        56: 10              push    #t
<BR>        57: 06              make-method
<BR>        58: 60              pop     local(0)
<BR>    6             puts(&quot;this is a test\n&quot;);
<BR>        59: b2              push    function puts
<BR>        60: 23              push    const(3)        &quot;this is a test\n&quot;
<BR>        61: 81 00           call    nargs = 1, for 0
<BR>    7             puts(&quot;of breakpoints.\n&quot;);
<BR>        63: b2              push    function puts
<BR>        64: 24              push    const(4)        &quot;of breakpoints.\n&quot;
<BR>        65: 81 00           call    nargs = 1, for 0
<BR>    8             #f;
<BR>        67: 11              push    #f
<BR>        68: 02              return single
<BR>
<BR>    {&lt;method-info&gt; 0x102050b1}, exit component, from &quot;foo.dylan&quot;
<BR>    5           block (exit)
<BR>        39: b0              push    function apply
<BR>        40: a1              push    value throw
<BR>        41: 30              push    arg(0)
<BR>        42: 32              push    arg(2)
<BR>        43: 73              call    nargs = 3, tail
<BR>        mindy&gt; </PRE>
</CODE>
<P>As you can see, the function <B>foo</B> has been split into three methods.  The first one corresponds to the part of <B>foo</B> that is outside the block.  The second method corresponds to the code inside the block.  And the third one corresponds to the <B>exit</B> function established by the block.  Look for the second method which spans line 7.  The following shows how to install the breakpoint:
<CODE>
<PRE>    mindy&gt; br 0x10205149, 7
<BR>    breakpoint 1 installed in {&lt;method-info&gt; 0x10205149} at line 7 (pc 63)
<BR>    mindy&gt; call foo()
<BR>    this is a test
<BR>    Breakpoint
<BR>    thread [0] R   main
<BR>    fp 0x100341f8: {anonymous &lt;byte-method&gt; 0x10245f41 #({class &lt;object&gt;})}\
<BR>    ({&lt;catch&gt; 0x10245f81}, #())
<BR>    foo.dylan
<BR>    7       puts(&quot;of breakpoints.\n&quot;);
<BR>    mindy&gt; c
<BR>    of breakpoints.
<BR>    $0=#f
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x10244071})
<BR>    mindy&gt; </PRE>
</CODE>
<BR>
<A NAME="E8E28"></A>
<H2><B>10. </B><B>Threads</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>Normally, there is only one thread of execution, in which case you won't need any of the commands in this section.  When you debug a multi-threaded program, these commands become very useful.  The <A NAME="I33"></A>thread command either lists the available threads or switches between them, depending on how you invoke it.  For example:
<CODE>
<PRE>    mindy&gt; p spawn-thread(foo:, curry(break, &quot;Thread foo&quot;))
<BR>    $0={&lt;thread&gt; 0x10243f49}
<BR>    mindy&gt; p spawn-thread(bar:, curry(break, &quot;Thread bar&quot;))
<BR>    $1={&lt;thread&gt; 0x10246f19}
<BR>    mindy&gt; thread
<BR>    c [0] D   main
<BR>      [1] R   foo
<BR>      [2] R   bar
<BR>    mindy&gt; </PRE>
</CODE>
<P>In this example, the thread command lists three threads: the main (or original) thread and the two threads you just created.  The c in the first column indicates which thread the debugger is currently examining.  The [N] indicates the thread ID for each thread.  The D and R designations indicate the status of each thread.  The main, foo, and bar labels are the debug-names passed as the first argument to <B>spawn-thread</B>.
<P>The different thread status codes are as follows:
<CODE>
<PRE>    STATUS     MEANING
<BR>       D       current thread the debugger is examining
<BR>       R       running/runable
<BR>       S       suspended
<BR>       B       blocked on a lock
<BR>       W       waiting for an event</PRE>
</CODE>
<P>Giving the thread command an argument causes the debugger to examine another thread.  You can designate threads with either its numeric ID or the debug-name passed to <B>spawn-thread</B>:
<CODE>
<PRE>    mindy&gt; thread foo
<BR>    thread [1] R   foo
<BR>    fp 0x102550bc: {anonymous &lt;byte-method&gt; 0x102443d9 #({class &lt;\
<BR>    object&gt;})}({&lt;catch&gt; 0x10244421}, #(), {&lt;value-cell&gt; 0x1024436\
<BR>    9}, {&lt;breakpoint&gt; 0x102441e1})
<BR>    /afs/cs.cmu.edu/project/gwydion/mindy/src/runtime/cond.dylan
<BR>    212     init-arguments: list(format-string: &quot;Continue from break&quot;))
<BR>    mindy&gt; thread 0
<BR>    thread [0] D   main
<BR>    fp 0x10034090: invoke-debugger({&lt;simple-error&gt; 0x1023fa91})
<BR>    mindy&gt; </PRE>
</CODE>
<P>Sometimes it is useful to temporarily disable some threads while debugging other threads.  The <A NAME="I34"></A>disable &lt;thread-id-or-name&gt; command disables (suspends) the indicated thread, and the <A NAME="I35"></A>enable command allows a thread to run again:
<CODE>
<PRE>    mindy&gt; disable foo
<BR>    [1] S 1 foo
<BR>    mindy&gt; enable foo
<BR>    [1] R   foo
<BR>    mindy&gt;</PRE>
</CODE>
<P>In this example, the status of the foo thread changes from R (runnable) to S (suspended) when it is disabled.
<P>If you repeatedly use the disable command on the same thread, then the enable command must be used the same number of times to before the thread's status changes to R. The 1 after the S above is the number of times the thread foo has been disabled.
<P>When a thread is suspended, the continue and step commands do not advance the thread's execution.  The disable and enable commands can help you find thread synchronization problems by allowing you to explicitly control when each thread runs.
<P>Invoking the disable or enable command with no argument affects the current thread the debugger is examining.
<P>The kill &lt;thread-id-or-name&gt; command kills the indicated thread.
<BR>
<A NAME="E8E29"></A>
<H2><B>11. </B><B>Inspect and Xinspect</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>The <A NAME="I36"></A>inspect and <A NAME="I37"></A>xinspect commands can be used to interactively examine an object and related objects. The inspect command is a text-based interface to the Inspector facilities, while xinspect is a graphical interface. See <A HREF="#">the document </A><I>The </I><I>Mindy Object Inspector</I> for information on using the Inspector.
<BR>
<A NAME="E8E30"></A>
<H2><B>12. </B><B>Miscellaneous Commands</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>The <A NAME="I38"></A>help command prints a one line summary of all the debugger commands.
<P>The <A NAME="I39"></A>quit command causes Mindy to exit without executing any of the <B>on-exit</B> hooks.  If you want the <B>on-exit</B> hooks to run, you should invoke the <B>exit</B> function with the print command:
<CODE>
<PRE>    mindy&gt; print exit()</PRE>
</CODE>
<P>The <A NAME="I40"></A>tron command turns on an internal trace facility that prints the arguments and results for every function call.  The <A NAME="I41"></A>troff command turns this off.
<P>The <A NAME="I42"></A>error command repeats the error message for the condition that caused this thread to drop into the debugger.
<P>The <A NAME="I43"></A>gc command invokes the garbage collector.
<P>The <A NAME="I44"></A>describe command takes an expression as an argument and evaluates it. If the result is an instance of a class defined in Dylan, as opposed to a built-in class, then the debugger identifies the class, prints the slot names, and prints the slot values.  If the result of the expression is an instance of a built-in class, then the debugger prints the value and its class.  The describe command does not create or assign to debugger variables, but you can use debugger variables in the expression given to the command.  The following examples show the describe command:
<CODE>
<PRE>    mindy&gt; describe make
<BR>    {&lt;generic-function&gt; make} is an instance of {class &lt;generic-function&gt;}
<BR>
<BR>    mindy&gt; describe &quot;Testing&quot;
<BR>    &quot;Testing&quot; is an instance of {class &lt;byte-string&gt;}
<BR>
<BR>    mindy&gt; describe make(&lt;table&gt;)
<BR>    {&lt;object-table&gt; 0x10245d79} is an instance of {class &lt;object-table&gt;}
<BR>    and has the following slots:
<BR>    merged-hash-state-slot: {permanent hash state}
<BR>    shrink-to-slot: 100
<BR>    shrink-when-slot: 10
<BR>    expand-to-slot: 300
<BR>    expand-when-slot: 200
<BR>    bucket-states-slot: #[{permanent hash state}, {permanent hash state}, \
<BR>    {permanent hash state}, {permanent hash state}, {permanent hash state}]
<BR>    bucket-count-slot: 5
<BR>    bucket-array-slot: #[#(), #(), #(), #(), #()]
<BR>    item-count-slot: 0</PRE>
</CODE>
<BR>
<A NAME="E8E31"></A>
<H2><B>13. </B><B>Copyright and Terms Of Use</B></H2>
<P ALIGN=LEFT><IMG SRC="gmindy/navyl.gif" WIDTH = 750 HEIGHT = 9>
<P>Copyright (c) 1994, 1995, 1996, 1997 Carnegie Mellon University All rights reserved.  
<P>Use and copying of this software and preparation of derivative works based on this software are permitted, including commercial use, provided that the following conditions are observed:
<UL>
<LI>This copyright notice must be retained in full on any copies and on appropriate parts of any derivative works.
<LI>Documentation (paper or online) accompanying any system that incorporates this software, or any part of it, must acknowledge the contribution of the Gwydion Project at Carnegie Mellon University.
</UL>
<P>This software is made available <I>as is</I>.  Neither the authors nor Carnegie Mellon University make any warranty about the software, its performance, or its conformity to any specification.
<P>Bug reports, questions, comments, and suggestions should be sent by E-mail to the Internet address gwydion-bugs@cs.cmu.edu. 

<P>
<CENTER><TABLE BORDER=1 CELLSPACING=1 ><TR>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="mindy.htm#E28E1">Mindy Compiler</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="debug.htm#E28E2">Mindy Debugger</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="inspect.htm#E28E3">Mindy Object</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="EXTENS~1.htm#E28E4">Extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="streams.htm#E28E5">Streams Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="STANDA~1.htm#E28E6">Standard IO</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="print.htm#E28E7">Print Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="format.htm#E28E8">Format Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="melange.htm#E28E9">Melange Interface</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="dylan-tk.htm#E28E10">TK Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="COLLEC~1.htm#E28E11">Collection extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="TABLE-~1.htm#E28E12">Table Extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="STRING~1.htm#E28E13">String extensions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="REGULA~1.htm#E28E14">Regular Expressions</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="TRANSC~1.htm#E28E15">Transcendental Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="time.htm#E28E16">Time Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="random.htm#E28E17">Random Library</A></TD>
</FONT>
<TD VALIGN=top ><FONT SIZE="-1" ><A HREF="matrix.htm#E28E18">Matrix Library</A>
</TD></FONT>
</TR></TABLE>
</CENTER><P ALIGN=CENTER>
<A HREF="mindy.htm" TARGET="_self"><IMG SRC="gmindy/blrprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>
<A HREF="httoc.htm" TARGET="_self"><IMG SRC="gmindy/blrtoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>
<A HREF="htindex.htm" TARGET="_self"><IMG SRC="gmindy/blrindex.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Index"></A>
<A HREF="inspect.htm" TARGET="_self"><IMG SRC="gmindy/blrnext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>
<A HREF="http://legend.gwydion.cs.cmu.edu/gwydion" TARGET="_self"><IMG SRC="gmindy/blrhome.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="See Page"></A>

<P>
<ADDRESS>Copyright 1994, 1995, 1996, 1997 Carnegie Mellon University. All rights reserved.</ADDRESS>
<P><A HREF="MAILTO:gwydion-bugs@cs.cmu.edu">Send comments and bug reports to gwydion-bugs@cs.cmu.edu</A>
</BODY></HTML>
