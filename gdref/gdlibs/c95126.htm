<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>The Dylan Module</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="Gwydion Dylan Library Reference Guide"
HREF="book1.htm"><LINK
REL="UP"
TITLE="The Dylan Library and Gwydion Dylan Extensions"
HREF="c95.htm"><LINK
REL="PREVIOUS"
TITLE="Modules of the Dylan Library"
HREF="c95104.htm"><LINK
REL="NEXT"
TITLE="The Extensions Module"
HREF="c95175.htm"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Gwydion Dylan Library Reference Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c95104.htm"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. The Dylan Library and Gwydion Dylan Extensions</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c95175.htm"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="AEN126"
>The Dylan Module</A
></H1
><P
>Whenever possible, we have tried to keep the Dylan module
      pristine and unextended, prefering to add our extensions to
      separate modules or libraries. However, this is not always
      possible, particularly when it involves extending the behavior
      of a function or macro that is exported from the Dylan
      module. Currently, Gwydion compilers support these extensions to
      the Dylan module as described below:</P
><P
></P
><UL
><LI
><P
>Gwydion compilers support <TT
CLASS="LITERAL"
>keyed-by</TT
>
	  clauses in <TT
CLASS="LITERAL"
>for</TT
> statements.  The format of
	  such a clause is</P
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="PARAMETER"
><I
>var</I
></TT
> keyed-by <TT
CLASS="PARAMETER"
><I
>key</I
></TT
> in <TT
CLASS="PARAMETER"
><I
>collection</I
></TT
></PRE
><P
>The <TT
CLASS="PARAMETER"
><I
>var</I
></TT
> is bound to each
	  element in <TT
CLASS="PARAMETER"
><I
>collection</I
></TT
>, and
	  <TT
CLASS="PARAMETER"
><I
>key</I
></TT
> is bound to the element's key
	  value.</P
></LI
><LI
><P
>Gwydion compilers supports <TT
CLASS="LITERAL"
>using</TT
>
	  clauses in <TT
CLASS="LITERAL"
>for</TT
> statements.  The format of
	  such a clause is</P
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="PARAMETER"
><I
>var</I
></TT
> in <TT
CLASS="PARAMETER"
><I
>collection</I
></TT
> using <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
></PRE
><P
>The <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
> will be used
	  instead of
	  <TT
CLASS="FUNCTION"
><B
>forward-iteration-protocol</B
></TT
>. The
	  <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
> argument must be a variable
	  name, not an expression. These <TT
CLASS="LITERAL"
>using</TT
>
	  clauses may be used together with
	  <TT
CLASS="LITERAL"
>keyed-by</TT
>:</P
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="PARAMETER"
><I
>var</I
></TT
> keyed-by <TT
CLASS="PARAMETER"
><I
>key</I
></TT
> in <TT
CLASS="PARAMETER"
><I
>collection</I
></TT
> using <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
></PRE
></LI
><LI
><P
>Gwydion compilers have an additional type of top level
	  definition, <TT
CLASS="LITERAL"
>define function</TT
>, which
	  creates a constant binding in the current module and
	  initializes it to a new function. The usage of
	  <TT
CLASS="LITERAL"
>define function</TT
> usage is similar to that
	  of <TT
CLASS="LITERAL"
>define method</TT
>. The following is an
	  example:</P
><PRE
CLASS="PROGRAMLISTING"
>define function cube (x)
  x * x * x;
end function cube;</PRE
><P
>A similar result might be had by writing</P
><PRE
CLASS="PROGRAMLISTING"
>define constant cube = method (x)
                         x * x * x;
                       end method;</PRE
><P
>or</P
><PRE
CLASS="PROGRAMLISTING"
>define method cube (x)
  x * x * x;
end method cube;</PRE
></LI
><LI
><P
>Gwydion compilers supports subclass specializers via
	  the <TT
CLASS="FUNCTION"
><B
>limited</B
></TT
> function.  A subclass
	  specializer causes a method to be invoked whenever the
	  generic function was called on a value that is the specified
	  class or any subclass of the specified class.  The method is
	  never invoked on a value that is an instance (direct or
	  indirect) of the specified class, only when the value is a
	  subclass of the specified class.  The following is an
	  example:</P
><PRE
CLASS="PROGRAMLISTING"
>define method make
    (result-class :: limited(&#60;class&#62;, subclass-of: &#60;my-class&#62;));
  let x = next-method();
  do-special-logging-or-something(x);
  x;
end method;</PRE
></LI
></UL
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c95104.htm"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c95175.htm"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Modules of the Dylan Library</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c95.htm"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The Extensions Module</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>