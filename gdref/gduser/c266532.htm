<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Function Clauses</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="Gwydion Dylan User's Guide"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Using the Melange Interface Generator"
HREF="c266.htm"><LINK
REL="PREVIOUS"
TITLE="Other File Options"
HREF="c266524.htm"><LINK
REL="NEXT"
TITLE="Struct and Union Clauses"
HREF="c266580.htm"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Gwydion Dylan User's Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c266524.htm"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Using the Melange Interface Generator</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c266580.htm"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="MELANGE-FUNCTION-CLASSES"
>Function Clauses</A
></H1
><P
>Imported functions can be easily invoked, in almost every
      case, without any additional declarations. However, by exerting
      explicit control over argument handling, the interfaces to some
      functions may be made cleaner. This control is exerted via
      function clauses. The primary purpose of these clauses is to
      specify additional type information for specific parameters or
      to specify alternative argument passing conventions. For
      example, if we had two alternate "read-integers" functions with
      the following declarations:</P
><PRE
CLASS="PROGRAMLISTING"
>int ReadInts1(int **VectorPtr);  /* result is a count of integers */
int *ReadInts2(int *Count);      /* result is a vector of  integers */</PRE
><P
>we might use the following interface definition:</P
><PRE
CLASS="PROGRAMLISTING"
>define interface
   #include "readints.h",
      rename: {"int *" =&#62; int-vector};
   function "ReadInts1"
      output-argument: 1;
   function "ReadInts2" =&#62; Read-Integers-Vector,
   output-argument: Count;
end interface;</PRE
><P
>This would produce two functions, both of which take 0
      arguments but return two values. The first would return an
      &#60;integer&#62; following by an "&#60;int-vector&#62;", while the
      second would return the &#60;int-vector&#62; first and the
      &#60;integer&#62; second.</P
><PRE
CLASS="PROGRAMLISTING"
>let (count :: &#60;integer&#62;, values :: &#60;int-vector&#62;)
   = Read-Ints1();
let (values :: &#60;int-vector&#62;, count :: &#60;integer&#62;) 
   = Read-Integers-Vector();</PRE
><P
>The function clause consists of a function name (which is
      a string), an optional renaming (as illustrated above), and an
      optional sequence of "options". The options include the
      following:</P
><P
></P
><DL
><DT
>seal:</DT
><DD
><P
>specifies whether the resulting method should be
            sealed. Possible values are sealed or open, and the
            default is taken from the value specified in the initial
            file clause. (The "default default" is sealed.)</P
></DD
><DT
>equate-result:</DT
><DD
><P
>overrides the default interpretation of the result
            type. The named type is assumed to be fully
            defined.</P
></DD
><DT
>map-result:</DT
><DD
><P
>specifies that "import-value" should be called to map the
            result value to the named type.</P
></DD
><DT
>ignore-result:</DT
><DD
><P
>specifies that the functions result value should be
            ignored, just as if the function had been declared
            "void". Although you may specify any boolean literal, the
            only meaningful value is #t.</P
></DD
><DT
>equate-argument:</DT
><DD
><P
>overrides the default interpretation of some
            argument's type. The argument may be specified by name or
            by position.</P
></DD
><DT
>map-argument:</DT
><DD
><P
>specifies that "export-value" should be called to
            map the given argument into the named type. Again, the
            argument may be specified by position or by name.</P
></DD
><DT
>input-argument:</DT
><DD
><P
>indicates that the specified argument should be
            passed by value. This is the default.</P
></DD
><DT
>output-argument:</DT
><DD
><P
>indicates that the specified argument should be be
            treated as a return value rather than a "parameter". The
            effect is to declare that the C parameter will be passed
            by reference and that the reference variable need not be
            initialized to any object.  This option assumes that the C
            parameter will have been declared as a "pointer" type, and
            will strip one "*" off of the argument type. Thus, if the
            parameter declaration specifies "int **", the actual value
            returned will have the Dylan type corresponding to "int
            *".</P
></DD
><DT
>input-output-argument:</DT
><DD
><P
>indicates that the specified argument should be
            considered both an input argument and that its
            (potentially modified) value should be returned as an
            additional result value. The effect is similar to that of
            "output-argument" except that the reference variable will
            be initialized with the argument value.</P
></DD
></DL
><P
>The following (nonsensical) example demonstrates all of
      the options, as they might be applied to the functions:</P
><PRE
CLASS="PROGRAMLISTING"
>extern struct object *bar(int first, int *second,struct object **third);
extern baz(char first, struct object *second);

define interface
   #include "demo.h";
   function "bar",
      seal: open,
      equate-result: &#60;object&#62;,
      map-result: &#60;bar-object&#62;,
      input-argument: first,   // passed normally
      output-argument: 2,      // nothing passed in, second result value
            // will be &#60;integer&#62;
      input-output-argument: third;   // passed in as second argument, 
            // returned as third result
   function "baz" =&#62; arbitrary-function-name,
      seal: sealed,      // default
      ignore-result: #t,
      equate-argument: {second =&#62; &#60;object&#62;},
      map-argument: {2 =&#62; &#60;baz-object&#62;};
end interface;</PRE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c266524.htm"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c266580.htm"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Other File Options</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c266.htm"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Struct and Union Clauses</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>