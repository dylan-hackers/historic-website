<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Specifying Object Names</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="Gwydion Dylan User's Guide"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Using the Melange Interface Generator"
HREF="c266.htm"><LINK
REL="PREVIOUS"
TITLE="Importing Header Files"
HREF="c266348.htm"><LINK
REL="NEXT"
TITLE="Type Definitions"
HREF="c266453.htm"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Gwydion Dylan User's Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c266348.htm"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Using the Melange Interface Generator</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c266453.htm"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="MELANGE-SPECIFYING-OBJECT-NAMES"
>Specifying Object Names</A
></H1
><P
>Because naming conventions differ between C and Dylan,
      Melange attempts to translate the names specified in C
      declarations into a form more appropriate to Dylan. This
      involves</P
><P
></P
><UL
><LI
><P
>Adding angle brackets around type names.</P
></LI
><LI
><P
>Adding dollar signs at the beginning of constant
	  names.</P
></LI
><LI
><P
>Translating (non-initial) underlines into hyphens.</P
></LI
><LI
><P
>Adding "struct-name$" prefixes to slot accessors.</P
></LI
></UL
><P
>In many cases, this default behavior will be precisely
      what you want. However, Melange provides mechanisms for
      specifying different translations for some or all of the
      declarations.</P
><H2
><A
NAME="MELANGE-MAPPING-FUNCTIONS"
>Mapping functions</A
></H2
><P
>The translations described above are provided by calls
        to a built-in "name mapping function" named
        "minimal-name-mapping-with-structure-prefix". You may specify
        other mapping functions via a "name-mapper:" option. Our
        example interface might then look like this:</P
><PRE
CLASS="PROGRAMLISTING"
>define interface
   #include "gc.h",
      object-file: "/usr/lib/mindy/gc.o",
      name-mapper: c-to-dylan;
end interface;</PRE
><DIV
CLASS="TABLE"
><P
><B
><A
NAME="MELANGE-NAME-MAPPING"
>Table 5-1. Standard Name Mapping Functions</A
></B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>minimal-name-mapping-with-structure-prefix</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Provides the translations described above.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>minimal-name-mapping</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Same as above, but excludes the "struct-name$"
	        prefixes.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>c-to-dylan</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Like minimal-name-mapping, but:</P
><P
></P
><UL
><LI
><P
>Adds hyphens to reinforce "CaseBased" word
                      separation.</P
></LI
><LI
><P
>Adds "get-" prefixes to slot accessors.</P
></LI
></UL
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>identity-name-mapping</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Does no translation.</TD
></TR
></TABLE
></DIV
><P
><A
HREF="c266364.htm#MELANGE-NAME-MAPPING"
>Table 5-1</A
> describes the four
        standard mapping functions that are provided by Melange.
        Users may link new mapping functions into Melange. In the
        Mindy implementation, this is done as follows:</P
><DIV
CLASS="PROCEDURE"
><OL
TYPE="1"
><LI
><P
>Create a new module which imports module "name-mappers"
            from library "c-parse".</P
></LI
><LI
><P
>Define methods on the "map-name" generic function which
            accepts the following parameters:</P
><P
></P
><DL
><DT
>mapper</DT
><DD
><P
>a &#60;symbol&#62; which is typically specialized by a
                  singleton to select a specific name mapper method.</P
></DD
><DT
>category</DT
><DD
><P
>a &#60;symbol&#62; which will always be one of:
		  #"type", #"constant", #"variable", or
		  #"function".</P
></DD
><DT
>prefix</DT
><DD
><P
>a &#60;string&#62; which is typically prepended to the
		  result string.</P
></DD
><DT
>name</DT
><DD
><P
>a &#60;string&#62; which supplies the original C
		  name.</P
></DD
><DT
>sequence-of-classes</DT
><DD
><P
>a sequence of simple names for the classes
                  which logically "contain" the given object. For
                  example, if we were processing the declaration
                  "struct str {int size; char *chars", one of the
                  calls to the mapping function would have with
                  namebound to "size" and classes bound to
                  #["str"].</P
></DD
></DL
><P
>and returns a &#60;string&#62; which will be used as the
            Dylan name for the declaration.</P
></LI
><LI
><P
>Compile this module and "link" it into Melange by
            concatenating it to the end of the melange.dbc.</P
></LI
></OL
></DIV
><P
>Mapping functions may call "hyphenate-case-breaks" which
        performs the same "CaseBased separation" as is done by
        "c-to-dylan". The trivial "identity-name-mapping" described
        above might be implemented by:</P
><PRE
CLASS="PROGRAMLISTING"
>define method map-name
   (mapper == #"identity-name-mapping", category, prefix, name, classes)
=&#62; (result :: &#60;string&#62;)
   name;
end method map-name;</PRE
><P
>You may specify different name mappers to be applied to
        the slots of "container types". This capability is described
        in a later section.</P
><H2
><A
NAME="MELANGE-PREFIXES"
>Prefixes</A
></H2
><P
>As noted above, the name mapping function is passed a
        "prefix" argument. By default, it is an empty string, but
        users may specify a different value by adding a "prefix:"
        option to the interface definition. For example, we might
        expand the previous example to:</P
><PRE
CLASS="PROGRAMLISTING"
>define interface
   #include "gc.h",
      object-file: "/usr/lib/mindy/gc.o",
      name-mapper: c-to-dylan,
      prefix: "gc-";
end interface;</PRE
><P
>This would cause Melange to tack "gc-" onto the
        beginning of every translated symbol.  Because the system
        knows about the "standard" Dylan naming conventions, it can do
        this intelligently. You would, therefore, get names like
        "&#60;gc-bool&#62;", "gc-time-to-gc", and "gc-scavenge".</P
><P
>Note that the interpretation of the "prefix" is entirely
        up to the name mapping routine.  Identity-name-mapping, for
        example, completely ignores the prefix. All of the other
        standard mapping functions prepend it to the name before
        adding brackets or dollar signs, but after performing all
        other transformations.</P
><P
>Facilities for adding "localized" prefixes to slot
        accessors, enumeration literals, etc.  will be described in
        later sections.</P
><H2
><A
NAME="MELANGE-EXPLICIT-RENAMING"
>Explicit Renaming</A
></H2
><P
>Although the automatic name mapping described above is
        sufficient for most objects named within a header file, there
        are cases in which you might wish to explicitly control the
        name of one or more specific objects. You can do this through
        a "rename:" option. This options specifies a list of
        translations between raw C names and Dylan identifiers. For
        example, we might have:</P
><PRE
CLASS="PROGRAMLISTING"
>define interface
   #include "gc.h",
      object-file: "/usr/lib/mindy/gc.o",
      name-mapper: c-to-dylan,
      prefix: "gc-"
      rename: {"struct obj" =&#62; &#60;C-Object&#62;, "collect_garbage" =&#62; GC};
end interface;</PRE
><P
>Note that the "target" of the renaming is an ordinary
        Dylan variable and is therefore case-insensitive. However, the
        source is an "alien name", which is (like all C code) case
        sensitive. Alien names should refer to an object, function, or
        type in exactly the same way you would refer to them in C. We
        therefore say "struct obj" instead of simply "obj", and might
        also say "enum foo" or "union bar". Alien names are actually
        parsed according to the standard lexical conventions of C, so
        you may use arbitrary spacing and even include comments if you
        really wish.</P
><P
>Note that "rename:" options supply names for new objects
        (and types) that are being imported into Dylan. You cannot,
        therefore, simply rename "bool" to "&#60;Boolean&#62;" to make
        it equivalent to the existing type -- this would simply result
        in a name conflict. For these purposes, you would instead use
        the "equate" and "map" operations, which will be described
        later. (In fact, if the C declaration had defined a type name
        "boolean", you might have to explicitly rename it to something
        else in order to avoid name conflicts with the existing type.
        Of course, in the above example, the "gc-" prefix would be
        sufficient to make the name unique.)</P
><H2
><A
NAME="MELANGE-ANONYMOUS-TYPES"
>Anonymous Types</A
></H2
><P
>The alien names described above can also be used to
        refer to C's so-called "anonymous types". You can therefore
        refer to "char *", "int [23]", or even "int (*) (char *foo)"
        (i.e. a pointer to function which takes a string and returns
        an integer) [At present, function types are not fully
        supported. You should not depend upon them to work as
        expected.]  . The ability to refer to anonymous types is
        useful because it allows you to use the "rename" option to
        provide explicit names for such types. Normally Melange would
        simply generate a an arbitrary "anonymous" identifier for the
        type. Without knowing the name of this type, you could not
        define new operations upon it. However, by saying, for
        example, "rename: {"char * =&#62; &#60;char-ptr&#62;"}", you can
        provide a convenient handle to use in defining new
        operations.</P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c266348.htm"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c266453.htm"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Importing Header Files</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c266.htm"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Type Definitions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>