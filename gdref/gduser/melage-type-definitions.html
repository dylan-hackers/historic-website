<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Type Definitions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="Gwydion Dylan User's Guide"
HREF="gduser.html"><LINK
REL="UP"
TITLE="Using the Melange Interface Generator"
HREF="melange.html"><LINK
REL="PREVIOUS"
TITLE="Specifying Object Names"
HREF="melange-specifying-object-names.html"><LINK
REL="NEXT"
TITLE="Translating Object Representations"
HREF="melage-translating-representations.html"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Gwydion Dylan User's Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="melange-specifying-object-names.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Using the Melange Interface Generator</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="melage-translating-representations.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="MELAGE-TYPE-DEFINITIONS"
>Type Definitions</A
></H1
><P
>When Melange encounters a "type definition" [The
      definition may be implicit, as in "char ** int" or "struct foo
      *bar". Simply by being present these code fragments supply
      implicit definitions for "char *", "char **" and "struct foo".]
      within a header file, it will typically create a new Dylan class
      which corresponds to that C type. Usually, this will be a
      subclass of &#60;statically-typed-pointer&#62;, which encapsulates
      the raw C pointer value (i.e an object address).  Each
      statically typed pointer class will have exactly the same
      structure (i.e. a single address), but the class itself can be
      used to determine what operations are supported on the
      data. This could include slot accessors for "struct"s and
      "union"s, dereference operations for "pointer" types, or general
      information about the objectUs size, etc.</P
><P
> There are times when you will find that some of the types
      defined in a header file are not really "new". It might be that
      they are completely identical to some type defined in another
      interface definition, or they might be "isomorphic" to some
      existing type which has more complete support. Melange provides
      support for both of these cases. The first case is handled by
      "equating" the two types, while the second is handled by
      "mapping" (i.e.  transforming) one type into the other.</P
><P
>For example, many header files contain definitions use the
      types "char *" and "boolean".  The declarations of these types
      don't provide any semantic interpretations -- "char *" is simply
      the address of a character, and boolean is nothing but a
      one-byte integer. However, by equating "char *" to the
      predefined &#60;c-string&#62; type, we can tell Melange that it is
      actually a &#60;string&#62; and should inherit all of the
      operations defined upon &#60;string&#62;s. Likewise, we can map
      the integral "boolean" values into "#t" and "#f" to get a
      &#60;boolean&#62;. These integral values will be automatically
      translated into &#60;boolean&#62;s when they are returned by a C
      function, and &#60;boolean&#62;s will be translated back into
      integers when passed as arguments to C functions.</P
><H2
><A
NAME="MELANGE-IMPLICIT-CLASS-DEFINITIONS"
>Implicit class definitions</A
></H2
><P
>Unless otherwise specified, new classes will be created
        for each type defined in a C header file. When the header file
        provides meaningful names for these types, then Melange will
        pass those names to the mapping functions to generate names
        for the Dylan classes. Otherwise, an anonymous name will be
        generated, limiting your ability to refer to the new type. For
        example, "struct foo" would typically generate the class
        "&#60;foo&#62;", while "struct foo ***" might generate the class
        "&#60;anonymous-107&#62;". In either case, you can explicitly
        specify the name for the new class by using the "rename:"
        option described above.</P
><P
>Different sorts of C declarations will yield different
        sorts of Dylan classes as well as different sets of operations
        defined upon them. Therefore, we will consider each variety
        separately:</P
><P
></P
><DL
><DT
>Primitive types</DT
><DD
><P
>The types "int", "char", "long", "short" and their
              unsigned counterparts are simply translated into
              &#60;integer&#62;, while "float" and "double" are
              translated into &#60;float&#62;.  However, Melange knows
              the sizes of each of these types so that pointers and
              native C "vectors" of them (described below) will work
              properly. No new types are created for these
              types.</P
></DD
><DT
>Pointer types</DT
><DD
><P
>Declarations like "int *" or "struct foo ***"
              generate new subclasses of
              "&#60;statically-typed-pointer&#62;". Note that "struct
              foo *" is actually treated as a synonym for "struct
              foo", and does not get a distinct class, although any
              extra levels of indirection (i.e.  "struct foo **") will
              generate new pointer classes. Three operations are
              supported upon pointer classes:</P
><PRE
CLASS="PROGRAMLISTING"
>pointer-value (pointer, #key index) =&#62; (value)</PRE
><P
>This function "dereferences" the pointer and
              returns the value. If index is supplied, then "pointer"
              is treated as a vector of values and the appropriate
              element is returned.</P
><PRE
CLASS="PROGRAMLISTING"
>content-size (cls) =&#62; integer</PRE
><P
>Returns the size of the value referenced by
              instances of "cls". If the size is not known, this is
              0.</P
><P
>Note that these types are not automatically
              treated as vectors. You may, however, make them so by
              using a "superclasses:" option to make them
              &#60;c-vector&#62;s.</P
></DD
><DT
>Vector types</DT
><DD
><P
>Declarations like "char [256]" are treated almost
              identically to pointer types, but they are automatically
              defined as subclasses of &#60;c-vector&#62;, so that all
              vector operations will be defined on them. However,
              because many systems depend upon the lack of bounds
              checking in C, vector types have a default size of
              "#f". You may explicitly define "size" functions to
              provide a more accurate size.</P
></DD
><DT
>Structure types</DT
><DD
><P
>Declarations like "struct bar {int a; char *b;}"
              also generate new subclasses of
              "&#60;statically-typed-pointer&#62;". Melange will define
              all of the operations defined for pointer values
              (described above), as well as accessors for each of the
              structure slots.  Structure objects are always accessed
              through "pointers" to them. Therefore, unless a non-zero
              index is specified, "pointer-value" will simply return
              the object passed to it. (The operation is still defined
              because non-zero indices can be used for vector
              access.)</P
></DD
><DT
>Union types</DT
><DD
><P
>Declarations like "union bar {int a, char *b;}"
              are treated the same as struct declarations, except that
              the slot accessors all refer to the same areas in
              memory.  Enumeration types -- Declarations like "enum
              foo {one, two, three};" are simply aliased to
              &#60;integer&#62;. However, constants are defined for each
              of the enumeration literals.</P
></DD
><DT
>Typedefs</DT
><DD
><P
>Declarations like "typedef struct foo bar" simply define
              new names for existing types.</P
></DD
></DL
><H2
><A
NAME="MELANGE-CLASS-INHERITANCE"
>Specifying class inheritance</A
></H2
><P
>When Melange creates new
        "&#60;statically-typed-pointer&#62;" classes, it typically
        creates them as simple subclasses of
        "&#60;statically-typed-pointer&#62;", with no other
        superclasses. However, you might sometimes need more control
        over the class hierarchy. For example, you might wish to
        specify that a C type should be considered a subtype of the
        abstract class "&#60;sequence&#62;". You could accomplish this
        via the following declarations:</P
><PRE
CLASS="PROGRAMLISTING"
>define interface
   #include "sequence.h";
   struct "struct cons_cell" =&#62; &#60;c-list&#62;,
      superclasses: {&#60;sequence&#62;};
   function "c_list_size" =&#62; size;
end interface;

define method forward-iteration-protocol (seq :: &#60;c-list&#62;)
....</PRE
><P
>Note that the type "&#60;c-list&#62;" will still be a
        subclass of "&#60;statically-typed-pointer&#62;"&#8212;we have
        simply added "&#60;sequence&#62;" to the list of
        superclasses. If "&#60;statically-typed-pointer&#62;" is not
        explicitly included in the "superclasses:" option, then it
        will be added at the end of the superclass list.</P
><P
>As demonstrated in the above example, you are still
        responsible for specifying whatever functions are required to
        satisfy the contract for the declared
        superclasses. "&#60;C-list&#62;" will be declared as a sequence,
        but you must specify a forward iteration protocol before any
        of the standard sequence operations will work properly.</P
><P
>The "superclasses:" option may currently be used within
        "struct", "union", and "pointer" clauses.</P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="melange-specifying-object-names.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="gduser.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="melage-translating-representations.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Specifying Object Names</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="melange.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Translating Object Representations</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>