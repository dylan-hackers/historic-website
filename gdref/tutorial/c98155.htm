<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>The Nature of Variables</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="Getting Started with 
Dylan"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Expressions & Variables"
HREF="c98.htm"><LINK
REL="PREVIOUS"
TITLE="True and False"
HREF="c98148.htm"><LINK
REL="NEXT"
TITLE="Assignment, Equality and Identity"
HREF="c98171.htm"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Getting Started with 
<SPAN
CLASS="TRADEMARK"
><A
HREF="http://www.cambridge.apple.com/dylan/dylan.html"
TARGET="_top"
>Dylan</A
></SPAN
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c98148.htm"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. Expressions &#38; Variables</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c98171.htm"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="NATURE-OF-VARIABLES"
>The Nature of Variables</A
></H1
><P
>Dylan variables differ from those found in C and
      Pascal. Instead of <I
CLASS="EMPHASIS"
>holding</I
> their values, Dylan variables
      <I
CLASS="EMPHASIS"
>refer</I
> to them. Conceptually, they resemble a cross between
      pointers and <SPAN
CLASS="ACRONYM"
>C++</SPAN
> references. Like references, Dylan variables may
      be evaluated without any indirection. Like pointers, they may be set
      to point to new objects whenever the programmer desires.</P
><P
>Furthermore, there's only one of any given numeric value in a
      Dylan program, at least from the programmer's point of view. All
      variables which refer to the integer 2&#8212;or, in Dylan-speak, are
      <I
CLASS="GLOSSTERM"
>bound</I
> to the integer 2&#8212;point to the exact same
      thing.</P
><PRE
CLASS="PROGRAMLISTING"
>let x = 2; // creates x and binds it to 2
x := 3;    // rebinds x to the value 3
let y = x; // creates y, and binds it to
           //   whatever x is bound to</PRE
><P
>If two variables are bound to one object with internal
      structure, the results may suprise C and Pascal programmers.</P
><PRE
CLASS="PROGRAMLISTING"
>let car1 = make(&#60;car&#62;); // bind car1 to a
                        // new car object
car1.odometer := 10000; // set odometer
let car2 = car1;        // bind new name
car2.odometer := 0;     // reset odometer
car1.odometer;          // evaluates to 0!</PRE
><P
>As long as one or more variables refer to an object, it
      continues to exist. However, as soon as the last reference either
      goes out of scope or gets rebound, the object becomes
      <I
CLASS="GLOSSTERM"
>garbage</I
>. Since there's no way that the program could ever
      refer to the object again, the <I
CLASS="GLOSSTERM"
>garbage collector</I
> feels
      free to reuse the memory which once held it.</P
><P
>Note that Dylan variables <I
CLASS="EMPHASIS"
>must</I
> be bound to a
      particular value when they are declared. In the name of type safety
      and implementation efficiency, every variable must refer to some
      well-defined object.</P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c98148.htm"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c98171.htm"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>True and False</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c98.htm"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Assignment, Equality and Identity</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>