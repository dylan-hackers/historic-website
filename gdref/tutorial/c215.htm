<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Methods &#38; Generic Functions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="Getting Started with 
Dylan"
HREF="book1.htm"><LINK
REL="PREVIOUS"
TITLE="Module Variables and Constants"
HREF="c98205.htm"><LINK
REL="NEXT"
TITLE="Return Values"
HREF="c215246.htm"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Getting Started with 
<SPAN
CLASS="TRADEMARK"
><A
HREF="http://www.cambridge.apple.com/dylan/dylan.html"
TARGET="_top"
>Dylan</A
></SPAN
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c98205.htm"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c215246.htm"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="METHODS-GENERIC-FUNCTIONS"
>Chapter 3. Methods &#38; Generic Functions</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c215.htm#PARAMETERS"
>Parameters &#38; Parameter Lists</A
></DT
><DT
><A
HREF="c215246.htm"
>Return Values</A
></DT
><DT
><A
HREF="c215253.htm"
>Bare Methods</A
></DT
><DT
><A
HREF="c215265.htm"
>Local Methods</A
></DT
><DT
><A
HREF="c215273.htm"
>Generic Functions</A
></DT
><DT
><A
HREF="c215295.htm"
>Keyword Arguments</A
></DT
></DL
></DIV
><P
>Dylan <I
CLASS="GLOSSTERM"
>methods</I
> correspond roughly to the functions
    found in C and Pascal. They take zero or more named parameters, but
    also return zero or more named return values. A minimal Dylan method
    might look like the following:</P
><PRE
CLASS="PROGRAMLISTING"
>define method hello-world()
  puts("Hello, world!");
end;</PRE
><P
>This method has no parameters and an unspecified return value. It
    could return any number of values of any type. In order to make the
    above code more clear, the function could be rewritten as follows:</P
><PRE
CLASS="PROGRAMLISTING"
>define method hello-world() =&#62; ();
  puts("Hello, world!");
end method;</PRE
><P
>There have been two changes. The function now officially returns
    no value whatsoever. Also note that <TT
CLASS="LITERAL"
>end</TT
> has been replaced by
    <TT
CLASS="LITERAL"
>end method</TT
> which could in turn be rewritten as <TT
CLASS="LITERAL"
>end
    method hello-world</TT
>. In general, Dylan permits all the obvious
    combinations of keywords and labels to follow an end statement.</P
><H1
><A
NAME="PARAMETERS"
>Parameters &#38; Parameter Lists</A
></H1
><P
>Dylan methods declare parameters in fashion similar to that of
      conventional languages, except for the fact that parameters may
      optionally be untyped. Both of the following methods are legal:</P
><PRE
CLASS="PROGRAMLISTING"
>define method foo(x :: &#60;integer&#62;, y) end;
define method bar(m, s :: &#60;string&#62;) end;</PRE
><P
>Both <TT
CLASS="FUNCTION"
><B
>foo</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>bar</B
></TT
> have one typed and one
      untyped parameter, but neither has a well-defined return value (or
      actually does anything). As in C, each typed parameter must have its
      own type declaration; there's no syntax for saying &#8220;the last
      three parameters were all integers&#8221;.</P
><P
>Functions with variable numbers of parameters include the
      <TT
CLASS="LITERAL"
>#rest</TT
> keyword at the end of their parameter lists. Thus,
      the declaration for C's <TT
CLASS="FUNCTION"
><B
>printf</B
></TT
> function would appear
      something like the following in Dylan:</P
><PRE
CLASS="PROGRAMLISTING"
>define method printf(format-string :: &#60;string&#62;, #rest arguments) =&#62; ();
  // Print the format string, extracting
  // one at a time from "arguments". Note
  // that Dylan actually allows us to
  // verify the types of variables,
  // preventing those nasty printf errors,
  // such as using %d instead of %ld.
  // ...
end method printf;</PRE
><P
>For an actual implementation of a lightweight <TT
CLASS="FUNCTION"
><B
>printf</B
></TT
>
      function, see Appendix A. </P
><P
>Note that Dylan makes no provision for passing variables by
      reference in the Pascal sense, or for passing pointers to
      variables. Parameter names are simply bound to whatever values are
      passed, and may be rebound like regular variables. This means that
      there's no way to write a <TT
CLASS="FUNCTION"
><B
>swap</B
></TT
> function in Dylan (except
      by using macros). However, the following function works just fine,
      because it modifies the <I
CLASS="GLOSSTERM"
>internal state</I
> of another
      object:</P
><PRE
CLASS="PROGRAMLISTING"
>define method sell(car :: &#60;car&#62;, new-owner :: &#60;string&#62;) =&#62; ();
  if (credit-check(new-owner))
    car.owner = new-owner;
  else
    error("Bad credit!");
  end;
end;</PRE
><P
>If this sounds unclear, reread the chapter on <A
HREF="c98.htm"
>variables and expressions</A
>.</P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c98205.htm"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c215246.htm"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Module Variables and Constants</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Return Values</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>