<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="core_1.htm">
<LINK REL=UP HREF="core_127.htm">
<LINK REL=PREV HREF="core_128.htm">
<LINK REL=NEXT HREF="core_130.htm">
<TITLE> synchronize-side-effects</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING129></A>

<DIV>
<P><A HREF="core_130.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="core_128.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="core_127.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="core_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="core_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="core_271.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>4.5.1   Low-level synchronization</P>

</DIV>
<A NAME=HEADING129-0></A>
<H1> <A NAME=MARKER-2-732></A><A NAME=MARKER-2-733></A>synchronize-side-effects</H1>
<P><I>Function</I></P>
<H3>Summary</H3>
<P> As <CODE><A HREF="core_128.htm#MARKER-9-731">sequence-point</A></CODE>, with the addition that all side effects that have been performed within the calling thread are made visible within all other threads.</P>
<H3>Signature</H3>
<dl><dd><pre>synchronize-side-effects () =&gt; () </pre></dl>
<H3>Arguments</H3>
<DL>
<P> </P><DT>None.<DD>
</DL>
<H3>Values</H3>
<DL>
<P> </P><DT>None.<DD>
</DL>
<H3>Library</H3>
<dl><dd><pre>threads</pre></dl>
<H3>Module</H3>
<dl><dd><pre>threads</pre></dl>
<H3>Description</H3>
<P> A call to this function implies all the constraints to the compiler of a call to <A HREF="core_128.htm#MARKER-9-731"><CODE>sequence-point</CODE></A>. In addition it ensures that all side effects that have been performed within the calling thread are made visible within all other threads. Hence, no side effect performed after the call can be visible to other threads before side effects performed before the call. On a strongly ordered machine, this function might legitimately be performed as a null operation.</P>
<P> Some of the standard synchronization functions in the Threads library also ensure the visibility of side effects and act as sequence points, as if by a call to this function. This is defined to happen as follows:</P>
<UL>
<LI>Immediately before a thread exits and becomes available for joining with <A HREF="core_133.htm#MARKER-9-744"><CODE>join-thread</CODE></A> 
<LI>Before <A HREF="core_134.htm#MARKER-9-747"><CODE>thread-yield</CODE></A> yields control
<LI>After <A HREF="core_139.htm#MARKER-9-760"><CODE>wait-for</CODE></A> achieves synchronization (for all methods provided by the Threads library)
<LI>Upon entry to <A HREF="core_140.htm#MARKER-9-763"><CODE>release</CODE></A> (for all methods provided by the Threads library)
<LI>Upon entry to <A HREF="core_173.htm#MARKER-9-845"><CODE>release-all</CODE></A>
</UL>
<H3>Example</H3>
<P> This example uses low-level synchronization to implement a class for performing lazy evaluation in a thread-safe manner, without the need for locks.</P>
<P> The class guarantees that the value will not be computed until it is needed, although it does not guarantee that it will not be computed more than once concurrently. This might be useful for memorization purposes.</P>
<P> The class uses 3 slots: one for a function which may be used to compute the value, one for a boolean indicating whether the value is already known, and one for the value itself, if known.</P>
<P> It is essential that no instance can ever be observed in a state where the boolean indicates a known value before the value is present. The low-level synchronization functions ensure this cannot happen.</P>
<DL><DD><PRE>define class &lt;lazy-value&gt; (&lt;object&gt;)
  slot thunk :: &lt;function&gt;, 
       required-init-keyword: thunk:;
  slot internal-guard :: &lt;boolean&gt; = #t;
  slot computed-value;
end class;</PRE></DL>
<DL><DD><PRE>define method lazy-value (lv :: &lt;lazy-value&gt;) 
    =&gt; (value)
  if (lv.internal-guard)</PRE></DL>
<DL><DD><PRE>      // Don't yet have a value -- so compute it now;
      let value = lv.thunk();</PRE></DL>
<DL><DD><PRE>      // Store the value in place
      lv.computed-value := value;</PRE></DL>
<DL><DD><PRE>      // Before droppping the guard, synchronize side 
      // effects to ensure there is no possibility that
      // other threads might see the lowered guard
      // before seeing the value</PRE></DL>
<dl><dd><pre>      synchronize-side-effects();  </pre></dl>
<DL><DD><PRE>      // Now we can drop the guard to permit other
      // threads to use this value</PRE></DL>
<dl><dd><pre>      lv.internal-guard := #f;</pre></dl>
<dl><dd><pre>      // Finally, return the computed value</pre></dl>
<dl><dd><pre>      value</pre></dl>
<DL><DD><PRE>  else  // The value has already been computed and
        // stored, so use it</PRE></DL>
<DL><DD><PRE>    // First, need a sequence-point to force the
    // compiler not to move the read of the 
    // computed-value so that it is performed BEFORE
    // the read of the guard.</PRE></DL>
<dl><dd><pre>    sequence-point();</pre></dl>
<DL><DD><PRE>    lv.computed-value;
  end if;</PRE></DL>
<dl><dd><pre>end method;</pre></dl>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Common Dylan and Functional Extensions - 31 Mar 00</ADDRESS>
<P><A HREF="core_130.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="core_128.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="core_127.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="core_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="core_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="core_271.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
