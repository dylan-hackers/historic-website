<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="core_1.htm">
<LINK REL=UP HREF="core_43.htm">
<LINK REL=PREV HREF="core_71.htm">
<LINK REL=NEXT HREF="core_73.htm">
<TITLE> subclass</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING72></A>

<DIV>
<P><A HREF="core_73.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="core_71.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="core_43.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="core_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="core_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="core_271.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>2.6   The COMMON-EXTENSIONS module </P>

</DIV>
<A NAME=HEADING72-0></A>
<H1> <A NAME=MARKER-2-509></A><A NAME=MARKER-2-510></A><A NAME=MARKER-10-511></A>subclass</H1>
<P><I>Function</I></P>
<H3>Summary</H3>
<P> Returns a type representing a class and its subclasses.</P>
<H3>Signature</H3>
<dl><dd><pre>subclass <I>class</I> =&gt; <I>subclass-type</I> </pre></dl>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>class</I><DD> An instance of <CODE>&lt;class&gt;</CODE>.
</DL>
<H3>Values</H3>
<DL>
<P> </P><DT><I>subclass-type</I><DD> An instance of <CODE>&lt;type&gt;</CODE>.
</DL>
<H3><A NAME=MARKER-10-512></A>Library</H3>
<dl><dd><pre>common-extensions</pre></dl>
<H3>Module</H3>
<dl><dd><pre>common-extensions</pre></dl>
<H3>Description</H3>
<P> Returns a type that describes all the objects representing subclasses of the given class. We term such a type a <I>subclass type</I>. </P>
<P> The <CODE>subclass</CODE> function is allowed to return an existing type if that type is type equivalent to the subclass type requested.</P>
<P> Without <CODE>subclass</CODE>, methods on generic functions (such as Dylan's standard <CODE>make</CODE> and <CODE>as</CODE>) that take types as arguments are impossible to reuse without resorting to ad hoc techniques. In the language defined by the DRM, the only mechanism available for specializing such methods is to use singleton types. A singleton type specializer used in this way, by definition, gives a method applicable to exactly one type. In particular, such methods are not applicable to subtypes of the type in question. In order to define reusable methods on generic functions like this, we need a type which allows us to express applicability to a type and all its subtypes. </P>
<P> For an object <I>O</I> and class <I>Y</I>, the following <CODE>instance?</CODE> relationship applies:</P>
<dl><dd><pre>INSTANCE-1: instance?(<I>O</I>, subclass(<I>Y</I>)) </pre></dl>
<P> True if and only if <I>O</I> is a class and <I>O</I> is a subclass of <I>Y</I>.</P>
<P> For classes <I>X</I> and <I>Y</I> the following <CODE>subtype?</CODE> relationships hold (note that a rule applies only when no preceding rule matches):</P>
<dl><dd><pre>SUBTYPE-1: subtype?(subclass(<I>X</I>), subclass(<I>Y</I>)) </pre></dl>
<P> True if and only if <I>X</I> is a subclass of <I>Y</I>.</P>
<dl><dd><pre>SUBTYPE-2: subtype?(singleton(<I>X</I>), subclass(<I>Y</I>)) </pre></dl>
<P> True if and only if <I>X</I> is a class and <I>X</I> is a subclass of <I>Y</I>. </P>
<dl><dd><pre>SUBTYPE-3: subtype?(subclass(<I>X</I>), singleton(<I>Y</I>))</pre></dl>
<P> Always false.</P>
<dl><dd><pre>SUBTYPE-4: subtype?(subclass(<I>X</I>), <I>Y</I>)</pre></dl>
<P> where <I>Y</I> is not a subclass type. True if <I>Y</I> is <CODE>&lt;class&gt;</CODE> or any proper superclass of <CODE>&lt;class&gt;</CODE> (including <CODE>&lt;object&gt;</CODE>, any implementation-defined supertypes, and unions involving any of these). There may be other implementation-defined combinations of types <I>X</I> and <I>Y</I> for which this is also true. </P>
<dl><dd><pre>SUBTYPE-5: subtype?(<I>X</I>, subclass(<I>Y</I>))</pre></dl>
<P> where <I>X</I> is not a subclass type. True if <I>Y</I> is <CODE>&lt;object&gt;</CODE> or any proper supertype of <CODE>&lt;object&gt;</CODE> and <I>X</I> is a subclass of <CODE>&lt;class&gt;</CODE>.</P>
<P> Note that by subclass relationships <CODE>SUBTYPE-4</CODE> and <CODE>SUBTYPE-5</CODE>, we get this correspondence: <CODE>&lt;class&gt;</CODE> and <CODE>subclass(&lt;object&gt;)</CODE> are type equivalent.</P>
<P> Where the <CODE>subtype?</CODE> test has not been sufficient to determine an ordering for a method's argument position, the following further method-ordering rules apply to cases involving subclass types (note that a rule applies only when no preceding rule matches):</P>
<P> <CODE>SPECIFICITY+1</CODE>. <CODE>subclass(<I>X)</I></CODE> precedes <CODE>subclass(<I>Y)</I></CODE> when the argument is a class <I>C</I> and <I>X</I> precedes <I>Y</I> in the class precedence list of <I>C</I>.</P>
<P> <CODE>SPECIFICITY+2</CODE>. <CODE>subclass(<I>X)</I></CODE> always precedes <I>Y</I>, <I>Y</I> not a subclass type. That is, applicable subclass types precede any other applicable class-describing specializer. </P>
<P> The constraints implied by sealing come by direct application of sealing rules 1-3 (see page 136of the DRM) and the following disjointness criteria for subclass types (note that a rule applies only when no preceding rule matches):</P>
<P> <CODE>DISJOINTNESS+1</CODE>. A subclass type <CODE>subclass(<I>X)</I></CODE> and a type <I>Y</I> are disjoint if <I>Y</I> is disjoint from <CODE>&lt;class&gt;</CODE>, or if <I>Y</I> is a subclass of <CODE>&lt;class&gt;</CODE> without instance classes that are also subclasses of <I>X</I>.</P>
<P> <CODE>DISJOINTNESS+2</CODE>. Two subclass types <CODE>subclass(<I>X)</I></CODE> and <CODE>subclass(<I>Y)</I></CODE> are disjoint if the classes <I>X</I> and <I>Y</I> are disjoint. </P>
<P> <CODE>DISJOINTNESS+3</CODE>. A subclass type <CODE>subclass(<I>X)</I></CODE> and a singleton type <CODE>singleton(<I>O)</I></CODE> are disjoint unless <I>O</I> is a class and <I>O</I> is a subclass of <I>X</I>. </P>
<P> The guiding principle behind the semantics is that, as far as possible, methods on classes called with an instance should behave isomorphically to corresponding methods on corresponding subclass types called with the class of that instance. So, for example, given the heterarchy:</P>
<DL><DD><PRE> &lt;object&gt;
    |
   &lt;A&gt;
   / \
  &lt;B&gt; &lt;C&gt;
    \ /
    &lt;D&gt;</PRE></DL>
<P> and methods:</P>
<DL><DD><PRE>  method foo (&lt;A&gt;)
  method foo (&lt;B&gt;)
  method foo (&lt;C&gt;)
  method foo (&lt;D&gt;)</PRE></DL>
<DL><DD><PRE>  method foo-using-type (subclass(&lt;A&gt;))
  method foo-using-type (subclass(&lt;B&gt;))
  method foo-using-type (subclass(&lt;C&gt;))
  method foo-using-type (subclass(&lt;D&gt;))</PRE></DL>
<P> that for a direct instance <I>D<SUB>1</SUB></I> of <CODE>&lt;D&gt;</CODE>:</P>
<dl><dd><pre>  foo-using-type(&lt;D&gt;)</pre></dl>
<P> should behave analogously to:</P>
<dl><dd><pre>  foo(D1)</pre></dl>
<P> with respect to method selection. </P>
<H3>Example</H3>
<DL><DD><PRE>define class &lt;A&gt; (&lt;object&gt;) end;
define class &lt;B&gt; (&lt;A&gt;) end;
define class &lt;C&gt; (&lt;A&gt;) end;
define class &lt;D&gt; (&lt;B&gt;, &lt;C&gt;) end;</PRE></DL>
<DL><DD><PRE>define method make (class :: subclass(&lt;A&gt;), #key)
  print(&quot;Making an &lt;A&gt;&quot;);
  next-method();
end method;</PRE></DL>
<DL><DD><PRE>define method make (class :: subclass(&lt;B&gt;), #key)
  print(&quot;Making a &lt;B&gt;&quot;);
  next-method();
end method;</PRE></DL>
<DL><DD><PRE>define method make (class :: subclass(&lt;C&gt;), #key)
  print(&quot;Making a &lt;C&gt;&quot;);
  next-method();
end method;</PRE></DL>
<DL><DD><PRE>define method make (class :: subclass(&lt;D&gt;), #key)
  print(&quot;Making a &lt;D&gt;&quot;);
  next-method();
end method;</PRE></DL>
<DL><DD><PRE>? make(&lt;D&gt;);
Making a &lt;D&gt;
Making a &lt;B&gt;
Making a &lt;C&gt;
Making an &lt;A&gt;
{instance of &lt;D&gt;}</PRE></DL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Common Dylan and Functional Extensions - 31 Mar 00</ADDRESS>
<P><A HREF="core_73.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="core_71.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="core_43.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="core_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="core_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="core_271.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
