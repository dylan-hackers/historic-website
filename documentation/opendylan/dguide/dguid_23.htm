<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="dguide_1.htm">
<LINK REL=UP HREF="dguid_19.htm">
<LINK REL=PREV HREF="dguid_22.htm">
<LINK REL=NEXT HREF="dguid_24.htm">
<TITLE>3.4   Defining a new frame class</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING23></A>

<DIV>
<P><A HREF="dguid_24.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="dguid_22.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="dguid_19.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="dguide_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="dguide_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="dgui_110.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>3 Improving The Design</P>

</DIV>
<A NAME=HEADING23-0></A>
<A NAME=UID-improve-889397></A>
<H1>3.4   <A NAME=MARKER-2-159></A><A NAME=MARKER-2-160></A><A NAME=MARKER-2-161></A><A NAME=MARKER-9-162></A>Defining a new frame class</H1>
<P>To begin with, define a frame class using the layout hierarchy you have already created. Although it might seem redundant to implement an inelegant layout again, it is easier to illustrate the basic techniques using a design you are already familiar with. In addition, there are several elements in the design that can be reused successfully. </P>
<P>Add the code described in this section to <CODE>frame.dylan</CODE>.</P>
<P>Defining a new class of frame is just like defining any Dylan class, except that there are several extra options available beyond the slot options normally available to <CODE>define class</CODE>. Each of these extra options lets you describe a particular aspect of the user interface. To define the new frame class, use the following structure:</P>
<PRE>
define frame &lt;task-frame&gt; (&lt;simple-frame&gt;)
  // definitions of frame slots and options go here
end frame &lt;task-frame&gt;;
<P></P>
</PRE>
<P>In this case, <CODE>&lt;task-frame&gt;</CODE> is the name of the new class of frame, and<CODE> &lt;simple-frame&gt;</CODE> is its superclass. Like ordinary Dylan classes, frame classes can have any number of superclasses, with multiple superclasses separated by commas. The superclass of any "standard" frame is usually <CODE>&lt;simple-frame&gt;</CODE>. If you were designing a dialog box, its superclass would be <CODE>&lt;dialog-frame&gt;</CODE>. If you were designing a wizard, its superclass would be <CODE>&lt;wizard-frame&gt;</CODE>.</P>
<P>Adding slots to a frame class is exactly the same as adding slots to a standard Dylan class. You can define slot names, init-keywords, init-functions, default values, and so on. For this example, you are not defining any slots.</P>
<P>Each user interface element in the new class of frame is specified as a pane with a name and a definition. A pane is a sheet within a layout, and you can think of panes as sheets that represent concrete classes in an interface (as opposed to abstract classes). In effect, specifying a pane allows you to group together existing gadgets into some meaningful relationship that effectively creates a new gadget, without actually defining a gadget class.</P>
<P>The name is used to refer to the pane, both from within the frame definition itself, and from other code. The pane definition includes code to create the interface element. A pane specification also includes a place to declare a local variable that can be used within the pane's definition to refer to the surrounding frame.</P>
<P>The following code fragment defines the two buttons, the text field, the radio box, and the list box from the initial design:</P>
<PRE>
pane add-button (frame)
  make(&lt;push-button&gt;, label: &quot;Add task&quot;,
       activate-callback: not-yet-implemented);
pane remove-button (frame)
  make(&lt;push-button&gt;, label: &quot;Remove task&quot;,
       activate-callback: not-yet-implemented);
pane task-text (frame)
  make(&lt;text-field&gt;, label: &quot;Task text:&quot;,
        activate-callback: not-yet-implemented);
pane priority-box (frame)
  make (&lt;radio-box&gt;, label: &quot;Priority:&quot;, 
       items: #(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;), 
       orientation: #&quot;vertical&quot;,
       activate-callback: not-yet-implemented);
pane task-list (frame)
  make(&lt;list-box&gt;, items: #(), lines: 15,
       activate-callback: not-yet-implemented);
<P></P>
</PRE>
<P>Note that the definition of each element is identical to the definitions included in the original layout described in <A HREF="dguid_14.htm#MARKER-9-124">Section 2.3 on page 6</A> (except that activate callbacks have been added to the code). Adding <CODE>(frame)</CODE> immediately after the name of each pane lets you refer to the frame itself within the frame definition using a local variable. This means that you can refer to any pane within the frame using normal slot syntax; that is, a pane called <CODE>my-pane</CODE> can be referred to as <CODE>frame.my-pane</CODE> throughout all of the definition of the frame class. This ability is essential when you come to layout each pane in the frame itself.</P>
<P>In addition, you need to define the layout in which to place these panes. This is itself just another pane, and its definition is again identical to the original layout described in <A HREF="dguid_14.htm#MARKER-9-124">Section 2.3 on page 6</A>, with one exception; rather than defining each element explicitly, you just include a reference to the relevant pane that you have already defined using normal slot syntax, thus:</P>
<PRE>
pane task-layout (frame)
  horizontally ()
    frame.task-list; 
    vertically () 
      horizontally () 
        frame.task-text;
        frame.add-button;
      end;
      frame.remove-button;
      frame.priority-box;
    end;
  end;
<P></P>
</PRE>
<P>To describe the top-level layout for the frame, you need to refer to this pane using the <CODE>layout</CODE> option, as follows:</P>
<PRE>
layout (frame) frame.task-layout;
<P></P>
</PRE>
<P>You actually have a certain amount of freedom when choosing what to define as a pane in the definition of a frame class. For example, the layout in the <CODE>task-layout</CODE> pane actually contains a number of sub-layouts. If you wanted, each one of these sub-layouts could be defined as a separate pane within the frame definition. Note, however, that you only have to "activate" the top-most layout; there should only be one use of the <CODE>layout</CODE> option.</P>
<P>Similarly, you are free to use whatever programming constructs you like when defining elements in your code. Just as in the earlier examples, you could define the layouts with explicit calls to <CODE>make</CODE>, rather than by using the <CODE>horizontally</CODE> and <CODE>vertically</CODE> macros. Thus, the following definition of <CODE>task-layout</CODE> is just as valid as the one above:</P>
<PRE>
pane task-layout (frame)
  make(&lt;row-layout&gt;,
       children: vector(frame.task-list,
                        make(&lt;column-layout&gt;,
                             children: 
                               vector(make(&lt;row-layout&gt;,
                                           children:
                                             vector
                                              (frame.task-text,
                                               frame.add-button)
                                          )))));
<P></P>
</PRE>
<P>Notice that this construct is rather more complicated than the one using macros!</P>
<P>Throughout this section, you may have noticed that you can identify a sequence of steps that need to occur inside the definition of a frame. It is good practice to keep this sequence in mind when writing your own frame-based code:</P>
<DL>
<DT><DD>1.  Define the content panes
<DT><DD>2.  Define the layout panes
<DT><DD>3.  Use the <CODE>layout</CODE> option
</DL>
<P>If you glue all the code defined in this section together, you end up with the following complete definition of a frame class.</P>
<PRE>
define frame &lt;task-frame&gt; (&lt;simple-frame&gt;)
  pane add-button (frame)
    make(&lt;push-button&gt;, label: &quot;Add task&quot;,
         activate-callback: not-yet-implemented);
  pane remove-button (frame)
    make(&lt;push-button&gt;, label: &quot;Remove task&quot;,
         activate-callback: not-yet-implemented);
  pane task-text (frame)
    make(&lt;text-field&gt;, label: &quot;Task text:&quot;,
         activate-callback: not-yet-implemented);
  pane priority-box (frame)
    make(&lt;radio-box&gt;, label: &quot;Priority:&quot;,
         items: #(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;),
         orientation: #&quot;vertical&quot;,
         activate-callback: not-yet-implemented);
  pane task-list (frame)
    make (&lt;list-box&gt;, items: #(), lines: 15,
          activate-callback: not-yet-implemented);
  pane task-layout (frame)
    horizontally ()
      frame.task-list; 
      vertically () 
        horizontally () 
          frame.task-text;
          frame.add-button;
        end;
        frame.remove-button;
        frame.priority-box;
      end;
    end;
  layout (frame) frame.task-layout;
  keyword title: = &quot;Task List Manager&quot;;
end frame &lt;task-frame&gt;;
<P></P>
</PRE>
<P>Note the addition of a <CODE>title:</CODE> keyword at the end of the definition. This can be used to give any instance of the frame class a title that is displayed in the title bar of the frame's window when it is mapped to the screen.</P>
<P>At this stage, the application still has no real functionality, and there is no improvement in the interface compared to the initial design, but by defining a frame class, the implementation is inherently more robust, making it easier to modify and, eventually, maintain.</P>
<P>If you want to try running your code, remember that you need to define some additional methods to create a frame instance and exit it cleanly. Methods for doing this were provided in <A HREF="dguid_21.htm#MARKER-9-155">Section 3.2 on page 13</A>. If you define these methods now, you can create running versions of each successive generation of the application as it is developed.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Building Applications Using DUIM - 26 May 1999</ADDRESS>
<P><A HREF="dguid_24.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="dguid_22.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="dguid_19.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="dguide_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="dguide_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="dgui_110.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
