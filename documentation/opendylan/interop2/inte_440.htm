<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inte_436.htm">
<LINK REL=PREV HREF="inte_439.htm">
<LINK REL=NEXT HREF="inte_441.htm">
<TITLE> define dispatch-client</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING440></A>

<DIV>
<P><A HREF="inte_441.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_439.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>5.3   Macros for defining custom interfaces</P>

</DIV>
<A NAME=HEADING440-0></A>
<H1> <A NAME=MARKER-2-1487></A>define dispatch-client</H1>
<P><I>Definition macro</I></P>
<H3>Summary</H3>
<P> Generates simple Dylan clients to COM dispatch interfaces.</P>
<H3>Macro call</H3>
<DL><DD><PRE>define dispatch-client <I>interface-name</I>
  <EM>{</EM> <I>uuid</I> <EM>|</EM> <I>property</I> <EM>|</EM> <I>function</I> <EM>}*</EM>
end <EM>[</EM>dispatch-client<EM>] [<I>interface-name]</I></EM></PRE></DL>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>interface-name</I><DD> name<SUB>bnf</SUB> 
<P> </P><DT><I>uuid</I> <DD> A GUID that identifies the interface. 
<P>The default is <CODE>$IID-IDispatch</CODE>. </P>
<P>This value should preferably be an instance of <CODE>&lt;REFGUID&gt;</CODE> (from <CODE>make-GUID</CODE>) but can also be a string representation of the GUID (containing 32 hexadecimal digits within braces).</P>
<P> </P><DT><I>property</I><DD>
</DL>
<DL><DD><PRE>  <EM>[</EM> size <EM>|</EM> element <EM>] [</EM> constant <EM>|</EM> write-only <EM>]</EM> property
    <I>prop-name</I> 
          <EM>[</EM> ( <EM>{</EM> <I>argument-name</I> <EM>[</EM> :: <I>argument-type</I> <EM>]}*</EM> ) <EM>]</EM>
          <EM>[</EM> :: <I>property-type</I> <EM>]</EM>
          <EM>{</EM> , <I>option</I> <EM>}*</EM> ;</PRE></DL>
<DL>
<P> </P><DT><I>function</I> <DD>
</DL>
<DL><DD><PRE>  function <I>member-name</I>
        <EM>[</EM> ( <EM>{</EM> <I>argument-name</I> <EM>[</EM> :: <I>argument-type</I> <EM>]}*</EM> )
          <EM>[</EM> =&gt; ( <EM>{</EM> <I>result-name</I> <EM>[</EM> :: <I>result-type</I> <EM>]}*</EM> ) <EM>]</EM>
        <EM>]</EM> <EM>{</EM> , <I>option</I> <EM>}*</EM> ;</PRE></DL>
<DL>
<P> </P><DT><I>option</I> <DD>
</DL>
<dl><dd><pre>  <EM>{</EM> name: <I>name</I> <EM>|</EM> disp-id: <I>disp-id</I> <EM>}</EM></pre></dl>
<H3>Library</H3>
<dl><dd><pre>OLE-Automation</pre></dl>
<H3>Module</H3>
<dl><dd><pre>OLE</pre></dl>
<H3>Description</H3>
<P> Generates simple Dylan clients to COM dispatch interfaces. It defines a class <I>interface-name</I> to represent the COM interface described. The class is a subclass of <CODE>&lt;dispatch-client&gt;</CODE>, and of <CODE>&lt;collection&gt;</CODE> if the <CODE>size</CODE> or <CODE>element</CODE> adjectives are present. </P>
<P> The <CODE>&lt;dispatch-client&gt;</CODE> class is a subclass of <CODE>&lt;LPDISPATCH&gt;</CODE>, so instances of dispatch-client types can be passed directly to functions such as <CODE>AddRef</CODE> and <CODE>Release</CODE>.</P>
<P> If a <I>uuid</I> clause is present, it specifies the interface ID for the interface. This value can be retrieved by applying the method <CODE>dispatch-client-uuid</CODE> to either the <CODE>&lt;dispatch-client&gt;</CODE> class or an instance. </P>
<P> A <CODE>make</CODE> method is defined on <I>interface-name</I>. No matter how the interface is created, it should be released with <CODE>Release</CODE> when it is no longer needed. The <CODE>make</CODE> method can be invoked with either a <CODE>disp-interface:</CODE> keyword or a <BR><CODE>class-id:</CODE> keyword, and, optionally, with <CODE>interface-ID:</CODE> keyword. The reference information for these keywords is as follows:</P>
<DL>
<P> </P><DT><CODE>disp-interface:</CODE><DD>
<P>Specifies an <CODE>&lt;LPDISPATCH&gt;</CODE> or a <BR><CODE>&lt;dispatch-client&gt;</CODE> to create the new interface from. If an interface ID is provided via the <CODE>uuid</CODE> clause or via the <CODE>interface-ID:</CODE> keyword, <CODE>QueryInterface</CODE> is used to find the new interface, otherwise the existing interface is used (after having <CODE>AddRef</CODE> applied).</P>
<P> </P><DT><CODE>class-id:</CODE><DD>
<P>The UUID of a coclass which implements the desired interface. The coclass is created with <CODE>create-dispatch</CODE>. If an interface ID is provided via the <CODE>uuid</CODE> clause or via the <CODE>interface-ID:</CODE> keyword, that interface ID is requested, otherwise <CODE>$IID-IDispatch</CODE> is requested.</P>
<P> </P><DT><CODE>interface-id:</CODE> (optional)<DD>
<P>If a <CODE>&lt;string&gt;</CODE> or <CODE>&lt;LPGUID&gt;</CODE> is provided, that GUID is used as an interface ID rather than any provided by the <CODE>uuid</CODE> clause. If <CODE>#f</CODE> is provided for the <CODE>interface-ID:</CODE> keyword, then no interface ID (when <CODE>disp-interface:</CODE> is provided) or <CODE>$IID-IDispatch</CODE> (when <BR><CODE>class-id:</CODE> is provided) is used.</P>
</DL>
<P> For every <I>property</I> or <I>function</I> a getter named <I>member-name<CODE>-dispid</CODE></I> is defined. This getter, when passed an instance of <I>interface-name</I>, returns the dispatch ID for <I>member-name</I>. If a value was provided by the <CODE>disp-id:</CODE> <I>option</I>, that value is returned, otherwise the dispatch ID is looked up with <BR><CODE>get-id-of-name</CODE> and cached in a private per-instance slot. The name that is looked up is that specified by the <CODE>name:</CODE> <I>option</I>, or if not supplied the name of the property/method.</P>
<P> <I>property</I> declarations cause the appropriate getter and setter methods to be defined. <CODE>constant</CODE> properties have only a getter; <CODE>write-only</CODE> properties have only a setter; other properties have both. The getter method for a property accepts the <CODE>default:</CODE> keyword. If the server does not return a value (common for indexed properties), the value of <CODE>default:</CODE> is returned. If <CODE>default:</CODE> is not specified or <CODE>$unsupplied</CODE> and the server does not return a value, an error is signalled.</P>
<P> If a property has arguments, the setter/getter methods accept those arguments and treat the property as an OLE indexed property. An indexed property with a single argument may have the <CODE>element</CODE> adjective applied.</P>
<P> If a property has the <CODE>element</CODE> adjective applied then <CODE>element</CODE> getter and/or setter methods are defined and the class inherits from <CODE>&lt;collection&gt;</CODE>. The <CODE>element</CODE> getter/setter methods simply call the setters/getters for the property. For the <CODE>element</CODE> adjective to be applied to a property, the property must take a single argument and return a single value.</P>
<P> If a property has the <CODE>size</CODE> adjective applied then <CODE>size</CODE> getter and/or setter methods are defined and the class inherits from <CODE>&lt;collection&gt;</CODE>. The <CODE>size</CODE> getter/setter methods simply call the setters/getters for the property. For the <CODE>size</CODE> adjective to be applied to a property, the property must not take any arguments and must return an integer.</P>
<P> <I>function</I> declarations cause a method to be defined. The method accepts an instance of <I>interface-name</I> and any additional arguments specified in the declaration. The method simply invokes <CODE>call-simple-method</CODE> with the appropriate dispatch ID. Parameters and return values that are subtypes of <CODE>&lt;dispatch-client&gt;</CODE> are automatically translated to/from <CODE>&lt;LPDISPATCH&gt;</CODE>.</P>
<H3>Example</H3>
<P> An invocation of the macro looks much like a <CODE>define</CODE> <CODE>class</CODE> or a <CODE>define</CODE> <CODE>dispatch-interface</CODE> invocation:</P>
<DL><DD><PRE>define dispatch-client &lt;IBlorf&gt;
  uuid &quot;{1f5bfc72-fa7a-11d1-a3c3-0060b0572a7f}&quot;;
  property IBlorf/Foo :: &lt;integer&gt;, disp-id: 7;
  function IBlorf/Bar (a :: &lt;integer&gt;) <BR>    =&gt; (b :: &lt;string&gt;),
    name: &quot;mBar&quot;;
end dispatch-client &lt;IBlorf&gt;;</PRE></DL>
<P> The above defines a class <CODE>&lt;IBlorf&gt;</CODE> to represent the COM interface described, and defines methods <CODE>IBlorf/Foo</CODE>, <CODE>IBlorf/Foo-setter</CODE>, and <CODE>IBlorf/Bar</CODE> which call <CODE>call-simple-method</CODE> with the appropriate DISPID.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>OLE, COM, ActiveX and DBMS Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inte_441.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_439.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
