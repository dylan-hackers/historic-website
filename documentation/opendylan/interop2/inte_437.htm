<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inte_436.htm">
<LINK REL=PREV HREF="inte_436.htm">
<LINK REL=NEXT HREF="inte_438.htm">
<TITLE> define custom-interface</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING437></A>

<DIV>
<P><A HREF="inte_438.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>5.3   Macros for defining custom interfaces</P>

</DIV>
<A NAME=HEADING437-0></A>
<H1> <A NAME=MARKER-2-1481></A>define custom-interface</H1>
<P><I>Definition macro</I></P>
<H3>Summary</H3>
<P> Creates a new custom v-table COM interface.</P>
<H3>Macro call</H3>
<DL><DD><PRE>define <EM>[</EM> <I>class-adjectives</I> <EM>]</EM> custom-interface <I>interface-name</I>  (<I>superclass</I>) 
  <EM>[</EM> client-class <I>client-class-name </I>
<EM>  [</EM> :: <I>client-superclass-name</I> <EM>] </EM>; <EM>] </EM>
    uuid <I>uuid</I>;
  <EM>{</EM> <I>property</I> <EM>|</EM> <I>function</I> <EM>}*</EM> 
end <EM>[</EM> custom-interface <EM>]</EM> <EM>[</EM> <I>interface-name</I> <EM>]</EM> </PRE></DL>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>class-adjectives</I><DD> Any Dylan class definition adjective.
<P> </P><DT><I>interface-name</I><DD> name<SUB>bnf</SUB> 
<P> </P><DT><I>superclass</I><DD> name<SUB>bnf</SUB> 
<P> </P><DT><I>client-class-name</I><DD> name<SUB>bnf</SUB> 
<P> </P><DT><I>uuid</I><DD> A GUID that identifies the interface. 
<P>The default is <CODE>$IID-IDispatch</CODE>. </P>
<P>This value should preferably be an instance of <CODE>&lt;REFGUID&gt;</CODE> (from <CODE>make-GUID</CODE>) but can also be a string representation of the GUID (containing 32 hexadecimal digits within braces).</P>
<P> </P><DT><I>property</I> <DD>
</DL>
<DL><DD><PRE>  <EM>{</EM> constant property <I>property-name</I> :: <I>property-type</I> ;
  <EM>|</EM> constant property <I>property-name</I> <EM>[</EM> :: <I>property-type</I> <EM>]</EM> 
      = <I>property-value</I> ; 
  <EM>| [</EM> virtual <EM>]</EM> property <I>property-name</I> :: <I>property-type</I> ; 
  <EM>}</EM></PRE></DL>
<DL>
<P> </P><DT><I>function</I> <DD>
</DL>
<DL><DD><PRE>  <EM>{</EM> function <EM>|</EM> vtable-member <EM>}</EM> <I>member-name</I> 
      ( <EM>{</EM> <I>argument-name</I> :: <I>argument-type</I>, <EM>}*</EM> )
         =&gt; ( <EM>{</EM> <I>result-name</I> :: <I>result-type</I>, <EM>}*</EM> );</PRE></DL>
<H3>Library</H3>
<dl><dd><pre>COM</pre></dl>
<H3>Module</H3>
<dl><dd><pre>COM</pre></dl>
<H3>Description</H3>
<P> Used<CODE> </CODE>to create a new COM interface, with a v-table determined by the superclass and the <CODE>function</CODE>, <CODE>vtable-member</CODE> and <CODE>property</CODE> clauses. An implementation of the interface can be created by using <CODE>define</CODE> <CODE>COM-interface</CODE> to define a subclass of <I>interface-name</I>. </P>
<P> The <I>superclass</I> specifies the interface class to inherit from. Often it will be <CODE>&lt;IUnknown&gt;</CODE>, but it could be another standard interface (for example, <CODE>&lt;IDispatch&gt;</CODE> for a dual interface) or another class defined by <CODE>define</CODE> <CODE>custom-interface</CODE>. </P>
<P> The optional <CODE>client-class</CODE> clause specifies the name that will be defined as the C pointer class to be used by a client. If a <I>client-superclass-name</I> is supplied, it is used as the superclass for the client class; otherwise <CODE>&lt;C-interface&gt;</CODE> is used as the superclass. After obtaining an interface pointer from a function such as <CODE>QueryInterface</CODE> or <CODE>CoCreateInstance</CODE>, you should call <CODE>pointer-cast</CODE> to convert it to this class since that is where the client-side methods will be defined. If a client-class clause is not specified, client methods will be defined. If a client-class clause is not specified, client methods will be defined on <CODE>&lt;C-interface&gt;</CODE>. Omitting client-class should be done with caution, because it can lead to name conflicts between members of different interfaces, as well as losing some type safety. (Invoking a v-table member through a wrong pointer can cause an out-of-language crash.)</P>
<P> The <CODE>uuid</CODE> clause is required; it specifies the interface ID by which <CODE>QueryInterface</CODE> will find this interface. The value may be given as either a string or a structure created by <CODE>make-GUID</CODE>. </P>
<P> A <CODE>function</CODE> or <CODE>vtable-member</CODE> declaration adds a slot to the v-table, defines a method on the <CODE>&lt;C-interface&gt;</CODE> subclass that will do an indirect call through the v-table slot, and a <CODE>C-callable-wrapper</CODE> that will connect the v-table slot of a Dylan instance to a call to the generic function on the Dylan object. The actual implementation method must be defined separately. The method must accept an instance of <I>interface-name</I> and any additional arguments specified in the declaration. For consistency with <CODE>define <BR>dispatch-interface</CODE>, the <CODE>function</CODE> clause implies that the first return value is an <CODE>&lt;SCODE&gt;</CODE> status code, followed by the explicit return values. The <CODE>vtable-member</CODE> clause differs only in that all result values must be declared explicitly; thus it allows specifying methods that do not return a status code.</P>
<P> The first return value will be implemented directly as the return value of the C function, while any additional return values will be converted to output parameters following the specified input parameters.</P>
<P> A <CODE>property</CODE> declaration is an abbreviation for defining a pair of methods to get and set a value. For example, </P>
<dl><dd><pre>  property blip :: &lt;integer&gt;;</pre></dl>
<P> is equivalent to the pair</P>
<DL><DD><PRE>  vtable-member blip () =&gt; (value :: &lt;integer&gt;);
  vtable-member set_blip ( value :: &lt;integer&gt; ) =&gt; ();</PRE></DL>
<P> plus defining a client-side method on <CODE>blip-setter</CODE> that calls <CODE>set_blip</CODE> and a server-side method on <CODE>set_blip</CODE> that calls <CODE>blip-setter</CODE>, so that the internal name <CODE>set_blip</CODE> never needs to be referenced directly.  (This conversion is necessary because ...<CODE>-setter</CODE> methods require the opposite argument order.)</P>
<P> Thus, an implementation for the property can be provided by simply defining a slot with the same name in the implementation class. The optional modifier <CODE>virtual</CODE> has no effect here; it is allowed simply for consistency with <CODE>define</CODE> <BR><CODE>dispatch-interface</CODE>. </P>
<P> For a <CODE>constant</CODE> <CODE>property</CODE>, only the getter member is created. If a <I>property-value</I> is specified, a getter method that returns that value will be created automatically on the server side.</P>
<P> The types of properties, function arguments, and function results may be specified by using either one of the following Dylan classes: </P>
<P> <CODE>&lt;integer&gt;, &lt;single-float&gt;, &lt;double-float&gt;, &lt;string&gt;, &lt;byte-string&gt;, &lt;machine-word&gt;, &lt;SCODE&gt;, &lt;HRESULT&gt;, &lt;character&gt;, &lt;byte-character&gt;, &lt;byte&gt;, &lt;boolean&gt;, &lt;Interface&gt;, &lt;mapped-interface&gt;, &lt;LONG&gt;, &lt;LPUNKNOWN&gt;, &lt;BSTR&gt;</CODE></P>
<P> or one of the following C types:</P>
<P> <CODE>&lt;C-boolean&gt;, &lt;C-both-signed-long&gt;, &lt;C-both-unsigned-long&gt;, &lt;C-byte&gt;, &lt;C-char&gt;, &lt;C-character&gt;, <BR>&lt;C-double&gt;, &lt;C-float&gt;, &lt;C-HRESULT&gt;, &lt;C-int&gt;, <BR>&lt;C-long&gt;, &lt;C-raw-unsigned-long&gt;, &lt;C-short&gt;, <BR>&lt;C-signed-char&gt;, &lt;C-string&gt;, &lt;C-unicode-string&gt;, <BR>&lt;C-unsigned-char&gt;, &lt;C-unsigned-int&gt;, &lt;C-unsigned-short&gt;, &lt;DWORD&gt;, &lt;ULONG&gt;, &lt;USHORT&gt;, &lt;WORD&gt;</CODE></P>
<P> or any C pointer type. (But remember that arbitrary pointers can generally be meaningfully used only with an in-process server.)</P>
<P> Note that because of current implementation limitations, the type name must literally be one of those listed above, not some other name that is defined to be equal to one of them.</P>
<P> See also the <A HREF="inte_439.htm#MARKER-9-1486"><CODE>define vtable-interface</CODE></A> macro, which is like <CODE>define</CODE> <CODE>custom-interface</CODE> except that it also generates type information for creating a type library.</P>
<H3>Example</H3>
<P> <CODE>define custom-interface</CODE> does not actually define a server implementation class; that must be done separately. For example:</P>
<DL><DD><PRE>define custom-interface &lt;IWhatever&gt; (&lt;IUnknown&gt;) 
  // interface
  uuid &quot;{DC86922A-16C3-11D2-9A67-006097C90313}&quot;;
  property foo :: &lt;integer&gt;;
  function bar (a :: &lt;integer&gt;) <BR>    =&gt; (b :: &lt;string&gt;);
end custom-interface &lt;IWhatever&gt;;</PRE></DL>
<DL><DD><PRE>define COM-interface &lt;my-whatever&gt; (&lt;IWhatever&gt;)
  // implementation
  slot foo :: &lt;integer&gt;;
end COM-interface &lt;my-whatever&gt;;</PRE></DL>
<DL><DD><PRE>define method bar (this :: &lt;my-whatever&gt;, 
                   a :: &lt;integer&gt;)
    =&gt; (result :: &lt;SCODE&gt;, b :: &lt;string&gt;)
  ...
  values($S-OK, ...)
end method bar;</PRE></DL>
<P> The above defines a class <CODE>&lt;IWhatever&gt;</CODE> to represent a new COM interface, and a class <CODE>&lt;my-whatever&gt;</CODE> that provides an implementation of that interface.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>OLE, COM, ActiveX and DBMS Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inte_438.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
