<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inte_443.htm">
<LINK REL=PREV HREF="inte_447.htm">
<LINK REL=NEXT HREF="inte_449.htm">
<TITLE>6.5   Implementing local servers </TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING448></A>

<DIV>
<P><A HREF="inte_449.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_447.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_443.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>6 The OLE-Server Library</P>

</DIV>
<A NAME=HEADING448-0></A>
<A NAME=UID-ole-server-895958></A>
<H1>6.5   <A NAME=MARKER-2-1544></A><A NAME=MARKER-2-1545></A><A NAME=MARKER-2-1546></A>Implementing local servers </H1>
<P>To implement a local server, the basic structure of your application should be the same as any GUI application using the Microsoft Win32 API, with the following exceptions.</P>
<UL>
<LI>Define a subclass of <A HREF="inte_452.htm#MARKER-9-1562"><CODE>&lt;ole-server-framework&gt;</CODE></A> and implement the required Dylan methods described in <A HREF="inte_455.htm#MARKER-9-1576">Section 6.7.2 on page 273</A>. 
<LI>Make your application capable of self-registration with the Windows Registry. With self-registration, the application can record itself in the Registry as a server for the COM objects it implements. The OLE-Server contains utilities that make writing a self-registering local server application simpler. 
</UL>
<DL>
<DT><DD>Wrap the body of the server application with a call to the function <A HREF="inte_467.htm#MARKER-9-1616"><CODE>OLE-util-register-only?</CODE>,  page 283</A>, which will test whether the application was passed arguments requiring it to perform a registration operation. Depending on the result of the call, the application can either run as normal, or perform the requested registration operation and exit.
</DL>
<PRE>
  if (OLE-util-register-only?()) // just [un]register &amp; terminate
   register-ole-server(class-id, prog-id, title-string, 
                       short-name: short-name-string);
  else // actually run the program
  ...
  end if;
<P></P>
</PRE>
<DL>
<DT><DD>When the application is wrapped in this code, if it is run with the <CODE>/RegServer</CODE> option (typically done as part of an installation script), it will just register itself and terminate, or if run with the <CODE>/UnregServer</CODE> option, it will try to unregister itself and terminate. Otherwise, <A HREF="inte_467.htm#MARKER-9-1616"><CODE>OLE-util-register-only?</CODE></A> returns <CODE>#f</CODE> and the application continues to run normally.
</DL>
<UL>
<LI>Once it is past the self-registration wrapper, make your application call <A HREF="inte_506.htm#MARKER-9-1725"><CODE>OLE-util-started-by-OLE?</CODE>,  page 314</A> to find out if it has been invoked by an OLE container. If the function returns <CODE>#f</CODE>, your application should just run as an independent application. If the function returns <CODE>#t</CODE>, your application should not show any of its windows; support code in the OLE-Server library will take care of that at the appropriate time. 
<LI>If your application is running under OLE, then before it enters its event loop, it must make an instance of the Dylan class <A HREF="inte_516.htm#MARKER-9-1751"><CODE>&lt;class-factory&gt;</CODE>,  page 320</A>, passing it the application's COM Class ID and the Dylan object class to be instantiated -- that is, your subclass of <A HREF="inte_452.htm#MARKER-9-1562"><CODE>&lt;ole-server-framework&gt;</CODE></A>. 
</UL>
<DL>
<DT><DD>COM's class factories are a means of creating multiple instances of a particular COM class. Instantiating the class factory takes care of registering your server application as the process that will serve objects of the given COM class, so that the container can connect to it. 
<DT><DD>(This registration should not be confused with the registration procedure discussed earlier, which was for registering the application as a server for the COM class or classes it supports, so that the container knows which server application to run.)
</DL>
<UL>
<LI>When a container application connects to your server application, a single instance of your subclass is instantiated automatically by the class factory. The container will call <CODE>QueryInterface</CODE> on it to find the interfaces it needs. This object is the "controlling unknown" for all the low-level OLE interfaces; if necessary, your server could also call <CODE>QueryInterface</CODE> on it to obtain low-level interface pointers in order to extend the capabilities of the library.
<LI><A NAME=MARKER-10-1547></A>When your server application terminates, it should call <A HREF="inte_515.htm#MARKER-9-1748"><CODE>revoke-registration</CODE>,  page 319</A>, on the instance of <A HREF="inte_516.htm#MARKER-9-1751"><CODE>&lt;class-factory&gt;</CODE></A>.
<LI>If your application is activated in-place, you must call the function <A HREF="inte_509.htm#MARKER-9-1732"><CODE>OLE-util-translate-accelerator</CODE></A> within the event loop to properly handle the top-level menu. It is harmless to call it in other contexts. Note that the COM interface object is created while events are being processed, so it cannot simply be placed in a local variable before entering the loop.
<LI>If your application has created an interface object, then before it terminates (such as when responding to a <CODE>$WM-CLOSE</CODE> message), it must make sure that the interface is properly disconnected from the container. To do this, call the function <A HREF="inte_512.htm#MARKER-9-1740"><CODE>OLE-util-close-server</CODE></A> on the interface object. 
</UL>
<DL>
<DT><DD>Because the OLE-Server instantiates the COM interface object for your server automatically, rather than through calling <CODE>make</CODE> on your subclass of <A HREF="inte_452.htm#MARKER-9-1562"><CODE>&lt;ole-server-framework&gt;</CODE></A>, your application will not naturally have a name bound to the COM interface object upon which you can call <A HREF="inte_516.htm#MARKER-9-1751"><CODE>&lt;class-factory&gt;</CODE></A>. You must arrange to bind the instance to a name by defining an <CODE>initialize</CODE> method on your subclass of <A HREF="inte_452.htm#MARKER-9-1562"><CODE>&lt;ole-server-framework&gt;</CODE></A>.
</DL>
<UL>
<LI>Your application must have at least two windows: a top-level frame window (which includes the border and title bar), and a single child window that occupies the client area within the border, that is referred to as the <I>document window</I>. The document window can be subdivided into other child windows, but there must be a single window handle representing the whole client region. 
<LI>In stand-alone execution, your server application should use <CODE>ShowWindow</CODE> to display the frame window, as any Windows application would. For out-of-place activation under OLE, your application's frame window is not shown until the support library calls your application's <A HREF="inte_457.htm#MARKER-9-1582"><CODE>OLE-part-open-out</CODE></A> method. 
<LI>For in-place activation -- that is, activation as an embedded object -- the OLE-Server library calls the application's <A HREF="inte_456.htm#MARKER-9-1579"><CODE>OLE-part-doc-window</CODE></A> method to get the document window. The library then takes care of displaying the document window as a child of the container's window, and also automatically places a "hatch" border around it. Although the frame window is not used during in-place activation, it must still exist, to serve as the initial parent when creating the document window.
<LI>You must set up the code that actually draws to the document window by calling it from either of two contexts: in response to a <CODE>$WM-PAINT</CODE> message, or when the application's <A HREF="inte_458.htm#MARKER-9-1585"><CODE>OLE-part-draw-metafile</CODE></A> method is called to produce an image of the window that will be displayed by the container when the server is not active, and will be saved with the container's other data. 
<LI>If your application has state information other than its screen image, as it most likely will, it will need to provide methods for handling that data's persistent storage. Even if it does not have such information it must provide methods, though they can do nothing. See the entries for <A HREF="inte_461.htm#MARKER-9-1597"><CODE>OLE-part-Create-Streams</CODE></A>, <A HREF="inte_462.htm#MARKER-9-1600"><CODE>OLE-part-Open-Streams</CODE></A>, <A HREF="inte_463.htm#MARKER-9-1603"><CODE>OLE-part-Release-Streams</CODE></A>, <A HREF="inte_464.htm#MARKER-9-1606"><CODE>OLE-part-Save-To-Storage</CODE></A>, and <A HREF="inte_465.htm#MARKER-9-1609"><CODE>OLE-part-Load-From-Storage</CODE></A> in <A HREF="inte_455.htm#MARKER-9-1576">Section 6.7.2</A>.
</UL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>OLE, COM, ActiveX and DBMS Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inte_449.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_447.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_443.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
