<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inte_574.htm">
<LINK REL=PREV HREF="inte_576.htm">
<LINK REL=NEXT HREF="inte_578.htm">
<TITLE>9.3   C-to-Dylan name-mapping scheme</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING577></A>

<DIV>
<P><A HREF="inte_578.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_576.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_574.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>9 OLE FFI Facilities</P>

</DIV>
<A NAME=HEADING577-0></A>
<A NAME=UID-ole-com-889977></A>
<H1>9.3   <A NAME=MARKER-2-1953></A><A NAME=MARKER-2-1954></A><A NAME=MARKER-2-1955></A>C-to-Dylan name-mapping scheme</H1>
<P>This section describes the scheme Functional Objects used to map the C names in the Microsoft OLE/COM API to names fitting Dylan style and coding conventions. </P>
<UL>
<LI>Class and type names are enclosed in angle brackets. For example, <CODE>HRESULT</CODE> becomes <CODE>&lt;HRESULT&gt;</CODE>. For Dylan classes representing C pointers, the Dylan <CODE>=</CODE> operator compares the pointer addresses, and <CODE>==</CODE> is not likely to be useful. (Comparison of structure contents, where applicable, is done by the same functions as in the C API.) 
<LI>Names of constants are prefixed by a dollar sign ($). For example, <CODE>NOERROR</CODE> becomes <CODE>$NOERROR</CODE>. 
<LI>Underscores are replaced by hyphens. For example, <CODE>MAKE_HRESULT</CODE> becomes <CODE>MAKE-HRESULT</CODE> and <CODE>S_OK</CODE> becomes <CODE>$S-OK</CODE>. (However, hyphens are not inserted between capitalized words.)
<LI>Functions whose only effect is to return a true-or-false value have a question mark (?) appended to their names. For example: <CODE>SUCCEEDED?</CODE>, <CODE>FAILED?</CODE>, and <CODE>IsEqualIID?</CODE>.
<LI>Where an interface function is documented under a name such as, for example, <CODE>IClassFactory::CreateInstance</CODE>, the corresponding Dylan generic function is called <CODE>IClassFactory/CreateInstance</CODE>. This means that function names generally need to be qualified by their interface names in Dylan, although they are not in C or C++. This is necessary because there are several names that are used in different interfaces with incompatible argument lists, so that the same generic function cannot be used. However, for convenience, the following alias names are defined:
</UL>
<PRE>
  define constant QueryInterface = IUnknown/QueryInterface;
<P></P>
  define constant AddRef = IUnknown/AddRef;
<P></P>
  define constant Release = IUnknown/Release;
<P></P>
</PRE>
<UL>
<LI>Where a C/C++ function takes a pointer argument as a place to store a result value (when that value is a pointer or integer, not when filling in fields in a structure), the corresponding Dylan function uses multiple return values to return such output parameters following the original function return value. For example, where C++ code says:
</UL>
<PRE>
  status = obj-&gt;QueryInterface(IID_Ifoo, &amp; result);
<P></P>
</PRE>
<DL>
<DT><DD>the equivalent Dylan code is:
</DL>
<PRE>
  let ( status :: &lt;SCODE&gt;, result :: &lt;Interface&gt; ) =
    QueryInterface(obj,$IID-Ifoo);
<P></P>
</PRE>
<UL>
<LI>The multitude of integer data types in C code (<CODE>int</CODE>, <CODE>long</CODE>, <CODE>unsigned</CODE>, <CODE>ULONG</CODE>, <CODE>DWORD</CODE>, and so on) are all designated as <CODE>&lt;integer&gt;</CODE> (or some appropriate subrange thereof) in Dylan method argument types. However, in some cases, values that are too large to be represented as an <CODE>&lt;integer&gt;</CODE> are represented as a <CODE>&lt;machine-word&gt;</CODE> instead.
</UL>
<DL>
<DT><DD>The names <CODE>&lt;SCODE&gt;</CODE> and <CODE>&lt;HRESULT&gt;</CODE> are defined as Dylan data types because they are not used as integers even though they are implemented as such in C. (In Dylan, they are actually aliases for <CODE>&lt;machine-word&gt;</CODE>.)
</DL>
<UL>
<LI>The C type <CODE>BOOL</CODE> is mapped to <CODE>&lt;boolean&gt;</CODE> in Dylan. Use <CODE>#t</CODE> and <CODE>#f</CODE> instead of <CODE>TRUE</CODE> and <CODE>FALSE</CODE>.
<LI>Because slot names are not in a separate name space in Dylan, the names of C structure fields will have the suffix <CODE>-value</CODE> added to form the name of the Dylan accessor function. For example, the C statement:
</UL>
<PRE>
  pt-&gt;x = x;
<P></P>
</PRE>
<DL>
<DT><DD>becomes in Dylan:
</DL>
<PRE>
  pt.x-value := x;
<P></P>
</PRE>
<UL>
<LI>The class <CODE>&lt;Interface&gt;</CODE> is an abstract class that includes all OLE interfaces, regardless of whether they are implemented in C or Dylan. Thus this is the appropriate declared type for a variable holding an arbitrary interface, such as returned by <CODE>QueryInterface</CODE> or <CODE>CreateInstance</CODE>. Classes such as <CODE>&lt;LPUNKNOWN&gt;</CODE>, <CODE>&lt;LPOLECONTAINER&gt;</CODE>, <CODE>&lt;LPOLEOBJECT&gt;</CODE>, and so on represent specific interfaces which could be implemented in either C or Dylan; conceptually these are subclasses of <CODE>&lt;Interface&gt;</CODE>, but they are currently actually implemented as aliases of <CODE>&lt;Interface&gt;</CODE> instead of as distinct types. <A NAME=MARKER-10-1956></A>. The C-FFI library's function <CODE>pointer-cast</CODE> can be used to convert an <CODE>&lt;Interface&gt;</CODE> to one of the more specific types. The classes <CODE>&lt;IUnknown&gt;</CODE>, <CODE>&lt;IOleContainer&gt;</CODE>, <CODE>&lt;IOleObject&gt;</CODE>, and so on are subclasses used for interfaces implemented in Dylan. Thus, the class hierarchy looks (conceptually) like:
</UL>
<PRE>
   &lt;Interface&gt;
       |
    &lt;LPUNKNOWN&gt;
     /       \
    /       &lt;IUnknown&gt;
&lt;LPOLEOBJECT&gt;  /     \
   /   \      /       \
  /   &lt;IOleObject&gt;    ...
 ...       |
    &lt;my-OleObject&gt;
<P></P>
</PRE>
<DL>
<DT><DD>where <CODE>&lt;my-OleObject&gt;</CODE> represents a user-defined Dylan class that provides an implementation of the <CODE>IOleObject</CODE> interface. Classes <CODE>&lt;IUnknown&gt;</CODE> and <CODE>&lt;IOleObject&gt;</CODE> do not have any direct instances.
</DL>
<UL>
<LI>The function call <CODE>null-pointer(&lt;LP...&gt;)</CODE> is used to create a null pointer of a particular interface type, where C code would just use <CODE>NULL</CODE>. The constant <CODE>$NULL-interface</CODE> is provided as a null instance of type <CODE>&lt;Interface&gt;</CODE>, which is not otherwise directly instantiable. The function <CODE>null?</CODE> can be used to test whether an instance of <CODE>&lt;Interface&gt;</CODE> (or any other C pointer type) is null. It also returns <CODE>#t</CODE> if the argument is <CODE>#f</CODE>. It is not valid to use <CODE>null-pointer</CODE> on a Dylan implementation class (that is, any subclass of <CODE>&lt;IUnknown&gt;</CODE>).
</UL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>OLE, COM, ActiveX and DBMS Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inte_578.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_576.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_574.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
