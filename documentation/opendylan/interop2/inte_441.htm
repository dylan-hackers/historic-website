<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inte_436.htm">
<LINK REL=PREV HREF="inte_440.htm">
<LINK REL=NEXT HREF="inte_442.htm">
<TITLE> define dispatch-interface</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING441></A>

<DIV>
<P><A HREF="inte_442.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_440.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>5.3   Macros for defining custom interfaces</P>

</DIV>
<A NAME=HEADING441-0></A>
<H1> <A NAME=MARKER-2-1488></A><A NAME=MARKER-9-1489></A>define dispatch-interface</H1>
<P><I>Definition macro</I></P>
<H3>Summary</H3>
<P> Provides a simple way to implement a server for a COM class with dispatch via <CODE>IDispatch</CODE>.</P>
<H3>Macro call</H3>
<DL><DD><PRE>define dispatch-interface <I>interface-name</I> (<I>superclasses</I>)
<PRE>
  <EM>{</EM> <I>typelib-clause</I> <EM>|</EM> <I>property</I> <EM>|</EM> <I>function</I> <EM>}*</EM>
</PRE>
end <EM>[</EM>dispatch-interface<EM>]</EM> <EM>[<I>interface-name]</I></EM></PRE></DL>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>interface-name</I><DD> name<SUB>bnf</SUB> 
<P> </P><DT><I>superclasses</I><DD> name<SUB>bnf</SUB> 
<P> </P><DT><I>interface-name</I><DD> name<SUB>bnf</SUB> 
<P> </P><DT><I>typelib-clause</I> <DD>
</DL>
<DL><DD><PRE>  <EM>{</EM> uuid <I>string-or-REFGUID</I>; 
<EM>  |</EM> name <I>name</I>; 
  <EM>|</EM> documentation <I>documentation</I>;
  <EM>|</EM> help-file <I>help-file</I>; 
<EM>  |</EM> help-context <I>help-context</I>; 
  <EM>|</EM> major-version <I>major-version</I>; 
  <EM>|</EM> minor-version <I>minor-version</I>;
  <EM>|</EM> locale locale; 
  <EM>}</EM></PRE></DL>
<DL>
<P> </P><DT><I>property</I> <DD>
</DL>
<DL><DD><PRE>  <EM>{</EM> <I>slot-adjectives</I> slot <I>slot-name</I> <I>slot-stuff</I>;
  <EM>|</EM> constant property <I>property-name</I> <EM>[</EM> :: <I>property-type</I> <EM>]</EM> 
      <EM>[</EM> = <I>property-value</I> <EM>]</EM> <EM>{</EM> , <I>option</I> <EM>}*</EM> ;
  <EM>| [</EM> virtual <EM>]</EM> property <I>property-name</I> <EM>[</EM> :: <I>property-type</I> <EM>]</EM>
  <EM>{</EM> , <I>option</I> 
<EM>  |</EM> , <I>slot-option</I> <EM>}*</EM> ;
<EM>}</EM></PRE></DL>
<DL>
<P> </P><DT><I>function</I> <DD>
</DL>
<DL><DD><PRE>  function <I>member-name</I> 
    <EM>[</EM> ( <EM>{</EM> <I>argument-name</I> :: <I>argument-type</I> ,<EM>}*</EM> )
      <EM>[</EM> =&gt; ( <EM>[</EM> <I>result-name</I> :: <I>result-type</I> <EM>]</EM> ) <EM>]</EM>
    <EM>]</EM> <EM>{</EM> , <I>option</I> <EM>}*</EM> ;</PRE></DL>
<DL>
<P> </P><DT><I>option</I> <DD>
</DL>
<DL><DD><PRE>  <EM>{</EM> name: <I>name</I> 
<EM>  |</EM> disp-id: <I>disp-id</I> 
  <EM>|</EM> documentation: <I>documentation</I> 
  <EM>|</EM> help-context: <I>help-context</I> 
  <EM>}</EM></PRE></DL>
<H3>Library</H3>
<dl><dd><pre>OLE-Automation</pre></dl>
<H3>Module</H3>
<dl><dd><pre>OLE</pre></dl>
<H3>Description</H3>
<P> Used to create Dylan COM servers with dispatch interfaces. By using <CODE>define</CODE> <CODE>COM-interface</CODE>, a Dylan class <I>interface-name</I> is created to implement the server.</P>
<P> The <I>superclasses</I> list specifies the classes to inherit from. Either <CODE>&lt;simple-dispatch&gt;</CODE> or another server class defined with <CODE>define</CODE> <CODE>dispatch-interface</CODE> must be included in the superclass list. If another server class is included, the type information for this class inherits the type information from the superclass. </P>
<P> An instance of <CODE>&lt;disp-type-info&gt;</CODE> is created to represent the interface to the class. This value can be fetched by applying the function <CODE>type-information</CODE> to the class or to an instance of the class. Any supplied <CODE>typelib-clause</CODE> clauses are passed on as keywords to the call to <BR><CODE>make(&lt;disp-type-info&gt;),</CODE> which is used to create the type information.</P>
<P> <I>property</I> declarations correspond to slots in the class. <CODE>slot</CODE> defines a slot in the class (using the same syntax as slot declarations in class definitions), but does not create type information for it. Thus slots created with <CODE>slot</CODE> cannot be accessed by clients of the defined dispatch class. Slots defined with <CODE>property</CODE> do have corresponding information in the type library and can be accessed by clients. <CODE>virtual</CODE> properties only have type information, but no corresponding slot; getter and setter methods must be defined separately.</P>
<P> A constant <CODE>property</CODE> has no setter method, and must specify either a <I>property-value</I> or <I>property-type</I> or both. If a value is specified, then nothing further is needed to implement the property. Otherwise, a getter method will need to be defined separately.</P>
<P> <A NAME=MARKER-10-1490></A></P>
<P> The <I>property</I> clause has two extensions. The first extension allows a type declaration and an initialization expression, as in:</P>
<dl><dd><pre>property foo :: &lt;bar&gt; = baz(), ...;</pre></dl>
<P> The type and the init expression become the type and init of the underlying Dylan slot, and also become the defaults for the <CODE>type:</CODE> and <CODE>value:</CODE> options of the property.</P>
<P> The second extension to <I>property</I> is an option <CODE>property-setter</CODE>, which can be used to specify a function to use to implement the setting of the property:</P>
<dl><dd><pre>property foo, property-setter: external-foo-setter;</pre></dl>
<P> If <CODE>property-setter:</CODE> is not specified, then the <CODE>slot</CODE> setter is used.</P>
<P> <I>function</I> declarations cause a method description to be added to the type information for the class. The method must be defined separately. The method must accept an instance of <I>interface-name</I> and any additional arguments specified in the declaration. The method must return an <CODE>&lt;SCODE&gt;</CODE> instance describing the success or failure of the method, plus any other result specified (no more than one). </P>
<P> If the type of a property or a member function parameter list or result are not specified, they will be given default values from the definition of the implementing function, or the value of a constant property. C-FFI types may be used here in order to more precisely specify how the data will be represented in the interface. </P>
<P> While this macro is often used to directly implement a server, if you want to just define an abstract interface which could have multiple implementations, use only <CODE>virtual</CODE> <CODE>property</CODE> clauses instead of <CODE>slot</CODE> clauses, and define the slots in implementation subclasses defined by <CODE>define</CODE> <CODE>COM-interface</CODE>. </P>
<H3>Example</H3>
<P> An invocation of the macro looks much like a <CODE>Define</CODE> <CODE>class</CODE> or a <CODE>define</CODE> <CODE>dispatch-client</CODE> invocation:</P>
<DL><DD><PRE>define dispatch-interface &lt;blorf-server&gt; 
 (&lt;simple-dispatch&gt;)
  uuid &quot;{26d99e70-07ca-11d2-a3c5-0060b0572a7f}&quot;;
  property foo :: &lt;integer&gt;, 
                 disp-id: 7;
  function bar (a :: &lt;integer&gt;) 
    =&gt; (b :: &lt;string&gt;),
                 name: &quot;mBar&quot;;
end dispatch-interface &lt;blorf-server&gt;;</PRE></DL>
<DL><DD><PRE>define method bar (this :: &lt;blorf-server&gt;, 
                   a :: &lt;integer&gt;)
    =&gt; (result :: &lt;SCODE&gt;, b :: &lt;string&gt;)
  ...
  values($S-OK, ...)
end method bar;</PRE></DL>
<P> The above defines a class <CODE>&lt;blorf-server&gt;</CODE> to implement the COM interface described, and creates type information describing the interface.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>OLE, COM, ActiveX and DBMS Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inte_442.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_440.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_436.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_579.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
