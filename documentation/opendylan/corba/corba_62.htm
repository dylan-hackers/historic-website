<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="corba_1.htm">
<LINK REL=UP HREF="corba_57.htm">
<LINK REL=PREV HREF="corba_61.htm">
<LINK REL=NEXT HREF="corba_63.htm">
<TITLE>5.5   Implementing CORBA initialization for the bank client</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING62></A>

<DIV>
<P><A HREF="corba_63.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="corba_61.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="corba_57.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="corba_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="corba_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="corb_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>5 The Bank Client</P>

</DIV>
<A NAME=HEADING62-0></A>
<A NAME=UID-bank-client-891527></A>
<H1>5.5   <A NAME=MARKER-10-212></A>Implementing CORBA <A NAME=MARKER-2-213></A>initialization for the bank client</H1>
<P>Having written the client GUI we are now ready to set up the client's CORBA environment. A client can only communicate with a CORBA object if it possesses a reference to that object. This raises the question of how the client obtains its initial object reference. The fact that some IDL operation may return an object reference is of no help here: without a reference to specify as its target, there is no way to invoke this operation.</P>
<P>In more detail, before a client can enter the CORBA environment, it must first:</P>
<UL>
<LI>Be initialized into the ORB.
<LI>Get a reference to the ORB pseudo-object for use in future ORB operations.
<LI>Get an initial reference to an actual object on the server.
</UL>
<P>CORBA provides a standard set of operations, specified in <I>pseudo IDL</I> (PIDL), to initialize applications and obtain the appropriate object references. </P>
<P>Operations providing access to the ORB reside in the <CODE>CORBA</CODE> module. (Like an IDL interface declaration, an IDL (or PIDL) module declaration defines a new namespace for the body of declarations it encloses. What it does not do is define a new type of CORBA object.) Operations providing access to CORBA features such as Object Adapters, the Interface Repository, the Naming Service, and other Object Services reside in the <CODE>ORB</CODE> interface defined within the <CODE>CORBA</CODE> module. </P>
<P>To provide some flavor of PIDL, here is a fragment of the PIDL specification of <CODE>CORBA</CODE> that we rely on in our implementation of the bank client.</P>
<PRE>
module CORBA {

  interface Object { 
    boolean is_a (in string logical_type_id);
    ...
  };
<P></P>
  interface ORB { 
    string object_to_string (in Object obj);
    Object string_to_object (in string str);
    ...
  };
<P></P>
...
<P></P>
  typedef string ORBid;
  typedef sequence &lt;string&gt; arg_list;
  ORB ORB_init (inout arg_list argv, in ORBid orb_identifier);
};
<P></P>
</PRE>
<P>The <CODE>Object</CODE> interface is implicitly inherited by all IDL interfaces, much as every Dylan class inherits from the class <CODE>&lt;object&gt;</CODE>. The <CODE>is_a</CODE> operation provides a test for inheritance -- the <CODE>logical_type_id</CODE> is a string representation of an interface identifier. The operation returns true if the object is an instance of that interface, including if that interface is an ancestor of the most derived interface of that object. </P>
<P>The <CODE>ORB</CODE> operations <CODE>object_to_string</CODE> and <CODE>string_to_object</CODE> provide an invertible mapping from object references to their representations as strings. </P>
<P>Notice that the CORBA operation <CODE>ORB_init</CODE> is defined outside the scope of any interface, providing a means of bootstrapping into the CORBA world. Calling <CODE>ORB_init</CODE> initializes the ORB, returning an <CODE>ORB</CODE> pseudo object that can be used as the target for further ORB operations.</P>
<P>Like most other language bindings, the Dylan binding adopts the <I>pseudo objects</I> approach, in which these CORBA and ORB operations are accessed by applying the binding's normal IDL mapping rules to the PIDL specification.</P>
<P>In this tutorial, as in the Hello World example of <A HREF="corba_15.htm#MARKER-9-132">Chapter 2</A>, the client can obtain the initial object reference from a shared file, in which the server has published a reference to its implementation of the bank object, encoded as a string. After starting up, the client reads the file, decodes the string into an object reference (using the ORB utility operation <CODE>file_to_object</CODE>, which in turn uses <CODE>string_to_object</CODE>), and then uses this reference as the target of further operations. </P>
<P>Alternatively, this demonstration can also use a Name Service<A NAME=MARKER-2-214></A> to communicate the initial bank reference between the client and server. A Name Service acts as an intermediary, allowing the server to register a reference against <I>name</I>, and then allowing the client to query for the associated reference. To use the Name Service pass </P>
<PRE>
        -location-service:naming-service 
<P></P>
</PRE>
<P>on the command line of the client. </P>
<P>To change the command line arguments given to the program, choose the <B>Project &gt; Settings...</B> dialog and switch to the Debug tab page. By default the command line arguments for the Bank demo are </P>
<PRE>
-ORBname-service-file c:\temp\ns.ior -location-service:shared-file
<P></P>
</PRE>
<P>which tells the ORB where the Name Service is, but that it should use a shared file to pass the initial Bank reference.</P>
<P>Here is some the Dylan code that implements the initialization of the client:</P>
<PRE>
define method initialize-client ()
  let orb = CORBA/ORB-init(make(CORBA/&lt;arg-list&gt;), 
                        &quot;Functional Developer ORB&quot;);
  let ls = get-location-service();
  block ()
    let bank = lookup-bank(orb, ls);
    let bank-frame = make(&lt;bank-frame&gt;, bank: bank);
    start-frame(bank-frame);
  exception (lookup-bank-failure(orb, ls))
    notify-user(&quot;Cannot locate the Bank. Click OK to Exit.&quot;);
  end block;
end method;
<P></P>
</PRE>
<P>This method first initializes the Functional Developer ORB by calling the Dylan generic function <CODE>CORBA/ORB-init</CODE> corresponding to the PIDL <CODE>ORB_init</CODE> operation. (Note that the IDL module name <CODE>CORBA</CODE> forms a prefix of the Dylan operation name, and that IDL underscore "<CODE>_</CODE>" maps to a Dylan dash "<CODE>-</CODE>".) The first argument to this call evaluates to an empty <CODE>CORBA/&lt;arglist&gt;</CODE>. Passing an empty sequence instructs the <CODE>CORBA/ORB-init</CODE> function to ignore this argument and use the application's command line arguments (if any) instead. The value of the second argument, <CODE>&quot;Functional Developer Orb&quot;</CODE>, merely identifies the ORB to use. The call returns an object of class <CODE>CORBA/&lt;ORB&gt;</CODE>. </P>
<P>The function <CODE>get-location-service</CODE> reads the command line to see whether to look for a shared file or use a Name Service<A NAME=MARKER-2-215></A>. It then passes this information to the function <CODE>lookup-bank</CODE>, which knows how to get a bank reference using either method. For example, for the shared file case <CODE>lookup-bank</CODE> does the following: </P>
<PRE>
define method lookup-bank (orb :: corba/&lt;orb&gt;, 
                        location-service == #&quot;shared-file&quot;)
    =&gt; (bank :: bankingdemo/&lt;bank&gt;)
  as(BankingDemo/&lt;bank&gt;, corba/orb/file-to-object(orb, 
                                            $bank-ior-file));
end method;
<P></P>
</PRE>
<P>The constant <CODE>$bank-ior-file</CODE> is the name of the shared file used to pass the reference of the bank object from the server to the client. </P>
<P>Invoking <CODE>CORBA/ORB/file-to-object</CODE> on this ORB, passing the shared file name, reconstitutes the IOR string contained in the file as an unspecific object reference of class <CODE>CORBA/&lt;Object&gt;</CODE>. Calling the <CODE>as</CODE> method on this object reference narrows (that is, coerces) it to a more specific object reference of class <CODE>BankingDemo/&lt;bank&gt;</CODE>. (The <CODE>as</CODE> method, which is generated by the IDL compiler and defined in the Bank-Stubs library, employs an implicit call to the object's <CODE>is_a</CODE> operation to check that the desired coercion is safe.) </P>
<P>Finally, the resulting object reference <CODE>bank</CODE>, of class <CODE>BankingDemo/&lt;bank&gt;</CODE>, is used to make and start a new bank frame, displaying the initial GUI to the user.</P>
<P>The full implementation of the client initialization can be found in the file <CODE>init-client.dylan</CODE>.</P>
<P><A NAME=MARKER-10-216></A>The implementation of the client is now <A NAME=MARKER-2-217></A>complete.</P>
<P></P>
<A NAME=LINK-bank-client-lastpage></A><A NAME=LINK-bank-server-firstpage></A><!-- FM pgf ignored -->

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Developing Component Software with CORBA - 26 May 1999</ADDRESS>
<P><A HREF="corba_63.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="corba_61.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="corba_57.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="corba_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="corba_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="corb_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
