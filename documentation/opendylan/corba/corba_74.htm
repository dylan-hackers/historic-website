<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="corba_1.htm">
<LINK REL=UP HREF="corba_70.htm">
<LINK REL=PREV HREF="corba_73.htm">
<LINK REL=NEXT HREF="corba_75.htm">
<TITLE>6.5.4   Implementing the servant methods</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING74></A>

<DIV>
<P><A HREF="corba_75.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="corba_73.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="corba_70.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="corba_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="corba_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="corb_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>6.5   Requirements for implementing the bank server</P>

</DIV>
<A NAME=HEADING74-0></A>
<H1>6.5.4   Implementing the servant methods</H1>
<P>The next step in implementing the server is to define methods, specialized on the implementation classes, for each of the protocol functions corresponding to an IDL attribute or operation.</P>
<P>To support this, the abstract servant classes,</P>
<PRE>
BankingDemo/&lt;account-servant&gt;
BankingDemo/&lt;checkingAccount-servant&gt;
BankingDemo/&lt;bank-servant&gt; 
<P></P>
</PRE>
<P>are defined to inherit, respectively, from the abstract protocol classes </P>
<PRE>
BankingDemo/&lt;account&gt;
BankingDemo/&lt;checkingAccount&gt;
BankingDemo/&lt;bank-servant&gt;
<P></P>
</PRE>
<P>As a result, implementing a protocol function boils down to defining a concrete method for that function, where the method specializes on the implementation class of its target object. Recall that the target object of a protocol function is the first parameter to that function.</P>
<P>We can now present the implementations of the protocol functions. The <CODE>BankingDemo/account/name</CODE> method returns the value of the account's <CODE>name</CODE> slot:</P>
<PRE>
define method BankingDemo/account/name 
    (account :: &lt;account-implementation&gt;) 
    =&gt; (name :: CORBA/&lt;string&gt;)
  account.name;
end method BankingDemo/account/name;
<P></P>
</PRE>
<P>The <CODE>BankingDemo/account/balance</CODE> method retrieves the balance field from the corresponding record on the database by executing an SQL <CODE>select</CODE> statement:</P>
<PRE>
define method BankingDemo/account/balance 
    (account :: &lt;account-implementation&gt;) 
    =&gt; (balance :: CORBA/&lt;long&gt;)
  with-connection(account.bank.connection)
    let query = make(&lt;sql-statement&gt;,
                     text: &quot;select Balance  from Accounts &quot;
                           &quot;where Name = ?&quot;);
    let result-set = execute(query, 
                             parameters: vector(account.name));
    as(CORBA/&lt;long&gt;, result-set[0][0]);
  end with-connection;
end method BankingDemo/account/balance;
<P></P>
</PRE>
<P>The <CODE>BankingDemo/account/balance</CODE> method increments the record's balance field by executing an SQL <CODE>update</CODE> statement:</P>
<PRE>
define method BankingDemo/account/credit 
    (account :: &lt;account-implementation&gt;, 
     amount :: CORBA/&lt;unsigned-long&gt;)
    =&gt; () 
  with-connection(account.bank.connection)
    let amount = abs(amount);
    let query = make(&lt;sql-statement&gt;,
                     text: &quot;update Accounts &quot;
                           &quot;set Balance = Balance + ? &quot;
                           &quot;where Name = ?&quot;);
    execute(query, parameters: vector(as(&lt;integer&gt;, amount),
            account.name));
  end with-connection;
end method BankingDemo/account/credit;
<P></P>
</PRE>
<P>The <CODE>BankingDemo/account/debit</CODE> method executes an SQL <CODE>update</CODE> statement that decrements the record's balance field, provided the balance exceeds the desired amount:</P>
<PRE>
define method BankingDemo/account/debit 
    (account :: &lt;account-implementation&gt;, amount :: CORBA/&lt;long&gt;)
    =&gt; ()
  with-connection(account.bank.connection)
    let amount = abs(amount);
    let query = make(&lt;sql-statement&gt;,
                     text: &quot;update Accounts &quot;
                           &quot;set Balance = Balance - ? &quot;
                           &quot;where Name = ? and Balance &gt;= ?&quot;);
    execute(query, 
            parameters: vector(as(&lt;integer&gt;, amount),
                               account.name, 
                               as(&lt;integer&gt;, amount)));
  end with-connection;
end method BankingDemo/account/debit;
<P></P>
</PRE>
<P>The <CODE>BankingDemo/checkingAccount/limit</CODE> method is similar to the <CODE>BankingDemo/account/balance</CODE> method defined above:</P>
<PRE>
define method BankingDemo/checkingAccount/limit 
    (account :: &lt;checkingAccount-implementation&gt;)
    =&gt; (limit :: CORBA/&lt;long&gt;)
  with-connection(account.bank.connection)
    let query = make(&lt;sql-statement&gt;,
                     text: &quot;select Limit from Accounts &quot;
                           &quot;where Name = ?&quot;);
    let result-set = execute(query, 
                             parameters: vector(account.name));
    as(CORBA/&lt;long&gt;, result-set[0][0]);
  end with-connection;
end method BankingDemo/checkingAccount/limit;
<P></P>
</PRE>
<P>Because we defined <CODE>&lt;checkingAccount-implementation&gt;</CODE> to inherit from <CODE>&lt;account-implementation&gt;</CODE>, there is no need to re-implement the <CODE>BankingDemo/account/balance</CODE> and <CODE>BankingDemo/account/credit</CODE> methods for this implementation class. However, we do want to define a specialized <CODE>BankingDemo/account/debit</CODE> method, to reflect that a checking account can be overdrawn up to its limit:</P>
<PRE>
define method BankingDemo/account/debit 
    (account :: &lt;checkingAccount-implementation&gt;, 
     amount :: CORBA/&lt;long&gt;)
     =&gt; ()
  with-connection(account.bank.connection)
    let amount = abs(amount);
    let query = make(&lt;sql-statement&gt;,
                     text: &quot;update Accounts &quot;
                           &quot;set Balance = Balance - ? &quot;
                    &quot;where Name = ? and (Balance + Limit) &gt;= ?&quot;);
    execute(query, 
            parameters: vector(as(&lt;integer&gt;, amount),
                               account.name, as(&lt;integer&gt;,
                               amount)));
  end with-connection;
end method BankingDemo/account/debit;
<P></P>
</PRE>
<P>The <CODE>BankingDemo/bank/name</CODE> method returns the value of the bank's <CODE>name</CODE> slot:</P>
<PRE>
define method BankingDemo/bank/name 
    (bank :: &lt;bank-implementation&gt;) 
  =&gt; (name :: CORBA/&lt;string&gt;)
  bank.name;
end method BankingDemo/bank/name;
<P></P>
</PRE>
<P>The <CODE>BankingDemo/bank/openAccount</CODE> method illustrates how CORBA user exceptions are raised:</P>
<PRE>
define method BankingDemo/bank/openAccount 
    (bank :: &lt;bank-implementation&gt;, name :: CORBA/&lt;string&gt;)
    =&gt; (account :: BankingDemo/&lt;account&gt;)
  if (existsAccount?(bank, name))
    error (make(BankingDemo/bank/&lt;duplicateAccount&gt;));
  else
    begin 
      with-connection(bank.connection)
        let query = make(&lt;sql-statement&gt;,
              text: &quot;insert into Accounts(Name, Balance, Limit) &quot;
                    &quot;values(?, ?, ?)&quot;,
              input-indicator: #f);
        execute(query, parameters: vector(name, as(&lt;integer&gt;, 0),
                                   #f));
      end with-connection;
<P></P>
      let new-account = make(&lt;account-implementation&gt;, 
                             bank: bank, name: name);
      as(BankingDemo/&lt;account&gt;, 
         PortableServer/POA/servant-to-reference(bank.poa, 
                                                 new-account));
    end;
  end if;
end method BankingDemo/bank/openAccount;
<P></P>
</PRE>
<P>If the test <CODE>existsAccount?(bank,</CODE> <CODE>name)</CODE> succeeds, the call to </P>
<PRE>
error (make(BankingDemo/bank/&lt;duplicateAccount&gt;)); 
<P></P>
</PRE>
<P>raises a Dylan condition. (We omit the definition of <CODE>existsAccount?</CODE>, which can be found in the source.) Recall that the condition class <CODE>BankingDemo/bank/&lt;duplicateAccount&gt;</CODE> corresponds to the IDL <CODE>duplicateAccount</CODE> exception. The POA that invoked this method in response to a client's request will catch the condition and send the IDL <CODE>duplicateAccount</CODE> exception back to the client.</P>
<P>If there is no existing account for the supplied name, the <CODE>BankingDemo/bank/openAccount</CODE> method creates a new record in the database by executing an SQL <CODE>insert</CODE> statement, initializing the "Limit" field of this record with the SQL NULL value. (Recall that the presence of the NULL value serves to distinguish ordinary accounts from checking accounts on the database.)</P>
<P>Finally, the method makes a new servant of class <CODE>&lt;account-implementation&gt;</CODE>, registers it with the bank's POA with a call to <CODE>PortableServer/POA/servant-to-reference</CODE>, and narrows the resulting object reference to the more specific class <CODE>BankingDemo/&lt;account&gt;</CODE>, the class of object references to account objects, as required by the signature of the protocol function.</P>
<P>The <CODE>BankingDemo/bank/openCheckingAccount</CODE> method is similar, except that it initializes the <CODE>Limit</CODE> field of the new account record with the desired overdraft limit, and registers a new servant of class <CODE>&lt;checkingAccount-implementation&gt;</CODE>, returning an object reference of class <CODE>BankingDemo/&lt;checkingAccount&gt;</CODE>:</P>
<PRE>
define method BankingDemo/bank/openCheckingAccount 
    (bank :: &lt;bank-implementation&gt;, name :: CORBA/&lt;string&gt;, 
     limit :: CORBA/&lt;long&gt;)
    =&gt; (checkingAccount :: BankingDemo/&lt;checkingAccount&gt;)
  if (existsAccount?(bank, name))
    error (make(BankingDemo/bank/&lt;duplicateAccount&gt;));
  else    
    begin 
      with-connection(bank.connection)
        let limit = abs(limit);
        let query = 
          make(&lt;sql-statement&gt;,
              text: &quot;insert into Accounts(Name, Balance, Limit) &quot;
                    &quot;values(?, ?, ?)&quot;,
              input-indicator: #f);
        execute(query, parameters: vector(name, as(&lt;integer&gt;, 0),
                                          as(&lt;integer&gt;, limit)));
      end with-connection;
      let new-account = make(&lt;checkingAccount-implementation&gt;,
                             bank: bank, name: name);
<P></P>
</PRE>
<DL>
<DT><DD>(see next page)
</DL>
<PRE>
      as(BankingDemo/&lt;checkingAccount&gt;,
      PortableServer/POA/servant-to-reference(bank.poa, 
                                              new-account));
     end;
  end if;
end method BankingDemo/bank/openCheckingAccount;
<P></P>
</PRE>
<P>The <CODE>BankingDemo/bank/retrieveAccount</CODE> method uses the <CODE>name</CODE> parameter to select the <CODE>Limit</CODE> field of an account record. If there is no record with that name, indicated by the query returning an empty result set, the method raises the CORBA user exception <CODE>nonExistentAccount</CODE> by signalling the corresponding Dylan error.</P>
<P>Otherwise, the method uses the value of the <CODE>Limit</CODE> field to distinguish whether the account is an account or a current account, creating a new servant of the appropriate class:</P>
<PRE>
define method BankingDemo/bank/retrieveAccount 
    (bank :: &lt;bank-implementation&gt;, name :: CORBA/&lt;string&gt;)
    =&gt; (account :: BankingDemo/&lt;account&gt;)
  with-connection(bank.connection)
    let query = make(&lt;sql-statement&gt;,
                     text: &quot;select Limit from Accounts &quot;
                           &quot;where Name = ?&quot;,
                     output-indicator: #f);
    let result-set = execute(query, parameters: vector(name), 
                             result-set-policy: 
                               $scrollable-result-set-policy);
    if (empty? (result-set))
      error (make(BankingDemo/bank/&lt;nonExistentAccount&gt;));
    else if (result-set[0][0])
               as(BankingDemo/&lt;checkingAccount&gt;,
               PortableServer/POA/servant-to-reference(bank.poa,
                 make(&lt;checkingAccount-implementation&gt;,
                      bank: bank, 
                      name: name)));
          else 
            as(BankingDemo/&lt;account&gt;,
               PortableServer/POA/servant-to-reference(bank.poa,
                 make(&lt;account-implementation&gt;,
                      bank: bank,
                      name: name)));
          end if;
    end if;
  end with-connection;
end method BankingDemo/bank/retrieveAccount;
<P></P>
</PRE>
<P>(Unlike the other queries in this example, this query is executed with <CODE>result-set-policy:</CODE> <CODE>$scrollable-result-set-policy</CODE> to ensure that testing the emptiness of the result set does not invalidate its records.) </P>
<P>Finally, the <CODE>closeAccount</CODE> removes the record of an account from the database by executing an SQL <CODE>delete</CODE> statement:</P>
<PRE>
define method BankingDemo/bank/closeAccount 
    (bank :: &lt;bank-implementation&gt;, 
     account-reference :: BankingDemo/&lt;account&gt;)
    =&gt; ()
  let account = 
    Portableserver/POA/reference-to-servant(bank.poa,
                                            account-reference);
  with-connection(bank.connection)
    let query = make(&lt;sql-statement&gt;,
                     text: &quot;delete from Accounts &quot;
                           &quot;where Name = ?&quot;);
    execute(query, parameters: vector(account.name));
  end with-connection;
end method BankingDemo/bank/closeAccount;
<P></P>
</PRE>
<P>Note that we need to dereference the object reference <CODE>account</CODE> that is passed in as the parameter of the <CODE>BankingDemo/bank/closeAccount</CODE> operation. We call the <CODE>Portableserver/POA/reference-to-servant</CODE> operation of the POA to do so. Here, we make implicit use of our knowledge that, in our application, the server only encounters object references registered with its local POA. This assumption is not true in <A NAME=MARKER-2-236></A>general.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Developing Component Software with CORBA - 26 May 1999</ADDRESS>
<P><A HREF="corba_75.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="corba_73.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="corba_70.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="corba_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="corba_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="corb_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
