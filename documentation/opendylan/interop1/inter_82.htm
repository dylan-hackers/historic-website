<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inter_76.htm">
<LINK REL=PREV HREF="inter_81.htm">
<LINK REL=NEXT HREF="inter_83.htm">
<TITLE> define C-struct </TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING82></A>

<DIV>
<P><A HREF="inter_83.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_81.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_76.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>1.6   Defining types </P>

</DIV>
<A NAME=HEADING82-0></A>
<H1> <A NAME=MARKER-2-487></A><A NAME=MARKER-2-488></A>define C-struct </H1>
<P><I>Definition macro</I></P>
<H3>Summary</H3>
<P> Describes C's aggregate structures.</P>
<H3>Signature</H3>
<DL><DD><PRE>define C-struct <I>name</I> 
  [<I>slot-spec</I>; ...] [;]
  [<I>type-options</I>] [;]
end [C-struct] [<I>name</I>]</PRE></DL>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>name</I><DD> A Dylan variable name.
<P> </P><DT><I>slot-spec</I><DD> 
<P> </P><DT>t<I>ype-options</I><DD> A property list.
</DL>
<H3>Library</H3>
<P> <CODE>c-ffi</CODE></P>
<H3>Module</H3>
<P> <CODE>c-ffi</CODE></P>
<H3>Description</H3>
<P> Describes C's aggregate structures. The name is defined to be a designator class encapsulating the value of a structure, not a pointer to the structure. This is significant because many of the protocols associated with structures work only on pointers to structures -- pointers to structures being the most common form and the form closest to Dylan's object model. The new designator class is defined to be a subclass of <CODE><A NAME=MARKER-2-489></A><A NAME=MARKER-2-490></A>&lt;C-struct&gt;</CODE>. </P>
<P> Once defined, a structure-designating class is most likely to be used as the basis for a pointer type definition in terms of which most further transactions will take place. Structure-designating classes are abstract and cannot have direct instances. Accessor methods defined for the slots of the structure are specialized on the structure designator's pointer-type. However, the class itself may be needed to specify an in-line structure in another structure, union, or array, or a value-passed structure argument or result in a C function.</P>
<P> A slot-spec has the following syntax:</P>
<DL><DD><PRE>[<I>slot-adjective</I>] slot <I>getter-name</I> :: <I>c-type</I> #key <I>setter</I> 
  <I>address-getter</I> <I>c-name length</I> <I>width</I> </PRE></DL>
<P> The <EM>slot-adjective</EM> can be either <CODE>array</CODE> or <CODE>bitfield</CODE>. The <CODE>array</CODE> slot adjective indicates that the slot is repeated and the <EM>dimensions</EM> option is used to indicate how many repetitions are defined, and how it is accessed. The <CODE>bitfield</CODE> slot adjective indicates that the slot is really a bitfield. If <CODE>bitfield</CODE> is given then the <EM>width</EM> option must also be given. The <EM>c-type</EM> given for a <CODE>bitfield</CODE> slot must be an integer designator. The <EM>c-type</EM> for a <CODE>bitfield</CODE> slot indicates how the value is interpreted in Dylan by the slot accessor. A slot may not be specified as both an <CODE>array</CODE> and a <CODE>bitfield</CODE>.</P>
<P> The getter-name keyword specifies the name of the Dylan function to which the getter method for the structure slot will be added. The specializer of the getter method's single argument will be a designator indicating a pointer to the struct's name. </P>
<P> The c-type specifies the field's C type, and must be a designator class. Unlike Dylan slot specifications, the type declaration here is not optional.</P>
<P> The optional setter keyword specifies the generic function to which the setter method for the structure slot will be added. It defaults to getter-name<CODE>-setter</CODE>. No setter method is defined if the <EM>setter</EM> option is <CODE>#f</CODE>.</P>
<P> The optional <I>address-getter</I> specifies the name of a function that can be used to return a pointer to the data in the member. It must return a <CODE><A NAME=MARKER-2-491></A><A NAME=MARKER-2-492></A>&lt;C-pointer&gt;</CODE> object that points to a C type. No <I>address-getter</I> is defined by default.</P>
<P> You can use the <I>dimensions</I> keyword only if you used the <CODE>array</CODE> slot adjective. This <I>dimensions</I> value can be either a list of integers or a single integer. The accessor for an array slot is defined to take an extra integer parameter for each dimension given. <A NAME=MARKER-10-493></A></P>
<P> You can use the <EM>width</EM> keyword option only if you used the <CODE>bitfield</CODE> adjective.</P>
<P> The optional c-name keyword allows you to document the original C name of the slot.</P>
<P> The type-options clause is a property list allowing you to specify properties of the type as a whole. It accepts the optional keyword c-name:, allowing you to document the original C name of the struct to be documented. The optional keyword <CODE>pointer-type-name:</CODE> is also accepted. When given, the name is bound to the struct pointer type on which the accessors are defined.</P>
<P> The type option <CODE>pack:<EM> n</EM></CODE> indicates that the struct has the packing semantics of Microsoft's <CODE>#pragma</CODE> <CODE>pack(<EM>n)</EM></CODE>.</P>
<P>Example C declaration:</P>
<PRE>
struct Point {
  unsigned short x;
  unsigned short y;
};
<P></P>
Point *OnePoint();   /* Returns a pointer to a Point */
Point *PointArray(); /* Returns a Point array */
<P></P>
</PRE>
<DL>
<DT><DD>Example FFI definition:
</DL>
<PRE>
define C-struct &lt;Point&gt;
  slot x :: &lt;C-unsigned-short&gt;;
  slot y :: &lt;C-unsigned-short&gt;;
  pointer-type-name: &lt;Point*&gt;;
end C-struct;
<P></P>
define C-function one-point
  result point :: &lt;Point*&gt;;
  c-name: "OnePoint";
end C-function;
<P></P>
define C-function point-array
  result array :: &lt;Point*&gt;;
  c-name: "PointArray";
end C-function;
<P></P>
</PRE>
<DL>
<DT><DD>Example transactions:
</DL>
<PRE>
? define variable p = one-point();
// Defined p.
<P></P>
? values(p.x, p.y);
100
50
<P></P>
? define variable array = point-array();
// Defined array.
<P></P>
? array[5].object-class; // implicit conversion to 
                         // the pointer type
{&lt;Point&gt; pointer #xff5e00}
<P></P>
? begin array[5].x := 10; array[5].y := 20 end;
20
<P></P>
? values(array[5].x, array[5].y)
10
20
<P></P>
</PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>C FFI and Win 32 Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inter_83.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_81.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_76.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
