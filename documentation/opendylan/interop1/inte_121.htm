<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inte_118.htm">
<LINK REL=PREV HREF="inte_120.htm">
<LINK REL=NEXT HREF="inte_122.htm">
<TITLE>2.4.3   Mapping C types onto Dylan classes</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING121></A>

<DIV>
<P><A HREF="inte_122.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_120.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_118.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>2.4   Naming and mapping conventions</P>

</DIV>
<A NAME=HEADING121-0></A>
<H1>2.4.3   <A NAME=MARKER-2-634></A><A NAME=MARKER-2-635></A><A NAME=MARKER-2-636></A><A NAME=MARKER-2-637></A><A NAME=MARKER-2-638></A><A NAME=MARKER-2-639></A>Mapping C types onto Dylan classes</H1>
<P>The multitude of integer data types in C code (<CODE>int</CODE>, <CODE>long</CODE>, <CODE>unsigned</CODE>, <CODE>ULONG</CODE>, <CODE>DWORD</CODE>, <CODE>LRESULT</CODE>, and so on) are all designated as <CODE>&lt;integer&gt;</CODE> (or some appropriate subrange thereof) in Dylan method argument types. However, a <CODE>&lt;machine-word&gt;</CODE> needs to be used to represent values that do not fit in the signed 30-bit representation of an integer.</P>
<P>Names such as <CODE>&lt;DWORD&gt;</CODE> should not be used in application code because they refer to the FFI designation of the C value representation, not to a Dylan data type.</P>
<P>The C types <CODE>BOOL</CODE> and <CODE>BOOLEAN</CODE> are both mapped to <CODE>&lt;boolean&gt;</CODE> in Dylan. Use <CODE>#t</CODE> and <CODE>#f</CODE> instead of <CODE>TRUE</CODE> and <CODE>FALSE</CODE>. </P>
<P><B>Note:</B> Beware that some functions, such as <CODE>TranslateAccelerator</CODE>, though documented to return <CODE>TRUE</CODE> or <CODE>FALSE</CODE>, actually return <CODE>int</CODE> instead of <CODE>BOOL</CODE>; in such a case, you will have to compare the result to 0.<A NAME=MARKER-10-640></A></P>
<P>Similarly, watch out for cases where C code passes <CODE>TRUE</CODE> or <CODE>FALSE</CODE> as an integer argument. To handle one common case, the Dylan implementation of <CODE>MAKELPARAM</CODE> accepts either an <CODE>&lt;integer&gt;</CODE> or <CODE>&lt;boolean&gt;</CODE> as the first argument.</P>
<P>The C types <CODE>CHAR</CODE>, <CODE>WCHAR</CODE>, and <CODE>TCHAR</CODE> are all mapped to <CODE>&lt;character&gt;</CODE> in Dylan. However, <CODE>UCHAR</CODE> is mapped to <CODE>&lt;integer&gt;</CODE> since that is how it is actually used.</P>
<P>Most of the pointer types in the Windows API have several names; for example: <CODE>PRECT</CODE>, <CODE>NPRECT</CODE>, and <CODE>LPRECT</CODE>. In 16-bit code, these distinguished between "near" and "far" pointers, but in 32-bit code there is no difference. Rather than carry the duplicate names over into Dylan, it would be simpler to use only the basic <CODE>P...</CODE> prefix names. However, the <CODE>LP...</CODE> names seem to be used much more often, and hence may be more familiar, and the Microsoft documentation still tends to use the <CODE>LP...</CODE> names in most places. So the Dylan interface defines both the <CODE>&lt;P...&gt;</CODE> and <CODE>&lt;LP...&gt;</CODE> names even though they have identical values. The <CODE>NP...</CODE> names are not defined in Dylan since they are not as commonly used.</P>
<P>Values of type <CODE>char*</CODE> in C are represented as instances of class <CODE>&lt;C-string&gt;</CODE> in Dylan. This is a subclass of <CODE>&lt;string&gt;</CODE>, so all of the normal string operations can be used directly. C function parameters of type <CODE>char*</CODE> will also accept an instance of <CODE>&lt;byte-string&gt;</CODE>; a C pointer is created to point to the characters of the Dylan data, so the string does not need to be copied. (Dylan byte strings maintain a NUL character at the end in order to allow them to be used directly by C.)</P>
<P>in the current implementation, that involves automatically copying the string at run time, but the need for copying is intended to be removed later.</P>
<P>The <CODE>TEXT</CODE> function can also be used to coerce a string literal to a <CODE>&lt;C-string&gt;</CODE>. This usage is consistent with the Win32 <CODE>TEXT</CODE> macro, although the current purpose is different. </P>
<P>The Dylan declarations for C types will generally follow the <I>strict</I> alternative versions of the C declarations. This means, for example, that the various handle types such as <CODE>&lt;hmenu&gt;</CODE> and <CODE>&lt;hwnd&gt;</CODE> are disjoint subclasses of <CODE>&lt;handle&gt;</CODE>, instead of all being equivalent.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>C FFI and Win 32 Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inte_122.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inte_120.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inte_118.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
