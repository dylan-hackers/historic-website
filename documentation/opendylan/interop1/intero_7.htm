<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="intero_6.htm">
<LINK REL=PREV HREF="intero_6.htm">
<LINK REL=NEXT HREF="intero_8.htm">
<TITLE>1.2.1   C types in Dylan</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING7></A>

<DIV>
<P><A HREF="intero_8.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="intero_6.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="intero_6.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>1.2   Overview </P>

</DIV>
<A NAME=HEADING7-0></A>
<H1>1.2.1   <A NAME=MARKER-2-198></A><A NAME=MARKER-2-199></A>C types in Dylan</H1>
<P>When you use the interface definition language to describe a C type to the Dylan compiler, the compiler generates a new Dylan class. This class is said to <I>designate</I> the C type, which means that it carries with it the essential properties of the C type such as its size and alignment. </P>
<P>You can use this <A NAME=MARKER-2-200></A><I>designator class</I> in subsequent interface definition forms to specify which elements involve the designated C type. A designator class also carries with it the information on how to interpret the untyped C data as a tagged Dylan object. </P>
<P><A NAME=MARKER-10-201></A>The C-FFI library contains predefined designator classes for C's fundamental types like <CODE>int</CODE> and <CODE>double</CODE>. The names of these predefined Dylan classes are formed from the C name of the fundamental type being designated. The designator class name for a particular C type formed using Dylan's standard class-naming convention; it is prefixed with "C-", hyphenated if it contains more than one word, and enclosed in angle brackets. For example, the C-FFI library provides the class <CODE><A NAME=MARKER-2-202></A><A NAME=MARKER-2-203></A>&lt;C-int&gt;</CODE> to designate the C type <CODE>int</CODE>; it designates <CODE>double</CODE> by the class <CODE><A NAME=MARKER-2-204></A><A NAME=MARKER-2-205></A>&lt;C-double&gt;</CODE>, and <CODE>unsigned</CODE> <CODE>long</CODE> by the class <CODE><A NAME=MARKER-2-206></A><A NAME=MARKER-2-207></A>&lt;C-unsigned-long&gt;</CODE>. </P>
<P><B>Note:</B> Since Dylan variable names are compared without sensitivity to case, the capitalization of the "C" in the names above, and in other Dylan names appearing in this document, is not binding and can safely be ignored.</P>
<P>The C-FFI library also provides predefined classes designating pointers to C's fundamental numeric types. To do so, it adds a <CODE>*</CODE> to the fundamental C type designator. For example <CODE><A NAME=MARKER-2-208></A><A NAME=MARKER-2-209></A>&lt;C-double*&gt;</CODE> designates the C type <CODE>double</CODE> <CODE>*</CODE>. </P>
<P>The following is an example of defining and using designator classes. Suppose we have the following C struct:</P>
<PRE>
typedef struct {
  unsigned short x_coord; 
  unsigned short y_coord; 
} Point;
<P></P>
</PRE>
<P>We describe C structs to Dylan using the macro <CODE><A NAME=MARKER-2-210></A><A NAME=MARKER-2-211></A>define C-struct</CODE>:</P>
<PRE>
define C-struct &lt;Point&gt;
  slot x-coord :: &lt;C-unsigned-short&gt;;
  slot y-coord :: &lt;C-unsigned-short&gt;;
end C-struct;
<P></P>
</PRE>
<P>This form defines a new designator class <CODE><A NAME=MARKER-2-212></A><A NAME=MARKER-2-213></A>&lt;Point&gt;</CODE> for a structure type corresponding to the C type <CODE>Point</CODE>. We designate the types of the slots of <CODE>&lt;Point&gt;</CODE> using the Dylan classes designating the C types used in the definition of <CODE>Point</CODE>. In this case, both slots are of the C type <CODE>unsigned</CODE> <CODE>short</CODE> which is designated by the predefined class <CODE><A NAME=MARKER-2-214></A><A NAME=MARKER-2-215></A>&lt;C-unsigned-short&gt;</CODE>. The information about the C type <CODE>unsigned</CODE> <CODE>short</CODE> carried by this designator class allows the compiler to compute the size, alignment, and layout of the struct. The compiler records the struct's size and alignment and associates them with <CODE>&lt;Point&gt;</CODE>. The designator class <CODE>&lt;Point&gt;</CODE> can then be used in the definition of other types, functions, and variables. For example, we could describe </P>
<PRE>
typedef struct {
  Point start;
  Point end;
} LineSegment;
<P></P>
</PRE>
<P>like this:</P>
<PRE>
define C-struct &lt;LineSegment&gt;
  slot start :: &lt;Point&gt;;
  slot end   :: &lt;Point&gt;;
end C-struct;
<P></P>
</PRE>
<P>As well as acting as a static information carrier for use in other FFI definitions, a designator class can also be instantiable, in which case Dylan uses an instance of the designator class to represent an object of the C type it designates when that object is passed from the "C world" to the "Dylan world". </P>
<P><B>Note:</B> Only classes that designate C <A NAME=MARKER-2-216></A>pointer types can be instantiated in this way. Instances of C's fundamental numeric value types like <CODE>int</CODE>, <CODE>char</CODE>, and <CODE>double</CODE> are just converted to an equivalent Dylan object with the same value. The <CODE>&lt;Point&gt;</CODE> class is not an instantiable class in Dylan because there is nothing in Dylan that corresponds to a C struct. However, the C-FFI does provide a Dylan representation of a pointer to a C struct.</P>
<P>To illustrate, here is an example interaction involving a C struct containing some pointer-typed slots and some slots whose types are fundamental numeric types:</P>
<PRE>
define C-struct &lt;Example&gt;
  slot count        :: &lt;C-int&gt;;
  slot statistic    :: &lt;C-double&gt;;
  slot data         :: &lt;C-char*&gt;;
  slot next         :: &lt;Example*&gt;;
  pointer-type-name :: &lt;Example*&gt;;
end C-struct;
<P></P>
</PRE>
<P>This example defines the two designator types <CODE>&lt;Example&gt;</CODE> and <CODE>&lt;Example*&gt;</CODE>; the slots <CODE>count</CODE> and <CODE>statistic</CODE> have fundamental numeric types while <CODE>data</CODE> and <CODE>next</CODE> have pointer types. The getter and setter methods for the slots are defined for instances of <CODE>&lt;Example*&gt;</CODE>. </P>
<P>Suppose there is a function <CODE>current-example</CODE> that returns an initialized <CODE>&lt;Example*&gt;</CODE> struct. The following transactions illustrate what you get when you read the slots of the structure it returns:</P>
<PRE>
? define variable example = current-example();
// Defined example 
<P></P>
? example.count;
4
<P></P>
? instance?(example.count, &lt;integer&gt;);
#t
<P></P>
? example.statistic;
10.5
<P></P>
? instance?(example.statistic, &lt;float&gt;);
#t
<P></P>
</PRE>
<P>The interactions above show that if we access structure slots that were defined as being of one of C's fundamental numeric types, we get a Dylan number of the equivalent value. The same thing happens if an imported C function returns a fundamental numeric type: a Dylan number with the same value appears in Dylan. Similarly, when setting slots in structs expecting numbers or passing objects out to C functions expecting numeric arguments, you should provide a Dylan number, and the C-FFI will convert it automatically to its C equivalent.</P>
<PRE>
? example.data;
{&lt;C-char&gt; pointer #xff5e00}
<P></P>
? instance?(example.data, &lt;C-char*&gt;);
#t
<P></P>
? example.next;
{&lt;Example&gt; pointer #xff5f00}
<P></P>
? instance?(example.next, &lt;Example*&gt;);
#t
<P></P>
</PRE>
<P>The interactions above show that accessing structure slots with a pointer type results in an instance of the Dylan class that designates that type. Again, the same thing happens if an imported C function returns a pointer type: an instance of the corresponding designator class is created. Similarly, when setting slots in structs expecting pointers or passing objects out to C functions expecting pointer arguments, you should provide an instance of the Dylan designator class for that pointer type, and the C-FFI will convert it automatically to the raw C pointer value.</P>
<P>Later sections describe all the macros available for defining C types and the functions available for manipulating them.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>C FFI and Win 32 Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="intero_8.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="intero_6.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="intero_6.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
