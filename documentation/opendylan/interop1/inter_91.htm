<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inter_85.htm">
<LINK REL=PREV HREF="inter_90.htm">
<LINK REL=NEXT HREF="inter_92.htm">
<TITLE> define C-callable-wrapper</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING91></A>

<DIV>
<P><A HREF="inter_92.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_90.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_85.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>1.7   Functions</P>

</DIV>
<A NAME=HEADING91-0></A>
<H1> <A NAME=MARKER-2-530></A><A NAME=MARKER-2-531></A>define C-callable-wrapper</H1>
<P><I>Definition macro</I></P>
<H3>Summary</H3>
<P> Makes a Dylan function callable from C by describing a C contract for the function.</P>
<H3>Signature</H3>
<DL><DD><PRE>define C-callable-wrapper [<I>dylan-rep-name] <BR></I>  of <I>dylan-function</I> 
  [<I>parameter-spec</I>; ...] [;]
  [<I>result-spec</I>] [;]
  [<I>function-options</I>][;]
end [C-callable-wrapper]</PRE></DL>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>dylan-rep-name</I><DD> A Dylan variable name.
<P> </P><DT><I>dylan-function</I><DD> An instance of <CODE>&lt;function&gt;</CODE>.
<P> </P><DT><I>parameter-spec</I><DD> 
<P> </P><DT><I>result-spec</I><DD> 
<P> </P><DT><I>function-options</I><DD> A property list.
</DL>
<H3>Library</H3>
<P> <CODE>c-ffi</CODE></P>
<H3>Module</H3>
<P> <CODE>c-ffi</CODE></P>
<H3>Description</H3>
<P> Makes a Dylan function callable from C by describing a C contract for the function. In order to generate a correct C-callable function wrapper, the same information about the function must be given as would be needed by C callers, typically provided by <CODE>extern</CODE> declarations for the function in a C header file: the types of its parameters and results.</P>
<P> The result of processing a <CODE><A NAME=MARKER-2-532></A><A NAME=MARKER-2-533></A>define C-callable-wrapper</CODE> definition is a function with a C entry point with the contract described. This function takes C values as arguments, converting them to Dylan representations according to the types declared for the parameters of the C function before calling the Dylan function with them. If the C function was described as returning results, the results of the call to the Dylan function are converted to C representations according to the declared types of those results before being returned to the C caller of the function.</P>
<P> The <EM>dylan-function</EM> is a Dylan function that accepts the correct number of parameters, and is called by the C callable wrapper.</P>
<P> The function-options are a property list. This list may contain a string value for the c-name keyword. If a c-name is specified, that name is made visible to C as the name of the generated <CODE>C-callable wrapper </CODE>function. Given a compatible <CODE>extern</CODE> declaration, this allows C code to call Dylan code simply by invoking a named function. The <CODE>export:</CODE> option takes the values <CODE>#t</CODE> or <CODE>#f</CODE> and indicates whether the c-name for the generated <CODE>C-callable-wrapper</CODE> function is to be exported from the library's <CODE>.dll</CODE>. <CODE>#t</CODE> means it is exported,<CODE> #f </CODE>means it is not. The default is #f. The <CODE>c-modifiers:</CODE> option is the same as in the <CODE>c-function</CODE> macro, except that the modifiers apply to the C function wrapper which is generated. See <A HREF="inter_89.htm#MARKER-9-515"><CODE>define C-function</CODE>,  page 48</A>.</P>
<P> If dylan-rep-name is specified, it is bound to an instance of a function-pointer designator class identifying the generated C-callable wrapper function. You can pass this pointer to C code for use as, for example, a callback. </P>
<P> A parameter-spec has the following syntax:</P>
<dl><dd><pre>[<I>adjectives</I>] parameter name :: <I>c-type</I> #key <I>c-name</I> </pre></dl>
<P> If no parameters are specified, the C function is taken to have no arguments.</P>
<P> An adjective can be <CODE>input</CODE>, <CODE>output</CODE>, or both. The calling discipline is specified by the <CODE>input</CODE> and <CODE>output</CODE> adjectives. </P>
<P> If a parameter is <CODE>output</CODE>, the corresponding parameter is not passed to the Dylan function, but the Dylan function is expected to return an extra value that is placed in the location pointed to by the parameter. When the pointer is NULL, the extra value from the Dylan function is ignored. The type designated for the parameter must be a pointer type.</P>
<P> If a parameter is both <CODE>input</CODE> and <CODE>output</CODE>, the parameter must be a pointer type, and the value accepted by the Dylan function is the result. <A HREF="inter_33.htm#MARKER-9-358"><CODE>The functions pointer-value and pointer-value-setter perform the primitive Dylan-to-C and C-to-Dylan conversions as documented with the designator class of the pointer's contents type (see Table 1.1). The C-FFI signals an error if it cannot convert the object you attempt to store in the pointer to a compatible type.</CODE></A> on that pointer. The Dylan function is expected to return an extra value which is placed into the location specified by the pointer passed to the C function. If the pointer passed to the C function is <CODE>NULL</CODE>, then the value passed to the Dylan function will be <CODE>#f</CODE>, and the extra value returned will be ignored.</P>
<P> There is currently no way to define a C-callable function that accepts a variable number of arguments. </P>
<P> A result-spec has the following syntax:</P>
<dl><dd><pre>result name :: <I>c-type</I> </pre></dl>
<P> If no <CODE>result</CODE> is specified, the C function defined does not return a value. It is defined as what in C terminology is known as a <I>void</I> function.</P>
<P>Example C declarations:</P>
<PRE>
/* Compute the length of a string */
int strlen(char *string);
<P></P>
/* Set the given locations to values, returning an
   error code */
<P></P>
int fill_locations(int *loc1, int* loc2);
<P></P>
/* Read at most as far as indicated in max_then_read,
   updating it to contain how much was actually read */
<P></P>
void read_stuff(int *max_then_read);
<P></P>
</PRE>
<P>Example FFI definitions:</P>
<PRE>
define method dylan-strlen (string) =&gt; (length) ... end;
<P></P>
define C-callable-wrapper of dylan-strlen
  parameter string :: &lt;C-char*&gt;;
  result    value  :: &lt;C-int&gt;;
  c-name: &quot;strlen&quot;;
end C-function;
<P></P>
define method dylan-fill-locations () 
 =&gt; (return-code :: &lt;integer&gt;, 
     val1 :: &lt;integer&gt;, 
     val2 :: &lt;integer&gt;) 
...
end;
<P></P>
define C-callable-wrapper of dylan-fill-locations
  output parameter loc1 :: &lt;C-int*&gt;;
  output parameter loc2 :: &lt;C-int*&gt;;
  result return-code    :: &lt;C-int&gt;;
  c-name: &quot;fill_locations&quot;;
end C-function;
<P></P>
define method dylan-read-stuff (max :: &lt;integer&gt;) =&gt;
  (read :: &lt;integer) ... 
end;
<P></P>
define C-callable-wrapper of dylan-read-stuff
  input output parameter max-then-read :: &lt;C-int*&gt;;
  c-name: &quot;read_stuff&quot;;
end C-function;
<P></P>
</PRE>
<P>Example C calls:</P>
<PRE>
{
  int length, *loc1, *loc2, max_then_read;
<P></P>
  length = strlen("ABC");
<P></P>
  fill_locations(loc1, loc2);
<P></P>
  max_then_read = 100
  read_stuff(&amp;max_then_read);
}
<P></P>
</PRE>
<P>In effect, a <CODE><A NAME=MARKER-2-534></A><A NAME=MARKER-2-535></A>define C-callable-wrapper</CODE> such as:</P>
<PRE>
define C-callable-wrapper of foo
  parameter string :: &lt;C-char*&gt;;
  parameter count  :: &lt;C-int&gt;;
  result    value  :: &lt;C-int&gt;;
  c-name: &quot;foo&quot;;
end C-function;
<P></P>
</PRE>
<P>expands into something like:</P>
<PRE>
%c-callable-function &quot;foo&quot; (c-string, c-count)
    let dylan-string 
      = %as-dylan-representation(&lt;C-char*&gt;, c-string);
    let dylan-count
      = %as-dylan-representation(&lt;C-int&gt;, c-count);
    let dylan-result 
      = foo(dylan-string, dylan-count);
    %as-c-representation(&lt;C-int&gt;, dylan-result);
  end;
<P></P>
</PRE>
<DL>
<DT><DD>where the <CODE>%</CODE> functions perform the primitive conversions between Dylan and C representations, checking that their arguments are compatible with the declared type.
<DT><DD>Callback example:
</DL>
<PRE>
? define C-function c-sort
    parameter strings     :: &lt;C-string*&gt;;
    parameter compare     :: &lt;C-function-pointer&gt;;
    result sorted-strings :: &lt;C-string*&gt;;
    c-name: &quot;sort&quot;;
  end C-function;
<P></P>
// Defined c-sort.
<P></P>
? define C-callable-wrapper callback-for-&lt; of \&lt;
    parameter string1 :: &lt;C-string&gt;;
    parameter string2 :: &lt;C-string&gt;;
    result    int     :: &lt;C-int&gt;;
  end C-callable-wrapper;
<P></P>
// Defined callback-for-&lt;
<P></P>
? callback-for-&lt;
{function pointer #xff6e00}
? c-sort(some-c-strings, callback-for-&lt;);
{&lt;C-string&gt; array}
<P></P>
</PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>C FFI and Win 32 Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inter_92.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_90.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_85.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
