<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inter_85.htm">
<LINK REL=PREV HREF="inter_88.htm">
<LINK REL=NEXT HREF="inter_90.htm">
<TITLE> define C-function</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING89></A>

<DIV>
<P><A HREF="inter_90.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_88.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_85.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>1.7   Functions</P>

</DIV>
<A NAME=HEADING89-0></A>
<H1> <A NAME=MARKER-2-513></A><A NAME=MARKER-2-514></A><A NAME=MARKER-9-515></A>define C-function</H1>
<P><I>Definition macro</I></P>
<H3>Summary</H3>
<P> Describes a C function to the <CODE>c-ffi</CODE>.</P>
<H3>Signature</H3>
<DL><DD><PRE>define C-function <I>name</I> 
  [<I>parameter-spec</I>; ...]
  [<I>result-spec</I>;]
  [<I>function-option</I>, ...;]
end [C-function] [<I>name</I>]</PRE></DL>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>name</I><DD> A Dylan variable name.
<P> </P><DT><I>parameter-spec</I><DD> 
<P> </P><DT><I>result-spec</I><DD> 
<P> </P><DT><I>function-option</I><DD> A property list.
</DL>
<H3>Library</H3>
<P> <CODE>c-ffi</CODE></P>
<H3>Module</H3>
<P> <CODE>c-ffi</CODE></P>
<H3>Description</H3>
<P> Describes a C function to the C-FFI. In order for a C function to be called correctly by Dylan, the same information about the function must be given as is needed by C callers, typically provided by <CODE>extern</CODE> declarations for the function in a C header file: the function's name and the types of its parameters and results.</P>
<P> The result of processing a <CODE><A NAME=MARKER-2-516></A><A NAME=MARKER-2-517></A>define C-function</CODE> definition is a Dylan function which is bound to name. This function takes Dylan objects as arguments, converting them to their C representations according to the types declared for the parameters of the C function before calling the C function with them. If the C function returns results, these results are converted to Dylan representations according to the declared types of those results before being returned to the Dylan caller of the function. By default the function created is a raw method, not a generic function. A generic function method can defined by using the <CODE>generic-function-method:</CODE> option.</P>
<P> Either the <CODE>c-name:<EM> </EM></CODE>function option must be supplied, or the <CODE>indirect:</CODE> option must be supplied with a value other than <CODE>#f</CODE>, but not both.</P>
<P> A parameter-spec has the following syntax:</P>
<dl><dd><pre>[<I>adjectives</I>] parameter name :: <I>c-type</I> #key <I>c-name</I> </pre></dl>
<P> If no parameters are specified, the C function is taken to have no arguments.</P>
<P> The adjectives can be either <CODE>output</CODE>, <CODE>input</CODE>, or both. The calling discipline is specified by the <CODE>input</CODE> and <CODE>output</CODE> adjectives.</P>
<P> By itself, <CODE>input</CODE> indicates that the argument is passed into the function by value. This option is the default and is used primarily to document the code. There is a parameter to the generated Dylan function corresponding to each <CODE>input</CODE> parameter of the C function.</P>
<P> The <CODE>output</CODE> adjective specifies that the argument value to the C function is used to identify a location into which an extra result of the C function will be stored. There is no parameter in the generated Dylan function corresponding to an <CODE>output</CODE> parameter of the C function. The C-FFI generates a location for the extra return value itself and passes it to the C function. When the C function returns, the value in the location is accessed and returned as an extra result from the Dylan function. The C-FFI allocates space for the output parameter's referenced type, passes a pointer to the allocated space, and returns <CODE>pointer-value </CODE>of that pointer. A struct or union type may not be used as an output parameter.</P>
<P> Example of <CODE>output</CODE> parameter definition:</P>
<DL><DD><PRE>  define C-function mix-it-up
    output parameter out1 :: &lt;some-struct*&gt;;
    output parameter out2 :: &lt;C-int*&gt;;
    result value :: &lt;C-int&gt;;
    c-name: &quot;mix_it_up&quot;;
  end C-function mix-it-up;</PRE></DL>
<P> Example transaction:</P>
<DL><DD><PRE>  ? mix-it-up();
  1
  {&lt;some-struct&gt; pointer #xfefe770}
  42
<P> If both <CODE>input </CODE>and <CODE>output</CODE> are supplied, they specify that the argument value to the C function is used to identify a location from which a value is accessed and into which an extra result value is placed by the C function. There is a parameter to the generated Dylan function corresponding to each <CODE>input output</CODE> parameter of the C function that is specialized as the union of the export type of the referenced type of the type given for the parameter in <CODE><A NAME=MARKER-2-518></A><A NAME=MARKER-2-519></A>define c-function</CODE>, and <CODE>#f</CODE>. When the C function returns, the value in the location is accessed and returned as an extra result from the Dylan function. If an <CODE>input</CODE> <CODE>output</CODE> parameter is passed as <CODE>#f</CODE> from Dylan then a <CODE>NULL</CODE> pointer is passed to the C function, and the extra value returned by the Dylan function will be <CODE>#f</CODE>.</P>
<P> Example of <CODE>input</CODE> <CODE>output</CODE> parameter definition: </P>
<DL><DD><PRE>  define C-function mix-it-up
    input output parameter inout :: &lt;C-int*&gt;;
    result value :: &lt;C-int&gt;;
    c-name: &quot;mix_it_up&quot;;
  end C-function mix-it-up;</PRE></DL>
<P> Example transaction:</P>
<DL><DD><PRE>? mix-it-up(7);
1 
14</PRE></DL>
<P> Note that neither <CODE>output</CODE> nor <CODE>input output </CODE>affects the declared type of an argument: it must have the same type it has in C and so, because it represents a location, must be a pointer type. </P>
<P> <A NAME=MARKER-10-520></A>A result-spec has the following syntax:</P>
<dl><dd><pre>  result [name :: c-type] </pre></dl>
<P> If no <CODE>result</CODE> is specified, the Dylan function does not return a value for the C result, and the C function is expected to have a return type of <CODE>void</CODE>.</P>
<P> Each <EM>function-option</EM> is a keyword-value pair. The <CODE>generic-function-method:</CODE> option may be either <CODE>#t</CODE> or <CODE>#f</CODE>, indicating whether to add a method to the generic function name or to bind a bare constant method directly to name. The default value for <CODE>generic-function-method:</CODE> is <CODE>#f</CODE>. The option <CODE>C-modifiers:</CODE> can be used to specify platform dependent modifiers for the C function being called. For example, on Windows, use <CODE>C-modifiers:</CODE> <CODE>&quot;__stdcall&quot;</CODE> if the C function to be called is defined to be a <CODE>__stdcall</CODE> function.</P>
<P> The <CODE>c-name:</CODE> option is used to specify the name of the C function as it is defined in the object or shared library file. The <I>c-name</I> must be a constant string.</P>
<P> The <CODE>indirect:</CODE> <CODE>#t</CODE> option defines a function that accepts a C function pointer as its first argument and calls the function given with the signature described by the parameters and result given. In this case the Dylan function defined accepts one more argument than if <I>c-name</I> was given. The type specified for the first parameter of the Dylan function is <BR><CODE><A NAME=MARKER-2-521></A><A NAME=MARKER-2-522></A>&lt;c-function-pointer&gt;</CODE>. One of <I>c-name</I> or <CODE>indirect:</CODE> <CODE>#t</CODE> must be supplied, but not both.</P>
<P>Example C declarations:</P>
<PRE>
/* Compute the length of a string */
int strlen(char *string);
<P></P>
/* Set the given locations to values, 
   returning an error code */
int fill_locations(int *loc1, int* loc2);
<P></P>
/* Read at most as far as indicated in max_then_read,
   updating it to contain how much was actually read */
<P></P>
void read_stuff(int *max_then_read);
<P></P>
</PRE>
<DL>
<DT><DD>Example FFI definitions:
</DL>
<PRE>
define C-function strlen
  parameter string :: &lt;C-char*&gt;;
  result    value  :: &lt;C-int&gt;;
  c-name: &quot;strlen&quot;;
end C-function;
<P></P>
define C-function fill-locations
  output parameter loc1 :: &lt;C-int*&gt;;
  output parameter loc2 :: &lt;C-int*&gt;;
  result return-code    :: &lt;C-int&gt;;
  c_name: &quot;fill_locations&quot;;
end C-function;
<P></P>
define C-function read-stuff
  input output parameter :: &lt;C-int*&gt;;
  c-name: &quot;read_stuff&quot;;
end C-function;
<P></P>
</PRE>
<P>Example transactions:</P>
<PRE>
? strlen($my-c-string);
44
<P></P>
? fill-locations();
0
101 // extra output value
102 // extra output value
<P></P>
? read-stuff(100);
50 // extra output value
<P></P>
</PRE>
<P>In effect, a <CODE><A NAME=MARKER-2-523></A><A NAME=MARKER-2-524></A>define C-function</CODE> such as:</P>
<PRE>
define C-function foo
  parameter string :: &lt;C-char*&gt;;
  parameter count  :: &lt;C-int&gt;;
  result    value  :: &lt;C-int&gt;;
  c-name: &quot;foo&quot;;
end C-function;
<P></P>
</PRE>
<P>expands into something like:</P>
<PRE>
define constant foo =
  method (string, count)
    let c-string = %as-c-representation(&lt;C-char*&gt;,
                                        string);
    let c-count = %as-c-representation(&lt;C-int&gt;, count);
    let c-result = %call-c-function(&quot;foo&quot;, c-string,
                                    c-count);
    %as-dylan-representation(&lt;C-int&gt;, c-result);
end;
<P></P>
</PRE>
<DL>
<DT><DD>with the declared type.
</DL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>C FFI and Win 32 Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inter_90.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_88.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_85.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
