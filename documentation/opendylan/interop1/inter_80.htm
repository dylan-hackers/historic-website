<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="intero_1.htm">
<LINK REL=UP HREF="inter_76.htm">
<LINK REL=PREV HREF="inter_79.htm">
<LINK REL=NEXT HREF="inter_81.htm">
<TITLE> define C-mapped-subtype</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING80></A>

<DIV>
<P><A HREF="inter_81.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_79.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_76.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>1.6   Defining types </P>

</DIV>
<A NAME=HEADING80-0></A>
<H1> <A NAME=MARKER-2-475></A><A NAME=MARKER-2-476></A>define C-mapped-subtype</H1>
<P><I>Definition macro</I></P>
<H3>Summary</H3>
<P> Allows you to define a name to which to bind a pointer designator.</P>
<H3>Signature</H3>
<DL><DD><PRE>define <I>modifiers</I> C-mapped-subtype <I>type-name</I> (<I>superclasses</I>)
  [map <I>high-level-type</I>  [, import-function: <I>import-fun</I>]
                    [, export-function: <I>export-fun</I>];]
  [import-map <I>high-level-type</I>, 
   import-function: <I>import-function</I>;]
  [export-map <I>high-level-type</I>, 
   export-function: <I>export-function</I>;]
   [type-options]
end</PRE></DL>
<H3>Arguments</H3>
<DL>
<P> </P><DT><I>modifiers</I><DD> The same as the modifiers allowed in <CODE>define-class</CODE>.
<P> </P><DT><I>type-name</I><DD> A Dylan variable name.
<P> </P><DT><I>superclasses</I><DD> A list of Dylan names.
<P> </P><DT><I>high-level-type</I><DD> An instance of <CODE>&lt;function&gt;</CODE>.
<P> </P><DT><I>import-fun</I><DD> An instance of <CODE>&lt;function&gt;</CODE>.
<P> </P><DT><I>export-fun</I><DD> An instance of <CODE>&lt;function&gt;</CODE>.
<P> </P><DT><CODE>type-options</CODE><DD> A property list.
</DL>
<H3>Library</H3>
<P> <CODE>c-ffi</CODE></P>
<H3>Module</H3>
<P> <CODE>c-ff</CODE>i</P>
<H3>Description</H3>
<P> Allows you to define a name to which to bind a pointer designator.</P>
<P> The <I>modifiers</I> may be <CODE>sealed</CODE> or <CODE>open</CODE>. (The default is <CODE>sealed</CODE>.) Their effect on the class defined is the same as the similar modifiers on an ordinary class.</P>
<P> The possible combinations are, a map clause, an import-map clause, an export-map clause, or both an import-map and an export-map clause. Any other combinations are illegal.</P>
<P> The <CODE>import-map</CODE> clause specifies that a type conversion takes place when <EM>type-name</EM> is used as a designator for values imported from C into Dylan. The conversion is accomplished by calling the <EM>import-function</EM> on the imported value. This call is automatically inserted into function wrappers, structure member getters, pointer-value dereference functions and so on by the C-FFI. The <EM>high-level-type</EM> is used as the Dylan type specifier for the appropriate parameter or result in any wrapper function or <CODE>c-struct</CODE> accessor which uses the defined class. The <CODE>export-map</CODE> clause specifies a similar type conversion for exported values. The <I>high-level-type<EM> </EM></I>must in either case name an instantiable Dylan type.</P>
<dl><dd><pre>  map &lt;type-c&gt;;</pre></dl>
<P> is equivalent to:</P>
<DL><DD><PRE>  import-map &lt;type-c&gt;;
  export-map &lt;type-c&gt;;</PRE></DL>
<P> The import and export functions are monadic functions whose single argument is the appropriate low-level value for export functions and the appropriate Dylan type for import functions. Any mapped subtype which specifies an import-map must specify an <I>import-function</I>. Any mapped subtype which specifies an export-map must specify an <I>export-function</I>.</P>
<P>Map boolean example:</P>
<PRE>
bool-header.h:
<P></P>
typedef int bool;
<P></P>
bool bool_function (bool b);
void bool_pointer_function (bool *b);
<P></P>
//eof
<P></P>
Module: my-module
<P></P>
define C-mapped-subtype &lt;bool&gt; (&lt;C-int&gt;)
  map &lt;boolean&gt;,
    export-function: 
      method (v :: &lt;boolean&gt;) =&gt; (result :: &lt;integer&gt;)
        as(&lt;integer&gt;, if(v) 1 else 0 end if) end,
    import-function: 
      method (v :: &lt;integer&gt;) =&gt; (result :: &lt;boolean&gt;)
       ~zero?(v) end;
end;
<P></P>
//end module
<P></P>
</PRE>
<P>Mapped string example: an alternate version of C-string which automatically converts instances of <CODE><A NAME=MARKER-2-477></A><A NAME=MARKER-2-478></A>&lt;byte-string&gt;</CODE> to instances of <CODE><A NAME=MARKER-2-479></A><A NAME=MARKER-2-480></A>&lt;C-example-string&gt;</CODE> on export.</P>
<PRE>
<A NAME=MARKER-10-481></A>string-header.h
<P></P>
typedef char *string;
<P></P>
string string-filter(string s);
void string-modifier(string *s);
<P></P>
//eof
<P></P>
module: my-module
<P></P>
define C-mapped-subtype &lt;C-example-string&gt; (&lt;C-char*&gt;,
                                            &lt;string&gt;)
  export-map type-union(&lt;byte-string&gt;, 
                        &lt;C-example-string&gt;),
  export-function: c-string-exporter;
end;
<P></P>
define method c-string-exporter
  (s :: &lt;byte-string&gt;) =&gt; (result :: &lt;C-char*&gt;)
    as(&lt;C-example-string&gt;, s)
end;
<P></P>
define method c-string-exporter 
  (s :: &lt;C-example-string&gt;) =&gt; (result :: &lt;C-example-string&gt;)
    s
end;
<P></P>
//end module
<P></P>
</PRE>
<P>It is possible to define an ordinary subtype of a mapped supertype. The mapping characteristic of the subtype is inherited from the supertype. It is also possible to define a mapped subtype of a mapped supertype. When the subtype and supertype both specify an export function, the export functions of the subtype and the supertype are composed with the subtype's export function applied to the result of the supertype's export function. Import functions of a mapped subtype and supertype are similarly composed. Mapping characteristics are inherited from the supertype where the subtype does not define them. (You can think of this as composition with identity when either the supertype or subtype fails to specify an import or export function.) This shadowing is only useful when import and export maps are defined separately. Here is an example of a mapped subtypes which adds an import map to the mapped version of <CODE>&lt;C-example-string&gt;</CODE> defined above.</P>
<PRE>
define C-mapped-subtype &lt;other-string&gt; 
    (&lt;C-example-string&gt;)
  import-map &lt;byte-string&gt;, 
    import-function: method (v :: &lt;byte-string&gt;) =&gt;
      (result :: &lt;C-example-string&gt;)
        as(&lt;C-example-string&gt;, v)
      end method;
end;
<P></P>
</PRE>
<P>The import signature is <CODE><A NAME=MARKER-2-482></A><A NAME=MARKER-2-483></A>&lt;byte-string&gt;</CODE>. The export signature is inherited from <CODE>&lt;C-example-string&gt;</CODE> <CODE>type-union(&lt;byte-string&gt;,</CODE> <CODE>&lt;C-example-string&gt;)</CODE>. For a example involving composition of mapped types consider the following (hypothetical) definitions of <CODE>&lt;C-raw-int&gt;</CODE>, <CODE>&lt;C-mapped-int&gt;</CODE> and <CODE>&lt;bool&gt;</CODE>. The <CODE>&lt;C-raw-int&gt;</CODE> class is a primitive which returns and accepts instances of <CODE>&lt;machine-word&gt;</CODE>. The <CODE>&lt;C-mapped-int&gt;</CODE> class is a mapped subtype which converts the instances of <CODE>&lt;machine-word&gt;</CODE> to instances of <CODE>&lt;integer&gt;</CODE>. The <CODE>&lt;bool&gt;</CODE> class is a mapped subtype of <CODE>&lt;C-mapped-int&gt;</CODE> which converts to and from <CODE>&lt;boolean&gt;</CODE>.</P>
<PRE>
define C-mapped-subtype &lt;C-mapped-int&gt; (&lt;C-raw-int&gt;)
  map &lt;boolean&gt;,
    export-function: 
      method (v :: &lt;integer&gt;) =&gt; 
        (result :: &lt;machine-word&gt;)
          as(&lt;machine-word&gt;, v) end,
    import-function: 
      method (v :: &lt;machine-word&gt;) =&gt; 
        (result :: &lt;integer&gt;)
          as(&lt;integer&gt;, v) end;
end;
<P></P>
define C-mapped-subtype &lt;bool&gt; (&lt;C-mapped-int&gt;)
  map &lt;boolean&gt;,
    export-function: 
      method (v :: &lt;boolean&gt;) =&gt; (result :: &lt;integer&gt;)
        if(v) 1 else 0 end if) end,
    import-function: 
      method (v :: &lt;integer&gt;) =&gt; (result :: &lt;boolean&gt;)
        ~zero?(v) end;
end;
<P></P>
</PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>C FFI and Win 32 Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="inter_81.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="inter_79.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="inter_76.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="intero_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="intero_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="inte_152.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
