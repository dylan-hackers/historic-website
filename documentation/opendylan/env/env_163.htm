<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="env_1.htm">
<LINK REL=UP HREF="env_157.htm">
<LINK REL=PREV HREF="env_162.htm">
<LINK REL=NEXT HREF="env_164.htm">
<TITLE>8.3   Optimizing the Reversi application</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING163></A>

<DIV>
<P><A HREF="env_164.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="env_162.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="env_157.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="env_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="env_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="env_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>8 Dispatch Optimization Coloring in the Editor</P>

</DIV>
<A NAME=HEADING163-0></A>
<A NAME=UID-coloring-891038></A>
<H1>8.3   Optimizing the Reversi application</H1>
<P>In this section we look at the dispatch optimization color information for part of the Reversi application and see what we can do to optimize it. </P>
<P>Before doing that, we should build the Reversi application in Production mode so we know that the application has been optimized as much as possible. </P>
<DL>
<DT><DD>1.  Open the Reversi project.
<DT><DD>2.  Choose <B>Project &gt; Settings</B> and, on the Compile page, set the compilation mode to "Production mode".
<DT><DD>3.  Choose <B>Project &gt; Clean Build</B>.
<DT><DD>4.  When the build is complete, go to the Sources page and open the file <CODE>game.dylan</CODE>.
<DT><DD>An editor window showing <CODE>game.dylan</CODE> appears.
<DT><DD>5.  In the editor window, turn on the <B>View &gt; Color Dispatch Optimizations</B> check item.
</DL>
<P>We can now see color information showing how dispatch optimizations were or were not carried out during the last build.</P>
<DL>
<DT><DD>6.  Go to the definition of the method <CODE>&lt;reversi-game&gt;</CODE>.
<DT><DD>You can use <B>Edit &gt; Find</B> or the "binoculars" toolbar button to do this.
</DL>
<P>This is the definition of <CODE>&lt;reversi-game&gt;</CODE>:</P>
<PRE>
define class &lt;reversi-game&gt; (&lt;object&gt;)
  slot reversi-game-board :: &lt;reversi-board&gt; 
    = make(&lt;reversi-board&gt;);
  slot %player :: &lt;player&gt; = #&quot;black&quot;,
    init-keyword: player:;
  slot %players :: &lt;integer&gt; = 1,
    init-keyword: players:;
  slot black-algorithm :: &lt;algorithm&gt; 
    = default-algorithm-for-player(#&quot;black&quot;),
    init-keyword: black-algorithm:;
  slot white-algorithm :: &lt;algorithm&gt; 
    = default-algorithm-for-player(#&quot;white&quot;),
    init-keyword: white-algorithm:;
  slot reversi-game-update-callback :: &lt;function&gt; = always(#f),
    init-keyword: update-callback:;
  slot reversi-game-message-function :: false-or(&lt;function&gt;) 
    = #f, init-keyword: message-function:;
end class &lt;reversi-game&gt;;
<P></P>
</PRE>
<P>There are three different colorings in this definition. The call to the function <CODE>always</CODE>, a Dylan language built-in function, is in light gray. That means the call has been eliminated completely from the compiled application. A call to the function <CODE>always</CODE> is defined to return a function object that always returns the value passed in the call to <CODE>always</CODE>. So here, the function object would always return <CODE>#f</CODE>. Unsurprisingly, the compiler evaluated this call completely, avoiding the need for run-time method dispatch. </P>
<P>The two calls to <CODE>default-algorithm-for-player</CODE>, a Reversi application method from <CODE>algorithms.dylan</CODE>, are colored in blue, signifying that the compiler managed to determine precisely which method to call, and inserted a direct call to that method in the compiled application. Again, the need for run-time method dispatch was averted. </P>
<P>Investigation shows that there is only one method on <CODE>default-algorithm-for-player</CODE>, which makes blue optimization simple here. The generic function for <CODE>default-algorithm-for-player</CODE> is defined implicitly, in the single <CODE>define</CODE> <CODE>method</CODE> <CODE>default-algorithm-for-player</CODE> call. Recall from the DRM (chapter 6) that implicitly defined generic functions are sealed by default. That fact allows the compiler to conclude that this method is the only method there will ever be on <CODE>default-algorithm-for-player</CODE>, making the optimization possible.</P>
<P>The third coloring is magenta, in the call to <CODE>make</CODE> on <CODE>&lt;reversi-board&gt;</CODE>, in the <CODE>reversi-game-board</CODE> slot definition. Here, then, is a generic function call that was not optimized. Magenta coloring means that for this call to <CODE>make</CODE>, the compiler could not determine the complete set of methods from which it could attempt to select the appropriate method to call. We will now make changes to the Reversi sources to optimize this call. </P>
<P>The problem here is that the compiler cannot be sure that additional methods on <CODE>make</CODE> might not be added at run time. By defining a sealed domain on make for <CODE>&lt;reversi-board&gt;</CODE>, we can clear this up.</P>
<DL>
<DT><DD>7.  Add the following to <CODE>game.dylan</CODE>:
</DL>
<PRE>
define sealed domain make(subclass(&lt;reversi-board&gt;));
<P></P>
</PRE>
<P>With this information, the compiler knows it has access to the complete set of methods on <CODE>make</CODE> for this class, and therefore can attempt to do the method selection itself.</P>
<P>We can recompile the application to see what effect our change has had.</P>
<DL>
<DT><DD>8.  Save <CODE>game.dylan</CODE> with <B>File &gt; Save</B>.
<DT><DD>9.  Rebuild the application, and refresh the color information for <CODE>game.dylan</CODE> with <B>View &gt; Refresh</B>. 
</DL>
<P>The refreshed coloring shows the call to <CODE>make</CODE> on <CODE>&lt;reversi-board&gt;</CODE> in the <CODE>reversi-game-board</CODE> slot definition in light gray. This coloring means that the compiler determined which <CODE>make</CODE> method to call, computed the result of the call--a <CODE>&lt;reversi-board&gt;</CODE> object--and inlined the object.</P>
<P>Looking further down <CODE>game.dylan</CODE>, notice that the definition of <CODE>reversi-game-size-setter</CODE> also calls <CODE>make</CODE> on <CODE>&lt;reversi-board&gt;</CODE>, a call that is also colored light gray.</P>
<P>We can now look at other possible optimizations in <CODE>game.dylan</CODE>.</P>
<DL>
<DT><DD>10.  Go to the definition of the method <CODE>initialize-board</CODE>.
</DL>
<P>The definition of <CODE>initialize-board</CODE> is:</P>
<PRE>
define method initialize-board (board :: &lt;reversi-board&gt;) =&gt; ()
  let squares = reversi-board-squares(board);
  for (square from 0 below size(squares))
    squares[square] := #f
  end;
  for (piece in initial-pieces(board))
    let square = piece[0];
      squares[square] := piece[1]
  end;
end method initialize-board;
<P></P>
</PRE>
<P>In this method there is a green-colored call to <CODE>reversi-board-squares</CODE> on the parameter <CODE>board</CODE>, an instance of <CODE>&lt;reversi-board&gt;</CODE>. Green coloring denotes an access to a slot whose position in a class is fixed. This optimization was possible because the <CODE>reversi-board-squares</CODE> method is just the implicitly defined accessor for the slot <CODE>reversi-board-squares</CODE>: </P>
<PRE>
define class &lt;reversi-board&gt; (&lt;object&gt;)
  slot reversi-board-size :: &lt;integer&gt; = $default-board-size,
    init-keyword: size:;
  slot reversi-board-squares :: &lt;sequence&gt; = #[];
end class &lt;reversi-board&gt;;
<P></P>
</PRE>
<P><A NAME=MARKER-10-621></A>The compiler achieved this optimization because it knew three things. First, it knew that the generic function implicitly defined by the accessor method was sealed. (As normal Dylan methods, accessor methods implicitly define a generic function if one does not already exist; such a generic function is sealed because implicitly defined generic functions are sealed by default.) Second, the compiler knew the type of <CODE>board</CODE> in the call to the accessor method. Third, the compiler knew that the class <CODE>&lt;reversi-board&gt;</CODE> was sealed, because classes are sealed by default. </P>
<P>We can now move on to some other optimization. The call <CODE>size(squares)</CODE> in <CODE>initialize-board</CODE> is colored in magenta. There are several similar magenta colorings in <CODE>game.dylan</CODE>, where the compiler could not optimize a method call on the value returned from <CODE>reversi-board-squares</CODE>: calls to <CODE>element</CODE>, <CODE>element-setter</CODE>, <CODE>empty?</CODE>, and <CODE>size</CODE>. In all cases this is because the type of <CODE>reversi-board-squares</CODE> is <CODE>&lt;sequence&gt;</CODE>, which is an open class. </P>
<P>We could seal domains on <CODE>&lt;sequence&gt;</CODE> to get optimizations here. But the DRM defines <CODE>&lt;sequence&gt;</CODE> as an open class, and it is not good practice to seal protocols that do not belong to your library or libraries. However, we can change the type of <CODE>reversi-board-squares</CODE> to be in a domain which is already sealed. Changing the slot type to <CODE>&lt;simple-object-vector&gt;</CODE> gives us a sealed type as well as preserving the protocol in use, so that we do not have to change any of the calls being made. </P>
<DL>
<DT><DD>11.  Go to the definition of <CODE>&lt;reversi-board&gt;</CODE>.
<DT><DD>12.  Change the type of <CODE>reversi-board-squares</CODE> to be <CODE>&lt;simple-object-vector&gt;</CODE>.
<DT><DD>13.  Save <CODE>game.dylan</CODE> with <B>File &gt; Save</B>.
<DT><DD>14.  Rebuild the application, and refresh the color information for <CODE>game.dylan</CODE> with <B>View &gt; Refresh</B>. 
<DT><DD>15.  Go back to the definition of <CODE>initialize-board</CODE>.
</DL>
<P>The <CODE>size(squares)</CODE> call is now colored green. Green coloring means the compiler determined that the call was equivalent to a slot access--particularly, an access to slot having a fixed offset from the memory address at which its class is located. The compiler removed the need for run-time method dispatch by replacing the call with code to access the location that would contain the slot value. </P>
<P>This particular optimization was possible because <CODE>size</CODE> is a slot accessor for instances of <CODE>&lt;simple-object-vector&gt;</CODE>, and, of course, because <CODE>&lt;simple-object-vector&gt;</CODE> is sealed.</P>
<P>You could examine the effects of this change on other calls that use the return value of <CODE>reversi-board-squares</CODE>. Some calls turn blue. Some calls to <CODE>element-setter</CODE> remain magenta because the compiler does not know the type of the index. Constraining the type of the index would improve such a call, turning it <A NAME=MARKER-2-622></A>blue or <A NAME=MARKER-2-623></A>even dark gray (inlined).</P>
<P><A NAME=MARKER-10-624></A></P>
<A NAME=LINK-coloring-lastpage></A><A NAME=LINK-delivery-firstpage></A><!-- FM pgf ignored -->

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Getting Started with Functional Developer - 31 MAR 2000</ADDRESS>
<P><A HREF="env_164.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="env_162.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="env_157.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="env_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="env_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="env_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
