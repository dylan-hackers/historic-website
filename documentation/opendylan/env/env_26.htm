<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="env_1.htm">
<LINK REL=UP HREF="env_25.htm">
<LINK REL=PREV HREF="env_25.htm">
<LINK REL=NEXT HREF="env_27.htm">
<TITLE>2.3.1   Searching the stack backtrace for the cause of the error</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING26></A>

<DIV>
<P><A HREF="env_27.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="env_25.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="env_25.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="env_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="env_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="env_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>2.3   Problems at run time </P>

</DIV>
<A NAME=HEADING26-0></A>
<H1>2.3.1   <A NAME=MARKER-9-235></A>Searching the stack backtrace for the cause of the error</H1>
<P>In this section we examine the backtrace and see what events led up to the unhandled exception.</P>
<P>Looking at the top of the backtrace, we can see that the most recent call activity in the Reversi master thread concerned catching the unhandled exception and invoking the debugger. The calls to <CODE>primitive_invoke_debugger</CODE>, <CODE>default-handler</CODE>, and <CODE>error</CODE> were all part of this. But if we move down the backtrace to the point below the call to <CODE>error</CODE>, we can examine the sequence of calls that led to the unhandled exception and find out how to fix the error.</P>
<P>The first interesting call for us is the one to <CODE>write-element</CODE>. This is the last of the calls appearing in the stack frame that Reversi made before the unhandled exception.</P>
<DL>
<DT><DD>1.  Select the call frame for <CODE>write-element</CODE>.
</DL>
<P>The source code definition of <CODE>write-element</CODE> appears in the pane opposite. This source code pane is read only; if we wanted to edit a definition shown in it we would click on the Edit Source (<IMG ALIGN=TOP SRC=editsrc.gif>) button above the source code pane, which would open the file containing the definition in an editor window.</P>
<P>Looking at the source code for <CODE>write-element</CODE>, the green arrow icon points to an assignment to <CODE>sb.buffer-next</CODE>. Here, the green arrow is showing the point at which execution would resume in that call frame if the application's execution was continued. What we do not know is whether the preceding call, to <CODE>coerce-from-element</CODE>, returned. It may be that the call failed (because the arguments were not what <CODE>coerce-from-element</CODE> was expecting) or that it succeeded but does not appear in the stack pane because of the default filtering. </P>
<P>To work out what has happened, we can examine the stack pane filtering with the filtering drop-down list.</P>
<DL>
<DT><DD>2.  Choose "Filtered frames" from the stack pane filtering drop-down list (which by default is set to "Filtered visible frames").
<DT><DD>The stack pane updates itself.
</DL>
<P>The six settings available from the stack pane <A NAME=MARKER-2-236></A>filtering drop-down list provide a quick way of changing what you view in the stack pane: </P>
<DL>
<DT>All frames<DD><P> Shows all frames in the thread being debugged</P>
<DT>All visible frames<DD><P> <BR>Shows all the frames in the thread that are part of the module's context, in this case the reversi module's context, which includes calls to any functions imported from other modules</P>
<DT>All local frames<DD><P> Shows all frames defined in the current (reversi) module</P>
<DT>Filtered frames<DD><P> Shows a filtered list of function calls in the thread being debugged</P>
<DT>Filtered visible frames<DD><P> <BR>Shows a filtered list of function calls in the current module plus calls to functions imported from any other modules used</P>
<DT>Filtered local frames<DD><P> <BR>Shows a filtered list of function calls from the current module only </P>
</DL>
<P>The "Filtered..." settings do not, by default, show foreign function calls, cleanup frames, and frames of unknown type, whereas the "All..." settings show everything. You can set the filtering rules using <B>View &gt; Debugger Options...</B>, see <A HREF="env_147.htm#MARKER-9-561">"Stack options" on page 129</A> for details.</P>
<P> <A NAME=MARKER-10-237></A><IMG ALIGN=TOP SRC=unfilterederrstack2-0.gif></P>
<P>Figure 2.5   Stack pane showing call frames from all modules.</P>
<P>So the question is whether the call to <CODE>coerce-from-element</CODE> failed, or whether it succeeded, but comes from a module that Reversi does not explicitly use. The stack pane now shows a frame for the call to <CODE>coerce-from-element</CODE>. The name has the suffix <CODE>streams-internals:streams</CODE>. This means that <CODE>coerce-from-element</CODE> is a name from the <CODE>streams-internals</CODE> module of the <CODE>streams</CODE> library.</P>
<P>This <I>name</I>:<I>module</I>:<I>library</I> form of printing Dylan names is used in a number of different places in Functional Developer. It shows that <I>name</I> is not part of the module, or module and library, that a tool is currently focused on. (The debugger and browser both have a toolbar pop-up where you can change the current module.) </P>
<P>Returning to our example, we now know that <CODE>write-element</CODE>'s call to <CODE>coerce-from-element</CODE> succeeded, because it created a call frame. We can see that <CODE>coerce-from-element</CODE> is now the last frame on the stack before the call to <CODE>error</CODE>.</P>
<DL>
<DT><DD>3.  Select the call frame for <CODE>coerce-from-element</CODE>.
</DL>
<P>The green arrow in the source code definition for <CODE>coerce-from-element</CODE> points to an assignment containing a call to <CODE>byte-char-to-byte</CODE>. Notice that this call does not appear in the backtrace. Because the backtrace is now showing call frames from all modules, we know that the exception must have been raised while attempting to call this function, before a call frame was created for it.</P>
<P>Since the error dialog told us that the exception was caused by something being of the wrong type, there is a good chance that the value of <CODE>elt</CODE>, the argument to <CODE>byte-char-to-byte</CODE>, is of the wrong type. Notice too that <CODE>elt</CODE>'s type is not specified in the signature of <CODE>coerce-from-element</CODE>.</P>
<P>We need to know the value passed to <CODE>elt</CODE>. We can find out by expanding the <CODE>coerce-from-element</CODE> call frame: a call frame preceded by a <B>+</B> can be expanded to show the values of its arguments and local variables.</P>
<DL>
<DT><DD>4.  Expand the call frame for <CODE>coerce-from-element</CODE>.
</DL>
<P>We can now see the value that was passed for <CODE>elt</CODE>. It is an integer value, either 0, 1, or 2. It is this value that caused the error that occurred. This is the message again:</P>
<PRE>
Dylan error: <I>n</I> is not of type {&lt;class&gt;: &lt;BYTE-CHARACTER&gt;}
<P></P>
</PRE>
<P>where <I>n</I> is either 0, 1, or 2. </P>
<P>Our next task is to find out why <CODE>coerce-from-element</CODE> was sent an integer instead of a byte character. To do this, we can simply move down the backtrace and examine earlier calls.</P>
<DL>
<DT><DD>5.  Select the call frame for <CODE>write-element</CODE>.
</DL>
<P>We can see here that the value passed to <CODE>elt</CODE> in <CODE>coerce-from-element</CODE> is the value of one of <CODE>write-element</CODE>'s parameters, also called <CODE>elt</CODE>. </P>
<P>We need to move further down the stack to the <CODE>reversi-board-write-data</CODE> call. </P>
<DL>
<DT><DD>6.  <A NAME=MARKER-10-238></A>Select the call frame for <CODE>reversi-board-write-data</CODE>.
</DL>
<P>The <CODE>reversi-board-write-data</CODE> method takes an instance of <CODE>&lt;reversi-board&gt;</CODE> and an instance of <CODE>&lt;file-stream&gt;</CODE> as arguments. A <CODE>&lt;reversi-board&gt;</CODE> instance is what the application uses to represent the state of the board during a game. A <CODE>&lt;file-stream&gt;</CODE> is what Reversi is using to write the state of the board out into a file that can be re-loaded later.</P>
<P>We can see that this method calls <CODE>reversi-board-squares</CODE> on the <CODE>&lt;reversi-board&gt;</CODE> instance and then iterates over the value returned, apparently writing each element to the stream with <CODE>reversi-square-write-data</CODE>. (Notice that <CODE>reversi-square-write-data</CODE> does not appear on the stack--this is because it contains only a tail call to <CODE>write-element</CODE>, and so is optimized away.)</P>
<P>We are closing in on the bug. It is looking like the value representing the Reversi board squares (<CODE>squares</CODE>), and the file stream the squares are being written to (<CODE>stream</CODE>), have incompatible element types, with the squares being represented by integers, and the file stream being composed of byte characters. </P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Getting Started with Functional Developer - 31 MAR 2000</ADDRESS>
<P><A HREF="env_27.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="env_25.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="env_25.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="env_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="env_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="env_206.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
