<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="io_1.htm">
<LINK REL=UP HREF="io_71.htm">
<LINK REL=PREV HREF="io_135.htm">
<LINK REL=NEXT HREF="io_137.htm">
<TITLE> &lt;wrapper-stream&gt;</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING136></A>

<DIV>
<P><A HREF="io_137.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_135.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_71.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>5.11   The STREAMS module</P>

</DIV>
<A NAME=HEADING136-0></A>
<H1> <A NAME=MARKER-10-774></A><A NAME=MARKER-2-775></A><A NAME=MARKER-2-776></A><A NAME=MARKER-9-777></A>&lt;wrapper-stream&gt;</H1>
<P><I>Open instantiable class</I></P>
<H3>Summary</H3>
<P> The class of wrapper-streams.</P>
<H3>Superclasses</H3>
<P> <A HREF="io_115.htm#MARKER-9-672"><CODE>&lt;stream&gt;</CODE></A></P>
<H3>Init-keywords</H3>
<DL>
<P> </P><DT><CODE>inner-stream:</CODE><DD> An instance of <A HREF="io_115.htm#MARKER-9-672"><CODE>&lt;stream&gt;</CODE></A>.
</DL>
<H3>Library</H3>
<dl><dd><pre>io</pre></dl>
<H3>Module</H3>
<dl><dd><pre>streams</pre></dl>
<H3>Description</H3>
<P> The class that implements the basic wrapper-stream functionality.</P>
<P> It takes a required init-keyword <CODE>inner-stream:</CODE>, which is used to specify the wrapped stream.</P>
<P> The <A HREF="#MARKER-9-777"><CODE>&lt;wrapper-stream&gt;</CODE></A> class implements default methods for all of the stream protocol functions described in this document. Each default method on <A HREF="#MARKER-9-777"><CODE>&lt;wrapper-stream&gt;</CODE></A> simply "trampolines" to its inner stream.</P>
<H3>Operations</H3>
<P> <A HREF="io_91.htm#MARKER-9-547"><CODE>inner-stream</CODE></A> </P>
<P> <A HREF="io_92.htm#MARKER-9-552"><CODE>inner-stream-setter</CODE></A> </P>
<P> <A HREF="io_101.htm#MARKER-9-598"><CODE>outer-stream-setter</CODE></A> </P>
<H3>Example</H3>
<P> In the example below, <CODE>&lt;io-wrapper-stream&gt;</CODE>, a subclass of <A HREF="#MARKER-9-777"><CODE>&lt;wrapper-stream&gt;</CODE></A>, "passes on" functions such as <BR><A HREF="io_106.htm#MARKER-9-622"><CODE>read-element</CODE></A> and <A HREF="io_138.htm#MARKER-9-787"><CODE>write-element</CODE></A> by simply delegating these operations to the inner stream:</P>
<DL><DD><PRE>define method read-element (ws :: &lt;io-wrapper-stream&gt;,
                            #key on-end-of-stream)
    =&gt; (element)
  read-element(ws.inner-stream)
end method;</PRE></DL>
<DL><DD><PRE>define method write-element (ws :: &lt;io-wrapper-stream&gt;,
                             element)
    =&gt; ()
  write-element(ws.inner-stream,element)
end method;</PRE></DL>
<P> Assuming that <CODE>&lt;io-wrapper-stream&gt;</CODE> delegates all other operations to its inner stream, the following is sufficient to implement a 16-bit Unicode character stream wrapping an 8-bit character stream.</P>
<P> <A NAME=MARKER-10-778></A></P>
<DL><DD><PRE>define class &lt;unicode-stream&gt; (&lt;io-wrapper-stream&gt;) 
end class;</PRE></DL>
<DL><DD><PRE>define method read-element (s :: &lt;unicode-stream&gt;,
                            #key on-end-of-stream)
    =&gt; (ch :: &lt;unicode-character&gt;)
  with-stream-locked (s)
    let first-char =  read-element(s.inner-stream, 
                                   on-end-of-stream);
    let second-char = read-element(s.inner-stream, 
                                   on-end-of-stream);
  end;
  convert-byte-pair-to-unicode(first-char, second-char)
end method;</PRE></DL>
<DL><DD><PRE>define method write-element  (s :: &lt;unicode-stream&gt;, 
                              c :: &lt;character&gt;)
    =&gt; ()
  let (first-char, second-char) 
      = convert-unicode-to-byte-pair(c);
  with-stream-locked (s)
    write-element(s.inner-stream, first-char);
    write-element(s.inner-stream, second-char)
  end;
  c
end method;</PRE></DL>
<DL><DD><PRE>define method stream-position (s :: &lt;unicode-stream&gt;) 
  =&gt;  (p :: &lt;integer&gt;)
  truncate/(stream-position(s.inner-stream), 2)
end method;</PRE></DL>
<DL><DD><PRE>define method stream-position-setter  (p :: &lt;integer&gt;, 
                                s :: &lt;unicode-stream&gt;);
  stream-position(s.inner-stream) := p * 2
end method;</PRE></DL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>System and I/O Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="io_137.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_135.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_71.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
