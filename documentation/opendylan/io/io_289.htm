<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="io_1.htm">
<LINK REL=UP HREF="io_288.htm">
<LINK REL=PREV HREF="io_288.htm">
<LINK REL=NEXT HREF="io_290.htm">
<TITLE> &lt;buffered-socket&gt;</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING289></A>

<DIV>
<P><A HREF="io_290.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_288.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_288.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>10.4.5   The &lt;BUFFERED-SOCKET&gt; class</P>

</DIV>
<A NAME=HEADING289-0></A>
<H1> <A NAME=MARKER-2-2269></A><A NAME=MARKER-2-2270></A>&lt;buffered-socket&gt;</H1>
<P><I>Class</I></P>
<DL>
<DT><DD>Superclasses: <CODE>&lt;socket&gt;</CODE>, <CODE>&lt;double-buffered-stream&gt;</CODE> 
<DT><DD>Socket streams whose elements are bytes or characters. These inherit buffering protocols and the implications of <CODE>read</CODE>, <CODE>write</CODE>, <CODE>read-element</CODE>, <CODE>write-element</CODE>, <CODE>force-output</CODE> and suchlike methods from <CODE>&lt;double-buffered-stream&gt;</CODE>. 
<DT><DD>Keywords:
<DT><CODE>force-output-before-read?:</CODE> <DD><P></P>
<DT><DD>An instance of <CODE>&lt;boolean&gt;</CODE>. Defaults value: <CODE>#t</CODE>. The methods which implement the stream reading protocols (<CODE>read</CODE>, <CODE>read-line</CODE>, <CODE>read-element</CODE> and so on) for instances of <CODE>&lt;socket&gt;</CODE> call <CODE>force-output</CODE> by default before blocking. This is to ensure that any pending output has been sent to the peer before the socket blocks waiting to read data sent by the peer. This corresponds to the expected, usual behavior of single-threaded client sockets and avoids deadlock in usual cases. Multi-threaded applications, particularly applications where one thread is reading and another thread is writing to the same socket, may wish to inhibit the default <CODE>force-output</CODE>. If the socket is created with <CODE>force-output-before-read?:</CODE> as <CODE>#f</CODE>, <CODE>force-output</CODE> will not be called before the read functions block.
</DL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>System and I/O Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="io_290.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_288.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_288.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
