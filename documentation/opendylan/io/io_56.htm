<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="io_1.htm">
<LINK REL=UP HREF="io_55.htm">
<LINK REL=PREV HREF="io_55.htm">
<LINK REL=NEXT HREF="io_57.htm">
<TITLE>5.6.1   Reading from streams</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING56></A>

<DIV>
<P><A HREF="io_57.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_55.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_55.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>5.6   Reading from and writing to streams</P>

</DIV>
<A NAME=HEADING56-0></A>
<H1>5.6.1   <A NAME=MARKER-2-314></A><A NAME=MARKER-9-315></A>Reading from streams</H1>
<P>The following are the basic functions for reading from streams. </P>
<STRONG><A NAME=MARKER-10-316></A><A NAME=MARKER-2-317></A><A NAME=MARKER-2-318></A><A NAME=MARKER-9-319></A>read-element </STRONG>
<P><I>Open generic function</I></P>
<PRE>
read-element <I>input-stream</I> #key <I>on-end-of-stream</I> =&gt; <I>element-or-eof</I> 
</PRE>
<DL>
<DT><DD>Returns the next element in <I>input-stream</I>. If the stream is not at its end, the stream is advanced in preparation for a subsequent read operation.
<DT><DD>The <I>on-end-of-stream</I> keyword allows you to specify a value to be returned if the stream is at its end. If this is not supplied, <A HREF="io_106.htm#MARKER-9-622"><CODE>read-element</CODE></A> signals an <A HREF="io_84.htm#MARKER-9-515"><CODE>&lt;end-of-stream-error&gt;</CODE></A> condition on reading the end of the stream. 
<DT><DD>If no input is available and the stream is not at its end, <A HREF="io_106.htm#MARKER-9-622"><CODE>read-element</CODE></A> waits until input becomes available.
<DT><DD>See also <A HREF="io_69.htm#MARKER-9-409"><CODE>unread-element</CODE>,  page 58</A>.
</DL>
<STRONG><A NAME=MARKER-2-320></A><A NAME=MARKER-2-321></A><A NAME=MARKER-9-322></A>read</STRONG>
<P><I>Open generic function</I></P>
<PRE>
read <I>input-stream</I> <I>n</I> #key <I>on-end-of-stream</I> =&gt; <I>sequence-or-eof</I> 
<P></P>
</PRE>
<DL>
<DT><DD>Returns a sequence of the next <I>n</I> elements from <I>input-stream</I>. 
<DT><DD>The type of the sequence returned depends on the type of the stream's underlying aggregate. For instances of <A HREF="io_113.htm#MARKER-9-662"><CODE>&lt;sequence-stream&gt;</CODE></A>, the type of the result is given by <CODE>type-for-copy</CODE> of the underlying aggregate. For instances of <A HREF="io_88.htm#MARKER-9-531"><CODE>&lt;file-stream&gt;</CODE></A>, the result is a vector that can contain elements of the type returned by calling <A HREF="io_118.htm#MARKER-9-688"><CODE>stream-element-type</CODE></A> on the stream.
<DT><DD>The stream position is advanced so that the next call to any function that reads from or writes to <I>input-stream</I> acts on the stream position immediately following the last of the <I>n</I> elements read. 
<DT><DD>If the stream is not at its end, <A HREF="io_105.htm#MARKER-9-616"><CODE>read</CODE></A> waits until input becomes available.
<DT><DD>If the end of the stream is reached before all <I>n</I> elements have been read, the behavior is as follows. 
<DT><DD>If <I>on-end-of-stream</I> was supplied, it is returned as the value of <A HREF="io_105.htm#MARKER-9-616"><CODE>read</CODE></A>. 
<DT><DD>If <I>on-end-of-stream</I> argument was not supplied, and at least one element was read from the stream, then an <A HREF="io_90.htm#MARKER-9-543"><CODE>&lt;incomplete-read-error&gt;</CODE></A> condition is signalled. When signalling this condition, <A HREF="io_105.htm#MARKER-9-616"><CODE>read</CODE></A> supplies two values: a sequence of the elements that were read successfully, and <I>n</I>. 
<DT><DD>If <I>on-end-of-stream</I> was not supplied, and no elements were read from the stream, an <A HREF="io_84.htm#MARKER-9-515"><CODE>&lt;end-of-stream-error&gt;</CODE></A> condition is signalled.
<DT><DD>The second of these is in some sense the most general behavior, in that the first and third cases could, in principle, be duplicated by using the second case, handling the signalled <CODE>&lt;incomplete-read-error&gt;</CODE>, and returning appropriate results.
</DL>
<P><A NAME=MARKER-10-323></A>A number of other functions are available for reading from streams. See <A HREF="io_102.htm#MARKER-9-603"><CODE>peek</CODE>,  page 81</A>, <A HREF="io_107.htm#MARKER-9-626"><CODE>read-into!</CODE>,  page 85</A>, <A HREF="io_82.htm#MARKER-9-504"><CODE>discard-input</CODE>,  page 66</A>, and <A HREF="io_119.htm#MARKER-9-693"><CODE>stream-input-available?</CODE>,  page 96</A>.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>System and I/O Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="io_57.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_55.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_55.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
