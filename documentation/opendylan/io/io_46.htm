<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997) -->
<HEAD>
<LINK REL=TOP HREF="io_1.htm">
<LINK REL=UP HREF="io_42.htm">
<LINK REL=PREV HREF="io_45.htm">
<LINK REL=NEXT HREF="io_47.htm">
<TITLE>5.4   Concepts</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV>
<A NAME=HEADING46></A>

<DIV>
<P><A HREF="io_47.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_45.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_42.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>5 The Streams Module</P>

</DIV>
<A NAME=HEADING46-0></A>
<A NAME=UID-streams-886201></A>
<H1>5.4   <A NAME=MARKER-2-268></A><A NAME=MARKER-9-269></A>Concepts</H1>
<P>A <I>stream</I> provides sequential access to an aggregate of data, such as a Dylan sequence or a disk file. Streams grant this access according to a metaphor of <I>reading</I> and <I>writing</I>: elements can be read from streams or written to them.</P>
<P>Streams are represented as Dylan objects, and all are general instances of the class <A HREF="io_115.htm#MARKER-9-672"><CODE>&lt;stream&gt;</CODE></A>, which the Streams module defines.</P>
<P>It is usual to say that a stream is established <I>over</I> the data aggregate. Hence, a stream providing access to the string <CODE>&quot;hello world&quot;</CODE> is said to be a stream over the string <CODE>&quot;hello world&quot;</CODE>.</P>
<P>Streams permitting reading operations are called <I>input</I> streams. Input streams allow elements from the underlying data aggregate to be consumed. Conversely, streams permitting writing operations are called <I>output</I> streams. Output streams allow elements to be written to the underlying data aggregate. Streams permitting both kinds of operations are called <I>input-output</I> streams. </P>
<P>The Streams module provides a set of functions for reading elements from an input stream. These functions hide the details of indexing, buffering, and so on. For instance, the function <A HREF="io_106.htm#MARKER-9-622"><CODE>read-element</CODE></A> reads a single data element from an input stream. </P>
<P>The following expression binds <CODE>stream</CODE> to an input stream over the string <CODE>&quot;hello world&quot;</CODE>: </P>
<PRE>
let stream = make(&lt;string-stream&gt;, contents: &quot;hello world&quot;);
<P></P>
</PRE>
<P>The first invocation of <A HREF="io_106.htm#MARKER-9-622"><CODE>read-element</CODE></A> on <CODE>stream</CODE> returns the character "h", the next invocation "e", and so on. Once a stream has been used to consume all the elements of the data, the stream is said to be at its end. This condition can be tested with the function <A HREF="io_116.htm#MARKER-9-679"><CODE>stream-at-end?</CODE></A>. The following code fragment applies <CODE>my-function</CODE> to all elements of the sequence:</P>
<PRE>
let stream = make(&lt;sequence-stream&gt;, contents: seq);
while (~stream-at-end?(stream)) 
  my-function(read-element(stream));
end;
<P></P>
</PRE>
<P>When all elements of a stream have been read, further calls to <A HREF="io_106.htm#MARKER-9-622"><CODE>read-element</CODE></A> result in the <A HREF="io_84.htm#MARKER-9-515"><CODE>&lt;end-of-stream-error&gt;</CODE></A> condition being signaled. An alternative end-of-stream behavior is to have a distinguished end-of-stream value returned. You can supply such an end-of-stream value as a keyword argument to the various read functions; the value can be any object. Supplying an end-of-stream value to a read function is more concise than asking whether a stream is at its end on every iteration of a loop.</P>
<P>The Streams module also provides a set of functions for writing data elements to an output stream. Like the functions that operate upon input streams, these functions hide the details of indexing, growing an underlying sequence, buffering for a file, and so on. For instance, the function <A HREF="io_138.htm#MARKER-9-787"><CODE>write-element</CODE></A> writes a single data element to an output stream. </P>
<P>The following forms bind <CODE>stream</CODE> to an output stream over an empty string and create the string "I see!", using the function <A HREF="io_117.htm#MARKER-9-684"><CODE>stream-contents</CODE></A> to access all of the stream's elements.</P>
<PRE>
let stream = make(&lt;byte-string-stream&gt;, direction: #&quot;output&quot;);
write(stream, &quot;I see!&quot;);
stream-contents(stream);
<P></P>
</PRE>
<P>Calling <A HREF="io_137.htm#MARKER-9-782"><CODE>write</CODE></A> on a sequence has the same effect as calling <A HREF="io_138.htm#MARKER-9-787"><CODE>write-element</CODE></A> on all the elements of the sequence. For more information about writing to streams, see <A HREF="io_58.htm#MARKER-9-334">Section 5.6.3 on page 46</A>. </P>
<P>Some streams are <I>positionable</I>; that is, any element of the stream can be accessed at any time. Positionable streams allow you to set the position at which the stream is accessed by the next operation. The following example uses positioning to return the character "w" from a stream over the string <CODE>&quot;hello world&quot;</CODE>:</P>
<PRE>
let stream = make(&lt;string-stream&gt;, contents: &quot;hello world&quot;);
stream-position(stream) := 6;
read-element(stream);
<P></P>
</PRE>
<P>The following example returns a string. The first ten characters are the fill characters for the underlying sequence of the stream. The fill character for <CODE>&lt;string&gt;</CODE> is "<CODE> </CODE>" (the space character), so in the example below, the first ten characters are spaces.</P>
<PRE>
let stream = make(&lt;string-stream&gt;, direction: #&quot;output&quot;);
adjust-stream-position(stream, 10); 
write(stream, &quot;whoa!&quot;);
stream-contents(stream);
<P></P>
</PRE>
<P>You can request a sequence containing all of the elements of a positionable stream by calling <A HREF="io_117.htm#MARKER-9-684"><CODE>stream-contents</CODE></A> on it. If the positionable stream is a <CODE>&lt;file-stream&gt;</CODE>, then it must be readable. Otherwise, it must be a sequence stream. The sequence returned never shares structure with any underlying sequence that might be used in the future by the stream. For instance, the string returned by calling <A HREF="io_117.htm#MARKER-9-684"><CODE>stream-contents</CODE></A> on an output <A HREF="io_127.htm#MARKER-9-738"><CODE>&lt;string-stream&gt;</CODE></A> will not be the same string as that being used to represent the string stream.</P>
<P>When making an input <A HREF="io_127.htm#MARKER-9-738"><CODE>&lt;string-stream&gt;</CODE></A>, you can cause the stream to produce elements from any subsequence of the supplied string. For example:</P>
<PRE>
read-to-end(make(&lt;string-stream&gt;, 
                 contents: &quot;hello there, world&quot;,
                 start: 6, 
                 end: 11));
<P></P>
</PRE>
<P>This example evaluates to <CODE>&quot;there&quot;</CODE>. The interval (<I>start</I>, <I>end</I>) includes the index <I>start</I> but excludes the index <I>end</I>. This is consistent with standard Dylan functions over sequences, such as <CODE>copy-sequence</CODE>. The <A HREF="io_112.htm#MARKER-9-657"><CODE>read-to-end</CODE></A> function is one of a number of convenient utility functions for operating on streams and returns all the elements up to the end of the stream from the stream's current position.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC --><DL>
<DL>
<DT><A REL=BELOW HREF="io_47.htm#HEADING47-0"><B>5.4.1  </B> - Streams, growing sequences, and object identity</A>
<DD>
</DL>
</DL>


</DIV>

<HR>
<ADDRESS>System and I/O Reference - 31 MAR 2000</ADDRESS>
<P><A HREF="io_47.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="io_45.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="io_42.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A> <A HREF="io_1.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="io_2.htm"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="io_333.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
